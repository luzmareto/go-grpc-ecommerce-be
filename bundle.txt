====================
FILE: D:\go-grpc-ecommerce-be\cmd\grpc\main.go
====================
package main

// go run cmd/grpc/main.go

import (
	"context"
	"log"
	"net"
	"os"
	"time"

	"github.com/joho/godotenv" //import manual
	grpcmiddleware "github.com/luzmareto/go-grpc-ecommerce-be/internal/grpcMiddleware"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/handler"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/repository"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/service"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/auth"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/cart"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/order"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/product"
	"github.com/luzmareto/go-grpc-ecommerce-be/pkg/database"
	gocache "github.com/patrickmn/go-cache"
	"github.com/xendit/xendit-go"
	"google.golang.org/grpc"            //import manual
	"google.golang.org/grpc/reflection" //import manual
)

func main() {
	ctx := context.Background()
	godotenv.Load()

	xendit.Opt.SecretKey = os.Getenv("XENDIT_SECRET")
	
	lis, err := net.Listen("tcp", ":50052")
	if err != nil {
		log.Panicf("error when listen %v", err)
	}

	db := database.ConnectDB(ctx, os.Getenv("DB_URI"))
	log.Println("Connected to database")

	cacheService := gocache.New(time.Hour*24, time.Hour)

	authMiddleware := grpcmiddleware.NewAuthMiddleware(cacheService)

	authRepository := repository.NewAuthRepository(db)
	authService := service.NewAuthService(authRepository, cacheService)
	authHandler := handler.NewAuthHandler(authService)

	productRepository := repository.NewProductRepository(db)
	productService := service.NewProductService(productRepository)
	productHandler := handler.NewProductHandler(productService)
	
	cartRepository := repository.NewCartRepository(db)
	cartService := service.NewCartService(productRepository, cartRepository)
	cartHandler := handler.NewCartHandler(cartService)

	orderRepository := repository.NewOrderRepository(db)
	orderService := service.NewOrderService(db, orderRepository,productRepository)
	orderHandler := handler.NewOrderHandler(orderService)

	serv := grpc.NewServer(
		grpc.ChainUnaryInterceptor(
			grpcmiddleware.ErrorMiddleware,
			authMiddleware.Middleware,
		),
	)

	auth.RegisterAuthServiceServer(serv, authHandler)
	product.RegisterProductServiceServer(serv, productHandler)
	cart.RegisterCartServiceServer(serv, cartHandler)
	order.RegisterOrderServiceServer(serv, orderHandler)

	if os.Getenv("ENVIRONMENT") == "dev" {
		reflection.Register(serv)
		log.Println("Reflection is registered.")
	}

	log.Println("Server is runing on :50052 port.")
	if err := serv.Serve(lis); err != nil {
		log.Panicf("Server is error %v", err)
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\cmd\rest\main.go
====================
package main

// go run cmd/rest/main.go

import (
	"context"
	"log"
	"mime"
	"net/http"
	"os"
	"path"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/joho/godotenv"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/handler"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/repository"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/service"
	"github.com/luzmareto/go-grpc-ecommerce-be/pkg/database"
)

func handlerGetFileName(c *fiber.Ctx) error {
	fileNameParam := c.Params("filename")
	filePath := path.Join("storage", "product", fileNameParam)
	if _, err := os.Stat(filePath); err != nil {
		if os.IsNotExist(err) {
			return c.Status(http.StatusNotFound).SendString("Not found")
		}
		log.Println(err)
		return c.Status(http.StatusInternalServerError).SendString("Internal Server Error")
	}

	file, err := os.Open(filePath)
	if err != nil {
		log.Println(err)
		return c.Status(http.StatusInternalServerError).SendString("Internal Server Error")
	}

	ext := path.Ext(filePath)
	mimeType := mime.TypeByExtension(ext)

	c.Set("Content-Type", mimeType)

	return c.SendStream(file)
}

func main() {
	godotenv.Load()
	ctx := context.Background()
	app := fiber.New()

	db := database.ConnectDB(ctx, os.Getenv("DB_URI"))
	orderRepository := repository.NewOrderRepository(db)
	webhookService := service.NewWebhookService(orderRepository)
	webHookHandler := handler.NewWebhookHandler(webhookService)

	app.Use(cors.New())

	app.Get("/storage/products/:filename", handlerGetFileName) // Untuk List Product
	app.Get("/storage/product/:filename", handlerGetFileName)  // Untuk Detail/Edit Product

	app.Post("/product/upload", handler.UploadProductImageHandler)
	app.Post("/products/upload", handler.UploadProductImageHandler)

	app.Post("/webhook/xendit/invoice", webHookHandler.ReceiveInvoice)

	app.Listen(":3000")
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\dto\webhook_receive_invoice.go
====================
package dto

import "time"

type XenditInvoiceRequest struct {
	ID                     string    `json:"id"`
	ExternalID             string    `json:"external_id"`
	UserID                 string    `json:"user_id"`
	IsHigh                 bool      `json:"is_high"`
	PaymentMethod          string    `json:"payment_method"`
	Status                 string    `json:"status"`
	MerchantName           string    `json:"merchant_name"`
	Amount                 int       `json:"amount"`
	PaidAmount             int       `json:"paid_amount"`
	BankCode               string    `json:"bank_code"`
	PaidAt                 time.Time `json:"paid_at"`
	PayerEmail             string    `json:"payer_email"`
	Description            string    `json:"description"`
	AdjustedReceivedAmount int       `json:"adjusted_received_amount"`
	FeesPaidAmount         int       `json:"fees_paid_amount"`
	Updated                time.Time `json:"updated"`
	Created                time.Time `json:"created"`
	Currency               string    `json:"currency"`
	PaymentChannel         string    `json:"payment_channel"`
	PaymentDestination     string    `json:"payment_destination"`
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\entity\cart.go
====================
package entity

import "time"

type UserCart struct {
	Id        string
	UserId    string
	ProductId string
	Quantity  int
	CreatedAt time.Time
	CreatedBy string
	UpdatedAt *time.Time
	UpdatedBy *string

	Product *Product
}



====================
FILE: D:\go-grpc-ecommerce-be\internal\entity\jwt\jwt.go
====================
package jwt

import (
	"context"
	"fmt"
	"os"

	"github.com/golang-jwt/jwt/v5"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
)

type JwtClaims struct {
	jwt.RegisteredClaims
	Email    string `json:"email"`
	FullName string `json:"full_name"`
	Role     string `json:"role"`
}

type JwtEntityContextKey string

var JwtEntityContextKeyValue JwtEntityContextKey = "JwtEntity"

func (jc *JwtClaims) SetToContext(ctx context.Context) context.Context {
	return context.WithValue(ctx, JwtEntityContextKeyValue, jc)

}

func GetClaimsFromToken(token string) (*JwtClaims, error) {

	tokenClaims, err := jwt.ParseWithClaims(token, &JwtClaims{}, func(t *jwt.Token) (any, error) {
		if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing  method %v", t.Header["alg"])
		}

		return []byte(os.Getenv("JWT_SECRET")), nil
	})
	if err != nil {
		return nil, utils.UnauthenticatedResponse()
	}

	if !tokenClaims.Valid {
		return nil, utils.UnauthenticatedResponse()
	}

	if claims, ok := tokenClaims.Claims.(*JwtClaims); ok {
		return claims, nil
	}

	return nil, utils.UnauthenticatedResponse()
}

func GetClaimsFromContext(ctx context.Context) (*JwtClaims, error) {
	claims, ok := ctx.Value(JwtEntityContextKeyValue).(*JwtClaims)
	if !ok {
		return nil, utils.UnauthenticatedResponse()
	}

	return claims, nil
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\entity\jwt\parse.go
====================
package jwt

import (
	"context"
	"strings"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"google.golang.org/grpc/metadata"
)

func ParseTokenFromContext(ctx context.Context) (string, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return "", utils.UnauthenticatedResponse()
	}

	bearerToken, ok := md["authorization"]
	if !ok {
		return "", utils.UnauthenticatedResponse()
	}

	if len(bearerToken) == 0 {
		return "", utils.UnauthenticatedResponse()
	}

	tokenSplit := strings.Split(bearerToken[0], " ")
	if len(tokenSplit) != 2 {
		return "", utils.UnauthenticatedResponse()
	}

	if tokenSplit[0] != "Bearer" {
		return "", utils.UnauthenticatedResponse()
	}

	return tokenSplit[1], nil
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\entity\numbering.go
====================
package entity

type Numbering struct {
	Module string
	Number int64
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\entity\order.go
====================
package entity

import "time"

const (
	OrderStatusCodeUnpaid   = "unpaid"
	OrderStatusCodePaid     = "paid"
	OrderStatusCodeShipped  = "shipped"
	OrderStatusCodeDone     = "done"
	OrderStatusCodeExpired  = "expired"
	OrderStatusCodeCanceled = "canceled"
)

type Order struct {
	Id                   string
	Number               string
	UserId               string
	OrderStatusCode      string
	UserFullName         string
	Address              string
	PhoneNumber          string
	Notes                *string
	Total                float64
	ExpiredAt            *time.Time
	CreatedAt            time.Time
	CreatedBy            string
	UpdatedAt            *time.Time
	UpdatedBy            *string
	DeletedAt            *time.Time
	DeletedBy            *string
	IsDeleted            bool
	XenditInvoiceId      *string
	XenditInvoiceUrl     *string
	XenditPaidAt         *time.Time
	XenditPaymentMethod  *string
	XenditPaymentChannel *string

	Items []*OrderItem
}

type OrderItem struct {
	Id                   string
	ProductId            string
	ProductName          string
	ProductImageFileName string
	ProductPrice         float64
	Quantity             int64
	OrderId              string
	CreatedAt            time.Time
	CreatedBy            string
	UpdatedAt            *time.Time
	UpdatedBy            *string
	DeletedAt            *time.Time
	DeletedBy            *string
	IsDeleted            bool
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\entity\product.go
====================
package entity

import "time"

type Product struct {
	Id            string
	Name          string
	Description   string
	Price         float64
	ImageFileName string
	CreatedAt     time.Time
	CreatedBy     string
	UpdatedAt     time.Time
	UpdatedBy     *string
	DeletedAt     time.Time
	DeletedBy     *string
	IsDeleted     bool
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\entity\user.go
====================
package entity

import "time"

const (
	UserRoleCustomer = "customer"
	UserRoleAdmin    = "admin"
)

type UserRole struct {
	Id        string
	Name      string
	Code      string
	CreatedAt time.Time
	CreatedBy string
	UpdatedAt time.Time
	UpdatedBy string
	DeletedAt time.Time
	DeletedBy string
	IsDeleted bool
}

type User struct {
	Id        string
	FullName  string
	Email     string
	Password  string
	RoleCode  string
	CreatedAt time.Time
	CreatedBy string
	UpdatedAt time.Time
	UpdatedBy string
	DeletedAt time.Time
	DeletedBy string
	IsDeleted bool
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\grpcMiddleware\auth_middleware.go
====================
package grpcmiddleware

import (
	"context"

	jwtentity "github.com/luzmareto/go-grpc-ecommerce-be/internal/entity/jwt"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	gocache "github.com/patrickmn/go-cache"
	"google.golang.org/grpc"
)

type authMiddleware struct {
	cacheService *gocache.Cache
}

//api yang tidak perlu login
var publicApis = map[string]bool{
	 "/auth.AuthService/Login": true,
	 "/auth.AuthService/Register": true,
	 "/product.ProductService/DetailProduct": true,
	 "/product.ProductService/ListProduct": true,
	 "/product.ProductService/ListProducts": true,
	 "/product.ProductService/HighlightProducts": true,
	 "/product.ProductService/HighlightProduct": true,
}


func (am *authMiddleware) Middleware(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any, err error) {
	if publicApis[info.FullMethod] {
		return handler(ctx, req)
	}

	// ambil token dari metada
	tokenstr, err := jwtentity.ParseTokenFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// cek token dari logout cache
	_, ok := am.cacheService.Get(tokenstr)
	if ok {
		return nil, utils.UnauthenticatedResponse()
	}

	// parse jwt hingga menjadi jwt
	claims, err := jwtentity.GetClaimsFromToken(tokenstr)
	if err != nil {
		return nil, err
	}

	// sematkan entity ke context
	ctx = claims.SetToContext(ctx)

	res, err := handler(ctx, req)

	return res, err
}

func NewAuthMiddleware(cacheService *gocache.Cache) *authMiddleware {
	return &authMiddleware{
		cacheService: cacheService,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\grpcMiddleware\error_middleware.go
====================
package grpcmiddleware

import (
	"context"
	"log"
	"runtime/debug"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func ErrorMiddleware(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any, err error) {
	defer func() {
		if r := recover(); r != nil {
			log.Println(r)
			debug.PrintStack()
			err = status.Errorf(codes.Internal, "internal server error")
		}
	}()
	res, err := handler(ctx, req)
	if err != nil {
		log.Println(err)
		if st, ok := status.FromError(err); ok {
			if st.Code() == codes.Unauthenticated {
				return nil, err
			}
		}

		return nil, status.Error(codes.Internal, "internal server error")
	}
	return res, err
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\handler\auth.go
====================
package handler

import (
	"context"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/service"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/auth"
)

type authHandler struct {
	auth.UnimplementedAuthServiceServer

	authService service.IAuthService
}


func (sh *authHandler) Register(ctx context.Context, request *auth.RegisterRequest) (*auth.RegisterResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &auth.RegisterResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	// process Register
	res, err := sh.authService.Register(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil

}

func (sh *authHandler) Login(ctx context.Context, request *auth.LoginRequest) (*auth.LoginResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &auth.LoginResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	// process Register
	res, err := sh.authService.Login(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (sh *authHandler) Logout(ctx context.Context, request *auth.LogoutRequest) (*auth.LogoutResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &auth.LogoutResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := sh.authService.Logout(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (sh *authHandler) ChangePassword(ctx context.Context, request *auth.ChangePasswordRequest) (*auth.ChangePasswordResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &auth.ChangePasswordResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}
	res, err := sh.authService.ChangePassword(ctx, request)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (sh *authHandler) GetProfile(ctx context.Context, request *auth.GetProfileRequest) (*auth.GetProfileResponse, error) {
	res, err := sh.authService.GetProfile(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func NewAuthHandler(authService service.IAuthService) *authHandler {
	return &authHandler{
		authService: authService,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\handler\cart.go
====================
package handler

import (
	"context"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/service"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/cart"
)

type cartHandler struct {
	cart.UnimplementedCartServiceServer

	cartService service.ICartService
}

func (ch *cartHandler) AddProductToCart(ctx context.Context, request *cart.AddProductToCartRequest) (*cart.AddProductToCartResponse, error){
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &cart.AddProductToCartResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ch.cartService.AddProductToCart(ctx, request)
	if err != nil {
		return nil, err
	}

	return  res, nil
}


func (ch *cartHandler)  ListCart(ctx context.Context,request *cart.ListCartRequest) (*cart.ListCartResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &cart.ListCartResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ch.cartService.ListCart (ctx, request)
	if err != nil {
		return nil, err
	}

	return  res, nil
}
func (ch *cartHandler) DeleteCart(ctx context.Context,request *cart.DeleteCartRequest) (*cart.DeleteCartResponse, error){
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &cart.DeleteCartResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ch.cartService.DeleteCart (ctx, request)
	if err != nil {
		return nil, err
	}

	return  res, nil
}

func (ch *cartHandler) UpdateCartQuantity(ctx context.Context, request *cart.UpdateCartQuantityRequest) (*cart.UpdateCartQuantityResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &cart.UpdateCartQuantityResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ch.cartService.UpdateCartQuantity (ctx, request)
	if err != nil {
		return nil, err
	}

	return  res, nil
}

func NewCartHandler(cartService service.ICartService) *cartHandler {
	return &cartHandler{
		cartService: cartService,
	}
}



====================
FILE: D:\go-grpc-ecommerce-be\internal\handler\order.go
====================
package handler

import (
	"context"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/service"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/order"
)

type orderHandler struct {
	order.UnimplementedOrderServiceServer

	orderService service.IOrderService
}

func (oh *orderHandler) CreateOrder(ctx context.Context, request *order.CreateOrderRequest) (*order.CreateOrderResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &order.CreateOrderResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := oh.orderService.CreateOrder(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (oh *orderHandler) ListOrderAdmin(ctx context.Context, request *order.ListOrderAdminRequest) (*order.ListOrderAdminResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &order.ListOrderAdminResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := oh.orderService.ListOrderAdmin(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (oh *orderHandler) ListOrder(ctx context.Context, request *order.ListOrderRequest) (*order.ListOrderResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &order.ListOrderResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := oh.orderService.ListOrder(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (oh *orderHandler) DetailOrder(ctx context.Context, request *order.DetailOrderRequest) (*order.DetailOrderResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &order.DetailOrderResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := oh.orderService.DetailOrder(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (oh *orderHandler) UpdateOrderStatus(ctx context.Context, request *order.UpdateOrderStatusRequest) (*order.UpdateOrderStatusResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &order.UpdateOrderStatusResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := oh.orderService.UpdateOrderStatus(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func NewOrderHandler(orderService service.IOrderService) *orderHandler {
	return &orderHandler{
		orderService: orderService,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\handler\product.go
====================
package handler

import (
	"context"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/service"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/product"
)

type productHandler struct {
	product.UnimplementedProductServiceServer

	productService service.IProductService
}

func (ph *productHandler) CreateProduct(ctx context.Context, request *product.CreateProductRequest) (*product.CreateProductResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &product.CreateProductResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ph.productService.CreateProduct(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil

}

func (ph *productHandler) DetailProduct(ctx context.Context,request *product.DetailProductRequest) (*product.DetailProductResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &product.DetailProductResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ph.productService.DetailProduct(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil

}

func (ph *productHandler) EditProduct(ctx context.Context, request *product.EditProductRequest) (*product.EditProductResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &product.EditProductResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ph.productService.EditProduct(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil

}

func (ph *productHandler) DeleteProduct(ctx context.Context, request *product.DeleteProductRequest) (*product.DeleteProductResponse, error) {
validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &product.DeleteProductResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ph.productService.DeleteProduct(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil

}

func (ph *productHandler) ListProduct(ctx context.Context, request *product.ListProductRequest) (*product.ListProductResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &product.ListProductResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ph.productService.ListProduct(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil

}
func (ph *productHandler) ListProductAdmin(ctx context.Context, request *product.ListProductAdminRequest) (*product.ListProductAdminResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &product.ListProductAdminResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ph.productService.ListProductAdmin(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil

}

func (ph *productHandler) HighlightProducts(ctx context.Context,request *product.HighlightProductsRequest) (*product.HighlightProductsResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &product.HighlightProductsResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	res, err := ph.productService.HighlightProducts(ctx, request)
	if err != nil {
		return nil, err
	}

	return res, nil

}


func NewProductHandler(productService service.IProductService) *productHandler {
	return &productHandler{
		productService: productService,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\handler\product_upload_image.go
====================
package handler

import (
	"fmt"
	"net/http"
	"path/filepath"
	"strings"
	"time"

	"github.com/gofiber/fiber/v2"
)

func UploadProductImageHandler(c *fiber.Ctx) error {
	file, err := c.FormFile("image")
	if err != nil {
		return c.Status(http.StatusBadRequest).JSON(fiber.Map{
			"success": false,
			"message": "image data not found",
		})
	}

	ext := strings.ToLower(filepath.Ext(file.Filename))
	allowedExts := map[string]bool{
		".jpg":  true,
		".jpeg": true,
		".png":  true,
		".webp": true,
	}
	if !allowedExts[ext] {
		return c.Status(http.StatusBadRequest).JSON(fiber.Map{
			"success": false,
			"message": "image extension is not allowed (jtp, jpeg, png, webp)",
		})
	}

	contentType := file.Header.Get("Content-Type")
	allowedContentType := map[string]bool{
		"image/jpeg": true,
		"image/png":  true,
		"image/webp": true,
	}
	if !allowedContentType[contentType] {
		return c.Status(http.StatusBadRequest).JSON(fiber.Map{
			"success": false,
			"message": "image type is not allowed",
		})
	}

	timestamp := time.Now().UnixNano()
	fileName := fmt.Sprintf("product_%d%s", timestamp, filepath.Ext(file.Filename))
	uploadPath := "./storage/product/" + fileName
	err = c.SaveFile(file, uploadPath)
	if err != nil {
		fmt.Println(err)
		return c.Status(http.StatusInternalServerError).JSON(fiber.Map{
			"success": false,
			"message": "internal server error",
		})
	}

	return c.JSON(fiber.Map{
		"success":  true,
		"message":  "upload success",
		"fileName": fileName,
	})
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\handler\service.go
====================
package handler

import (
	"context"
	"fmt"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/service"
)

type serivceHandler struct {
	service.UnimplementedHelloWorldServiceServer
}

func (sh *serivceHandler) HelloWorld(ctx context.Context, request *service.HelloWordlRequest) (*service.HelloWorldResponse, error) {
	validationErrors, err := utils.CheckValidation(request)
	if err != nil {
		return nil, err
	}
	if validationErrors != nil {
		return &service.HelloWorldResponse{
			Base: utils.ValidationErrorResponse(validationErrors),
		}, nil
	}

	return &service.HelloWorldResponse{
		Message: fmt.Sprintf("hello %s", request.Name),
		Base:    utils.SuccessResponse("Success"),
	}, nil

}

func NewServiceHandler() *serivceHandler {
	return &serivceHandler{}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\handler\webhook_handler.go
====================
package handler

import (
	"log"
	"net/http"

	"github.com/gofiber/fiber/v2"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/dto"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/service"
)

type webhookHandler struct {
	webhookService service.IWebhookService
}

func (wh *webhookHandler) ReceiveInvoice(c *fiber.Ctx) error {
	var request dto.XenditInvoiceRequest
	err := c.BodyParser(&request)
	if err != nil {
		log.Println(err)
		return c.SendStatus(http.StatusBadRequest)
	}

	err = wh.webhookService.ReceiveInvoice(c.UserContext(), &request)
	if err != nil {
		log.Println(err)
		return c.SendStatus(http.StatusInternalServerError)
	}

	return c.SendStatus(http.StatusOK)
}

func NewWebhookHandler(webhookService service.IWebhookService) *webhookHandler {
	return &webhookHandler{
		webhookService: webhookService,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\repository\auth.repository.go
====================
package repository

import (
	"context"
	"database/sql"
	"errors"
	"log"
	"time"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
)

type IAuthRepository interface {
	GetUserByEmail(ctx context.Context, email string) (*entity.User, error)
	InsertUser(ctx context.Context, user *entity.User) error
	UpdateUserPassword(ctx context.Context, userID string, hashedNewPasswrod string, updateBy string) error
}

type authRepository struct {
	db *sql.DB
}

func (ar *authRepository) GetUserByEmail(ctx context.Context, email string) (*entity.User, error) {
	row := ar.db.QueryRowContext(ctx, "SELECT id, email, password, full_name, role_code, created_at FROM \"user\" WHERE email = $1 AND is_deleted IS false", email)
	if row.Err() != nil {
		return nil, row.Err()
	}

	var user entity.User
	err := row.Scan(
		&user.Id,
		&user.Email,
		&user.Password,
		&user.FullName,
		&user.RoleCode,
		&user.CreatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}

	return &user, nil
}

func (ar *authRepository) InsertUser(ctx context.Context, user *entity.User) error {
	_, err := ar.db.ExecContext(
		ctx,
		"INSERT INTO \"user\" (id, full_name, email, password, role_code, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by, is_deleted) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)",
		user.Id,
		user.FullName,
		user.Email,
		user.Password,
		user.RoleCode,
		user.CreatedAt,
		user.CreatedBy,
		user.UpdatedAt,
		user.UpdatedBy,
		user.DeletedAt,
		user.DeletedBy,
		user.IsDeleted,
	)
	if err != nil {
		log.Printf("[ERROR][InsertUser] gagal insert user %s: %v", user.Email, err)
		return err
	}
	return nil
}

func (ar *authRepository) UpdateUserPassword(ctx context.Context, userID string, hashedNewPasswrod string, updateBy string) error {
	_, err := ar.db.ExecContext(
		ctx,
		"UPDATE \"user\" SET password = $1, updated_at = $2, updated_by = $3 WHERE id = $4",
		hashedNewPasswrod,
		time.Now(),
		updateBy,
		userID,
	)
	if err != nil {
		return err
	}

	return nil
}

func NewAuthRepository(db *sql.DB) IAuthRepository {
	return &authRepository{
		db: db,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\repository\cart_repository.go
====================
package repository

import (
	"context"
	"database/sql"
	"errors"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
)

type ICartRepository interface {
	GetCartByProductAndUserId(ctx context.Context, ProductId, userID string) (*entity.UserCart,error)
	CreateNewCart(ctx context.Context, cart *entity.UserCart) error
	UpdateCart(ctx context.Context, cart *entity.UserCart) error
	GetlistCart (ctx context.Context, userId string) ([]*entity.UserCart, error)
	GetCartById (ctx context.Context, cartId string) (*entity.UserCart, error)
	DeleteCart (ctx context.Context, cartId string) error
}

type cartRepository struct {
	db *sql.DB
}

func (cr *cartRepository) GetCartByProductAndUserId(ctx context.Context, ProductId, userId string) (*entity.UserCart,error) {
	row := cr.db.QueryRowContext(
		ctx,
		"SELECT id, product_id, user_id, quantity, created_at, created_by, updated_at, updated_by FROM user_cart WHERE product_id = $1 AND user_id = $2",
		ProductId,
		userId,
	)
	if row.Err() != nil {
		return  nil, row.Err()
	}

	var cartEntity entity.UserCart
	err :=  row.Scan(
		&cartEntity.Id,
		&cartEntity.ProductId,
		&cartEntity.UserId,
		&cartEntity.Quantity,
		&cartEntity.CreatedAt,
		&cartEntity.CreatedBy,
		&cartEntity.UpdatedAt,
		&cartEntity.UpdatedBy,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows){
			return nil, nil
		}
		return nil, err
	}

	return  &cartEntity, nil
}

func (cs *cartRepository) CreateNewCart(ctx context.Context, cart *entity.UserCart) error {
	_, err :=cs.db.ExecContext(
		ctx,
		"INSERT INTO user_cart (id, product_id, user_id, quantity, created_at, created_by, updated_at, updated_by) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)",
		cart.Id,
		cart.ProductId,
		cart.UserId,
		cart.Quantity,
		cart.CreatedAt,
		cart.CreatedBy,
		cart.UpdatedAt,
		cart.UpdatedBy,
	)
	if err != nil {
		return err
	}
	return nil
}

func (cs *cartRepository) UpdateCart(ctx context.Context, cart *entity.UserCart) error{
	_, err :=cs.db.ExecContext(
		ctx,
		"UPDATE user_cart SET product_id = $1, user_id= $2, quantity = $3, updated_at = $4, updated_by = $5 WHERE id = $6",
		cart.ProductId,
		cart.UserId,
		cart.Quantity,
		cart.UpdatedAt,
		cart.UpdatedBy,
		cart.Id,
	)
	if err != nil {
		return err
	}
	return nil
}

func (cr *cartRepository) GetlistCart (ctx context.Context, userId string) ([]*entity.UserCart, error){
	 rows, err := cr.db.QueryContext(
		ctx,
		"SELECT uc.id, uc.product_id, uc.user_id, uc.quantity , uc.created_at, uc.created_by, uc.updated_at, uc.updated_by, p.id, p.name, p.image_file_name, p.price FROM user_cart uc JOIN product p ON uc.product_id = p.id WHERE uc.user_id = $1 AND p.is_deleted = false",
		userId,
	)
	if err != nil {
		return nil, err
	}

	var carts []*entity.UserCart = make([]*entity.UserCart, 0)
	for rows.Next(){
		var cart entity.UserCart
		cart.Product = &entity.Product{}

		err = rows.Scan(
			&cart.Id,
			&cart.ProductId,
			&cart.UserId,
			&cart.Quantity,
			&cart.CreatedAt,
			&cart.CreatedBy,
			&cart.UpdatedAt,
			&cart.UpdatedBy,
			&cart.Product.Id,
			&cart.Product.Name,
			&cart.Product.ImageFileName,
			&cart.Product.Price,
		)
		if err != nil {
			return nil, err
		}

		carts = append(carts, &cart)
	}

	return  carts, nil
}

func (cr *cartRepository) GetCartById (ctx context.Context, cartId string) (*entity.UserCart, error){
	row := cr.db.QueryRowContext(
		ctx,
		"SELECT id, product_id, user_id, quantity, created_at, created_by, updated_at, updated_by FROM user_cart WHERE id = $1",
		cartId, 
	)
	if row.Err() != nil {
		return  nil, row.Err()
	}

	var cart entity.UserCart
	err := row.Scan(
		&cart.Id,
		&cart.ProductId,
		&cart.UserId,
		&cart.Quantity,
		&cart.CreatedAt,
		&cart.CreatedBy,
		&cart.UpdatedAt,
		&cart.UpdatedBy,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows){
			return  nil, nil
		}
		return nil, err
	}

	return  &cart, nil
}
func (cr *cartRepository) DeleteCart (ctx context.Context, cartId string) error{
	_, err := cr.db.ExecContext(
		ctx,
		"DELETE FROM user_cart WHERE id = $1",
		cartId, 
	)
	if err != nil {
		return  err
	}

	return  nil
}


func NewCartRepository(db *sql.DB) ICartRepository  {
	return  &cartRepository{
		db: db,
	}
}



====================
FILE: D:\go-grpc-ecommerce-be\internal\repository\order_repository.go
====================
package repository

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	"github.com/luzmareto/go-grpc-ecommerce-be/pkg/database"
)

type IOrderRepository interface {
	WithTrancastion(tx *sql.Tx) IOrderRepository
	GetNumbering(ctx context.Context, module string) (*entity.Numbering, error)
	CreateOrder(ctx context.Context, order *entity.Order) error
	UpdateNumbering(ctx context.Context, numbering *entity.Numbering) error
	CreateOrderItem(ctx context.Context, orderItem *entity.OrderItem) error
	GetOrderById(ctx context.Context, orderId string) (*entity.Order, error)
	UpdateOrder(ctx context.Context, order *entity.Order) error
	GetListOrderAdminPagination(ctx context.Context, pagination *common.PaginationRequest) ([]*entity.Order, *common.PaginationResponse, error)
	GetListOrderPagination(ctx context.Context, pagination *common.PaginationRequest, userId string) ([]*entity.Order, *common.PaginationResponse, error)
}

type orderRepository struct {
	db database.DatabaseQuery
}

func (os *orderRepository) WithTrancastion(tx *sql.Tx) IOrderRepository {
	return &orderRepository{
		db: tx,
	}
}

func (os *orderRepository) GetNumbering(ctx context.Context, module string) (*entity.Numbering, error) {
	row := os.db.QueryRowContext(
		ctx,
		"SELECT module, number FROM numbering WHERE module = $1 FOR UPDATE",
		module,
	)
	if row.Err() != nil {
		return nil, row.Err()
	}

	var numbering entity.Numbering
	err := row.Scan(
		&numbering.Module,
		&numbering.Number,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}

		return nil, err
	}
	return &numbering, nil
}

func (or *orderRepository) CreateOrder(ctx context.Context, order *entity.Order) error {
	_, err := or.db.ExecContext(
		ctx,
		"INSERT INTO \"order\" (id, number, user_id, order_status_code, user_full_name, address, phone_number, notes, total, expired_at, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by, is_deleted, xendit_invoice_id, xendit_invoice_url) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)",
		order.Id,
		order.Number,
		order.UserId,
		order.OrderStatusCode,
		order.UserFullName,
		order.Address,
		order.PhoneNumber,
		order.Notes,
		order.Total,
		order.ExpiredAt,
		order.CreatedAt,
		order.CreatedBy,
		order.UpdatedAt,
		order.UpdatedBy,
		order.DeletedAt,
		order.DeletedBy,
		order.IsDeleted,
		order.XenditInvoiceId,
		order.XenditInvoiceUrl,
	)
	if err != nil {
		return err
	}

	return nil
}

func (or *orderRepository) UpdateNumbering(ctx context.Context, numbering *entity.Numbering) error {
	_, err := or.db.ExecContext(
		ctx,
		"UPDATE numbering SET number = $1 WHERE module = $2	",
		numbering.Number,
		numbering.Module,
	)
	if err != nil {
		return err
	}

	return nil
}

func (or *orderRepository) CreateOrderItem(ctx context.Context, orderItem *entity.OrderItem) error {
	_, err := or.db.ExecContext(
		ctx,
		"INSERT INTO order_item (id, product_id, product_name, product_image_file_name, product_price, quantity, order_id, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by, is_deleted) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)",
		orderItem.Id,
		orderItem.ProductId,
		orderItem.ProductName,
		orderItem.ProductImageFileName,
		orderItem.ProductPrice,
		orderItem.Quantity,
		orderItem.OrderId,
		orderItem.CreatedAt,
		orderItem.CreatedBy,
		orderItem.UpdatedAt,
		orderItem.UpdatedBy,
		orderItem.DeletedAt,
		orderItem.DeletedBy,
		orderItem.IsDeleted,
	)

	if err != nil {
		return err
	}
	return nil
}

func (or *orderRepository) GetOrderById(ctx context.Context, orderId string) (*entity.Order, error) {
	row := or.db.QueryRowContext(
		ctx,
		"SELECT id, number, user_full_name, address, phone_number, notes, order_status_code, total, created_at, xendit_invoice_url, user_id, expired_at, xendit_paid_at, xendit_payment_channel, xendit_payment_method FROM \"order\" WHERE id = $1 AND is_deleted = false",
		orderId,
	)
	if row.Err() != nil {
		return nil, row.Err()
	}

	var order entity.Order
	err := row.Scan(
		&order.Id,
		&order.Number,
		&order.UserFullName,
		&order.Address,
		&order.PhoneNumber,
		&order.Notes,
		&order.OrderStatusCode,
		&order.Total,
		&order.CreatedAt,
		&order.XenditInvoiceUrl,
		&order.UserId,
		&order.ExpiredAt,
		&order.XenditPaidAt,
		&order.XenditPaymentChannel,
		&order.XenditPaymentMethod,
	)
	if err != nil { //logic jika order tidak ditemukan
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}

		return nil, err
	}

	rows, err := or.db.QueryContext(
		ctx,
		"SELECT product_id, product_name, product_price, quantity FROM order_item WHERE order_id =$1 AND is_deleted = false",
		order.Id,
	)
	if err != nil {
		return nil, err
	}

	items := make([]*entity.OrderItem, 0)
	for rows.Next() {
		var item entity.OrderItem

		err = rows.Scan(
			&item.ProductId,
			&item.ProductName,
			&item.ProductPrice,
			&item.Quantity,
		)
		if err != nil {
			return nil, err
		}

		items = append(items, &item)
	}

	order.Items = items

	return &order, nil
}

func (or *orderRepository) UpdateOrder(ctx context.Context, order *entity.Order) error {
	_, err := or.db.ExecContext(
		ctx,
		"UPDATE \"order\" SET updated_at = $1, updated_by = $2, xendit_paid_at = $3, xendit_payment_channel = $4, xendit_payment_method = $5, order_status_code = $6 WHERE id = $7",
		order.UpdatedAt,
		order.UpdatedBy,
		order.XenditPaidAt,
		order.XenditPaymentChannel,
		order.XenditPaymentMethod,
		order.OrderStatusCode,
		order.Id,
	)
	if err != nil {
		return err
	}

	return nil

}

func (or *orderRepository) GetListOrderAdminPagination(ctx context.Context, pagination *common.PaginationRequest) ([]*entity.Order, *common.PaginationResponse, error) {
	row := or.db.QueryRowContext(
		ctx,
		"SELECT COUNT(*) FROM \"order\" WHERE is_deleted = false",
	)
	if row.Err() != nil {
		return nil, nil, row.Err()
	}

	var totalCount int
	err := row.Scan(&totalCount)
	if err != nil {
		return nil, nil, err
	}

	offset := (pagination.CurrentPage - 1) * pagination.ItemPerPage
	totalPages := (totalCount + int(pagination.ItemPerPage) - 1) / int(pagination.ItemPerPage)

	allowedSorts := map[string]string{
		"number":     "number",
		"customer":   "user_full_name",
		"total":      "total",
		"created_at": "created_at",
	}
	sort := "ORDER BY created_at DESC"
	if pagination.Sort != nil {
		direction := "ASC"
		sortField, ok := allowedSorts[pagination.Sort.Field]
		if ok {
			if pagination.Sort.Direction == "desc" {
				direction = "DESC"
			}
			sort = fmt.Sprintf("ORDER BY %s %s", sortField, direction)
		}
	}

	baseQuery := fmt.Sprintf("SELECT id, number, order_status_code, total, user_full_name, created_at, expired_at FROM \"order\" WHERE is_deleted = false %s LIMIT $1 OFFSET $2", sort)
	rows, err := or.db.QueryContext(
		ctx,
		baseQuery,
		pagination.ItemPerPage,
		offset,
	)
	if err != nil {
		return nil, nil, err
	}

	orders := make([]*entity.Order, 0)
	ids := make([]string, 0)
	orderItemsMap := make(map[string][]*entity.OrderItem)
	for rows.Next() {
		var orderEntity entity.Order
		err = rows.Scan(
			&orderEntity.Id,
			&orderEntity.Number,
			&orderEntity.OrderStatusCode,
			&orderEntity.Total,
			&orderEntity.UserFullName,
			&orderEntity.CreatedAt,
			&orderEntity.ExpiredAt,
		)
		if err != nil {
			return nil, nil, err
		}

		orders = append(orders, &orderEntity)
		ids = append(ids, fmt.Sprintf("'%s'", orderEntity.Id))
		orderItemsMap[orderEntity.Id] = make([]*entity.OrderItem, 0)
	}

	if len(orders) > 0 {
		idsJoin := strings.Join(ids, ", ")
		baseOrderItemQuery := fmt.Sprintf("SELECT product_id, product_name, product_price, quantity, order_id FROM order_item WHERE is_deleted = false AND order_id IN (%s)", idsJoin)
		rows, err = or.db.QueryContext(
			ctx,
			baseOrderItemQuery,
		)
		if err != nil {
			return nil, nil, err
		}

		for rows.Next() {
			var item entity.OrderItem
			rows.Scan(
				&item.ProductId,
				&item.ProductName,
				&item.ProductPrice,
				&item.Quantity,
				&item.OrderId,
			)
			if err != nil {
				return nil, nil, err
			}

			orderItemsMap[item.OrderId] = append(orderItemsMap[item.OrderId], &item)
		}

		for i, o := range orders {
			orders[i].Items = orderItemsMap[o.Id]
		}
	}

	var metadata common.PaginationResponse = common.PaginationResponse{
		CurrentPage:    pagination.CurrentPage,
		TotalPageCount: int32(totalPages),
		ItemPerPage:    pagination.ItemPerPage,
		TotalItemCount: int32(totalCount),
	}
	return orders, &metadata, nil
}

func (or *orderRepository) GetListOrderPagination(ctx context.Context, pagination *common.PaginationRequest, userId string) ([]*entity.Order, *common.PaginationResponse, error) {
	row := or.db.QueryRowContext(
		ctx,
		"SELECT COUNT(*) FROM \"order\" WHERE is_deleted = false AND user_id = $1",
		userId,
	)
	if row.Err() != nil {
		return nil, nil, row.Err()
	}

	var totalCount int
	err := row.Scan(&totalCount)
	if err != nil {
		return nil, nil, err
	}

	offset := (pagination.CurrentPage - 1) * pagination.ItemPerPage
	totalPages := (totalCount + int(pagination.ItemPerPage) - 1) / int(pagination.ItemPerPage)

	allowedSorts := map[string]string{
		"number":     "number",
		"customer":   "user_full_name",
		"total":      "total",
		"created_at": "created_at",
	}
	sort := "ORDER BY created_at DESC"
	if pagination.Sort != nil {
		direction := "ASC"
		sortField, ok := allowedSorts[pagination.Sort.Field]
		if ok {
			if pagination.Sort.Direction == "desc" {
				direction = "DESC"
			}
			sort = fmt.Sprintf("ORDER BY %s %s", sortField, direction)
		}
	}

	baseQuery := fmt.Sprintf("SELECT id, number, order_status_code, total, user_full_name, created_at, expired_at, xendit_invoice_url FROM \"order\" WHERE is_deleted = false AND user_id = $1 %s LIMIT $2 OFFSET $3", sort)
	rows, err := or.db.QueryContext(
		ctx,
		baseQuery,
		userId,
		pagination.ItemPerPage,
		offset,
	)
	if err != nil {
		return nil, nil, err
	}

	orders := make([]*entity.Order, 0)
	ids := make([]string, 0)
	orderItemsMap := make(map[string][]*entity.OrderItem)
	for rows.Next() {
		var orderEntity entity.Order
		err = rows.Scan(
			&orderEntity.Id,
			&orderEntity.Number,
			&orderEntity.OrderStatusCode,
			&orderEntity.Total,
			&orderEntity.UserFullName,
			&orderEntity.CreatedAt,
			&orderEntity.ExpiredAt,
			&orderEntity.XenditInvoiceUrl,
		)
		if err != nil {
			return nil, nil, err
		}

		orders = append(orders, &orderEntity)
		ids = append(ids, fmt.Sprintf("'%s'", orderEntity.Id))
		orderItemsMap[orderEntity.Id] = make([]*entity.OrderItem, 0)
	}

	if len(orders) > 0 {
		idsJoin := strings.Join(ids, ", ")
		baseOrderItemQuery := fmt.Sprintf("SELECT product_id, product_name, product_price, quantity, order_id FROM order_item WHERE is_deleted = false AND order_id IN (%s)", idsJoin)
		rows, err = or.db.QueryContext(
			ctx,
			baseOrderItemQuery,
		)
		if err != nil {
			return nil, nil, err
		}

		for rows.Next() {
			var item entity.OrderItem
			rows.Scan(
				&item.ProductId,
				&item.ProductName,
				&item.ProductPrice,
				&item.Quantity,
				&item.OrderId,
			)
			if err != nil {
				return nil, nil, err
			}

			orderItemsMap[item.OrderId] = append(orderItemsMap[item.OrderId], &item)
		}

		for i, o := range orders {
			orders[i].Items = orderItemsMap[o.Id]
		}
	}

	var metadata common.PaginationResponse = common.PaginationResponse{
		CurrentPage:    pagination.CurrentPage,
		TotalPageCount: int32(totalPages),
		ItemPerPage:    pagination.ItemPerPage,
		TotalItemCount: int32(totalCount),
	}
	return orders, &metadata, nil
}

func NewOrderRepository(db database.DatabaseQuery) IOrderRepository {
	return &orderRepository{
		db: db,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\repository\product_repository.go
====================
package repository

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	"github.com/luzmareto/go-grpc-ecommerce-be/pkg/database"
)

type IProductRepository interface {
	WithTrancastion(tx *sql.Tx) IProductRepository
	CreateNewProduct(ctx context.Context, product *entity.Product) error
	GetProductById(ctx context.Context, id string) (*entity.Product, error)
	GetProductsByIds(ctx context.Context, ids []string) ([]*entity.Product, error)
	UpdateProduct(ctx context.Context, product *entity.Product) error
	DeleteProduct(ctx context.Context, id string, deletedAt time.Time, deletedBy string) error
	GetProductsPagination(ctx context.Context, pagination *common.PaginationRequest) ([]*entity.Product, *common.PaginationResponse, error)
	GetProductsPaginationAdmin(ctx context.Context, pagination *common.PaginationRequest) ([]*entity.Product, *common.PaginationResponse, error)
	GetProductHighlight(ctx context.Context) ([]*entity.Product, error)
}

type productRepository struct {
	db database.DatabaseQuery
}

func (repo *productRepository) WithTrancastion(tx *sql.Tx) IProductRepository {
	return &productRepository{
		db: tx,
	}
}
func (repo *productRepository) CreateNewProduct(ctx context.Context, product *entity.Product) error {
	_, err := repo.db.ExecContext(
		ctx,
		"INSERT INTO product (id, name, description, price, image_file_name, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by, is_deleted) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)",
		product.Id,
		product.Name,
		product.Description,
		product.Price,
		product.ImageFileName,
		product.CreatedAt,
		product.CreatedBy,
		product.UpdatedAt,
		product.UpdatedBy,
		product.DeletedAt,
		product.DeletedBy,
		product.IsDeleted,
	)

	if err != nil {
		return err
	}
	return nil
}

func UUIDOrNil(s string) any {
	if _, err := uuid.Parse(s); err != nil {
		return nil
	}
	return s
}

func (repo *productRepository) GetProductById(ctx context.Context, id string) (*entity.Product, error) {
	idParam := UUIDOrNil(id)
	var productEntity entity.Product
	row := repo.db.QueryRowContext(
		ctx,
		"SELECT id, name, description, price, image_file_name FROM product WHERE id = $1 AND is_deleted = false",
		idParam,
	)
	if row.Err() != nil {
		return nil, row.Err()
	}

	err := row.Scan(
		&productEntity.Id,
		&productEntity.Name,
		&productEntity.Description,
		&productEntity.Price,
		&productEntity.ImageFileName,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
	}

	return &productEntity, nil
}

func (repo *productRepository) GetProductsByIds(ctx context.Context, ids []string) ([]*entity.Product, error) {
	queryIds := make([]string, len(ids))
	for i, id := range ids {
		queryIds[i] = fmt.Sprintf("'%s'", id)
	}
	rows, err := repo.db.QueryContext(
		ctx,
		fmt.Sprintf("SELECT id, name, price, image_file_name FROM product WHERE id IN (%s) AND is_deleted =false", strings.Join(queryIds, ", ")),
	)
	if err != nil {
		return nil, err
	}

	var products []*entity.Product = make([]*entity.Product, 0)
	for rows.Next() {
		var productEntity entity.Product
		err = rows.Scan(
			&productEntity.Id,
			&productEntity.Name,
			&productEntity.Price,
			&productEntity.ImageFileName,
		)
		if err != nil {
			return nil, err
		}

		products = append(products, &productEntity)
	}

	return products, nil
}

func (repo *productRepository) UpdateProduct(ctx context.Context, product *entity.Product) error {
	_, err := repo.db.ExecContext(
		ctx,
		"UPDATE product SET name=$1, description=$2, price=$3, image_file_name=$4, updated_at=$5, updated_by=$6 WHERE id =$7",
		product.Name,
		product.Description,
		product.Price,
		product.ImageFileName,
		product.UpdatedAt,
		product.UpdatedBy,
		product.Id,
	)

	if err != nil {
		return err
	}
	return nil
}

func (repo *productRepository) DeleteProduct(ctx context.Context, id string, deletedAt time.Time, deletedBy string) error {
	_, err := repo.db.ExecContext(
		ctx,
		"UPDATE product SET deleted_at = $1, deleted_by = $2, is_deleted = true WHERE id = $3",
		deletedAt,
		deletedBy,
		id,
	)

	if err != nil {
		return err
	}
	return nil
}

func (repo *productRepository) GetProductsPagination(ctx context.Context, pagination *common.PaginationRequest) ([]*entity.Product, *common.PaginationResponse, error) {
	row := repo.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM product WHERE is_deleted = false")
	if row.Err() != nil {
		return nil, nil, row.Err()
	}

	var totalCount int
	err := row.Scan(&totalCount)
	if err != nil {
		return nil, nil, err
	}

	offset := (pagination.CurrentPage - 1) * pagination.ItemPerPage
	totalPages := (totalCount + int(pagination.ItemPerPage) - 1) / int(pagination.ItemPerPage)

	rows, err := repo.db.QueryContext(
		ctx,
		"SELECT id, name, description, price, image_file_name FROM product WHERE is_deleted = false ORDER BY created_at DESC LIMIT $1 OFFSET $2",
		pagination.ItemPerPage,
		offset,
	)

	if err != nil {
		return nil, nil, err
	}

	var products []*entity.Product = make([]*entity.Product, 0)
	for rows.Next() {
		var product entity.Product

		err = rows.Scan(
			&product.Id,
			&product.Name,
			&product.Description,
			&product.Price,
			&product.ImageFileName,
		)
		if err != nil {
			return nil, nil, err
		}

		products = append(products, &product)
	}

	paginationResponse := &common.PaginationResponse{
		CurrentPage:    pagination.CurrentPage,
		ItemPerPage:    pagination.ItemPerPage,
		TotalItemCount: int32(totalCount),
		TotalPageCount: int32(totalPages),
	}
	return products, paginationResponse, nil
}

func (repo *productRepository) GetProductsPaginationAdmin(ctx context.Context, pagination *common.PaginationRequest) ([]*entity.Product, *common.PaginationResponse, error) {
	row := repo.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM product WHERE is_deleted = false")
	if row.Err() != nil {
		return nil, nil, row.Err()
	}

	var totalCount int
	err := row.Scan(&totalCount)
	if err != nil {
		return nil, nil, err
	}

	offset := (pagination.CurrentPage - 1) * pagination.ItemPerPage
	totalPages := (totalCount + int(pagination.ItemPerPage) - 1) / int(pagination.ItemPerPage)

	allowedSorts := map[string]bool{
		"name":        true,
		"description": true,
		"price":       true,
	}

	orderQuery := "ORDER BY created_at DESC"
	if pagination.Sort != nil && allowedSorts[pagination.Sort.Field] {
		direction := "asc"
		if pagination.Sort.Direction == "desc" {
			direction = "desc"
		}
		orderQuery = fmt.Sprintf("ORDER BY %s %s", pagination.Sort.Field, direction)
	}

	baseQuery := fmt.Sprintf("SELECT id, name, description, price, image_file_name FROM product WHERE is_deleted = false %s LIMIT $1 OFFSET $2", orderQuery)
	rows, err := repo.db.QueryContext(
		ctx,
		baseQuery,
		pagination.ItemPerPage,
		offset,
	)

	if err != nil {
		return nil, nil, err
	}

	var products []*entity.Product = make([]*entity.Product, 0)
	for rows.Next() {
		var product entity.Product

		err = rows.Scan(
			&product.Id,
			&product.Name,
			&product.Description,
			&product.Price,
			&product.ImageFileName,
		)
		if err != nil {
			return nil, nil, err
		}

		products = append(products, &product)
	}

	paginationResponse := &common.PaginationResponse{
		CurrentPage:    pagination.CurrentPage,
		ItemPerPage:    pagination.ItemPerPage,
		TotalItemCount: int32(totalCount),
		TotalPageCount: int32(totalPages),
	}
	return products, paginationResponse, nil
}

func (repo *productRepository) GetProductHighlight(ctx context.Context) ([]*entity.Product, error) {
	//highligh 3 data penjualan teratas pada beranda
	rows, err := repo.db.QueryContext(
		ctx,
		`SELECT
    id,
    name,
    description,
    price,
    image_file_name
FROM
    product
WHERE
    id IN (
        SELECT p.id
        FROM product p
        JOIN order_item oi ON oi.product_id = p.id
        WHERE
            p.is_deleted = false AND oi.is_deleted = false
        GROUP BY p.id ORDER BY COUNT(*) DESC
        LIMIT 3
    );
		`,
	)
	if err != nil {
		return nil, err
	}

	var products []*entity.Product = make([]*entity.Product, 0)
	for rows.Next() {
		var productEntity entity.Product

		err = rows.Scan(
			&productEntity.Id,
			&productEntity.Name,
			&productEntity.Description,
			&productEntity.Price,
			&productEntity.ImageFileName,
		)
		if err != nil {
			return nil, err
		}
		products = append(products, &productEntity)
	}

	return products, nil
}
func NewProductRepository(db database.DatabaseQuery) IProductRepository {
	return &productRepository{
		db: db,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\service\auth_service.go
====================
package service

import (
	"context"
	"errors"
	"log"
	"os"
	"time"

	jwtentity "github.com/luzmareto/go-grpc-ecommerce-be/internal/entity/jwt"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/repository"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/auth"
	gocache "github.com/patrickmn/go-cache"
	"golang.org/x/crypto/bcrypt"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type IAuthService interface {
	Register(ctx context.Context, request *auth.RegisterRequest) (*auth.RegisterResponse, error)
	Login(ctx context.Context, request *auth.LoginRequest) (*auth.LoginResponse, error)
	Logout(ctx context.Context, request *auth.LogoutRequest) (*auth.LogoutResponse, error)
	ChangePassword(ctx context.Context, request *auth.ChangePasswordRequest) (*auth.ChangePasswordResponse, error)
	GetProfile(ctx context.Context, request *auth.GetProfileRequest) (*auth.GetProfileResponse, error)
}

type authService struct {
	authRepository repository.IAuthRepository
	cacheService   *gocache.Cache
}

func (as *authService) Register(ctx context.Context, request *auth.RegisterRequest) (*auth.RegisterResponse, error) {
	// pengecekan email ke database
	if request.Password != request.PasswordConfirmation {
		return &auth.RegisterResponse{
			Base: utils.BadRequestResponse("Password is not match"),
		}, nil
	}
	user, err := as.authRepository.GetUserByEmail(ctx, request.Email)
	if err != nil {
		return nil, err
	}

	//apabila email sudah terdaftar, maka error
	if user != nil {
		return &auth.RegisterResponse{
			Base: utils.BadRequestResponse("User already exist"),
		}, nil
	}

	// hash passwrd
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(request.Password), 10)
	if err != nil {
		return nil, err
	}
	// insert ke db
	newUser := entity.User{
		Id:        uuid.NewString(),
		FullName:  request.FullName,
		Email:     request.Email,
		Password:  string(hashedPassword),
		RoleCode:  entity.UserRoleCustomer,
		CreatedAt: time.Now(),
		CreatedBy: request.FullName,
	}
	err = as.authRepository.InsertUser(ctx, &newUser)
	if err != nil {
		return nil, err
	}

	return &auth.RegisterResponse{
		Base: utils.SuccessResponse("user successfuly register"),
	}, nil
}

func (as *authService) Login(ctx context.Context, request *auth.LoginRequest) (*auth.LoginResponse, error) {
	// check apakah email sudah terdaftar
	user, err := as.authRepository.GetUserByEmail(ctx, request.Email)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return &auth.LoginResponse{
			Base: utils.BadRequestResponse("user is not register"),
		}, nil
	}

	// check apakah password sudah macth
	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(request.Password))
	if err != nil {
		if errors.Is(err, bcrypt.ErrMismatchedHashAndPassword) {
			log.Println("Password mismatch error:", err) // Tambahkan log ini
			return nil, status.Errorf(codes.Unauthenticated, "Unauthenticated")
		}
		log.Println("Unexpected bcrypt error:", err)

		return nil, err
	}

	// generate jwt
	now := time.Now()
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwtentity.JwtClaims{
		RegisteredClaims: jwt.RegisteredClaims{
			Subject:   user.Id,
			ExpiresAt: jwt.NewNumericDate(now.Add(time.Hour * 24)),
			IssuedAt:  jwt.NewNumericDate(now),
		},
		Email:    user.Email,
		FullName: user.FullName,
		Role:     user.RoleCode,
	})
	secretKey := os.Getenv("JWT_SECRET")
	accessToken, err := token.SignedString([]byte(secretKey))
	if err != nil {
		return nil, err
	}

	// kirim response
	return &auth.LoginResponse{
		Base:       utils.SuccessResponse("Login successful"),
		AccessToken: accessToken,
	}, nil
}

// Logout implements IAuthService.
func (as *authService) Logout(ctx context.Context, request *auth.LogoutRequest) (*auth.LogoutResponse, error) {

	jwtToken, err := jwtentity.ParseTokenFromContext(ctx)
	if err != nil {
		return nil, err
	}

	tokenClaims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}

	as.cacheService.Set(jwtToken, "", time.Duration(tokenClaims.ExpiresAt.Time.Unix()-time.Now().Unix())*time.Second)

	return &auth.LogoutResponse{
		Base: utils.SuccessResponse("Logout Success"),
	}, nil
}

func (as *authService) ChangePassword(ctx context.Context, request *auth.ChangePasswordRequest) (*auth.ChangePasswordResponse, error) {
	// cek new pass confimation
	if request.NewPassword != request.NewPasswordConfirmation {
		return &auth.ChangePasswordResponse{
			Base: utils.BadRequestResponse("New Password is not match"),
		}, nil
	}

	// cek old password
	jwtToken, err := jwtentity.ParseTokenFromContext(ctx)
	if err != nil {
		return nil, err
	}
	jwtentity.GetClaimsFromToken(jwtToken)
	claims, err := jwtentity.GetClaimsFromToken(jwtToken)
	if err != nil {
		return nil, err
	}

	user, err := as.authRepository.GetUserByEmail(ctx, claims.Email)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return &auth.ChangePasswordResponse{
			Base: utils.BadRequestResponse("User does not exist"),
		}, nil
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(request.OldPassword))
	if err != nil {
		if errors.Is(err, bcrypt.ErrMismatchedHashAndPassword) {
			return &auth.ChangePasswordResponse{
				Base: utils.BadRequestResponse("Old password is not match"),
			}, nil
		}

		return nil, err
	}

	// update new password ke db
	hashedNewPasswrod, err := bcrypt.GenerateFromPassword([]byte(request.NewPassword), 10)
	if err != nil {
		return nil, err
	}
	err = as.authRepository.UpdateUserPassword(ctx, user.Id, string(hashedNewPasswrod), user.FullName)
	if err != nil {
		return nil, err
	}

	// kirim response
	return &auth.ChangePasswordResponse{
		Base: utils.SuccessResponse("Change Password Succes"),
	}, nil
}

func (as *authService) GetProfile(ctx context.Context, request *auth.GetProfileRequest) (*auth.GetProfileResponse, error) {
	// get data token
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}
	// Ambil data dari database
	user, err := as.authRepository.GetUserByEmail(ctx, claims.Email)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return &auth.GetProfileResponse{
			Base: utils.BadRequestResponse("user doesn't exist"),
		}, nil
	}

	// Buat response

	// kirim response
	return &auth.GetProfileResponse{
		Base:        utils.SuccessResponse("Get Profile Succes"),
		UserId:      claims.Subject,
		FullName:    claims.FullName,
		Email:       claims.Email,
		RoleCode:    claims.Role,
		MemberSince: timestamppb.New(user.CreatedAt),
	}, nil
}

func NewAuthService(authRepository repository.IAuthRepository, cacheService *gocache.Cache) IAuthService {
	return &authService{
		authRepository: authRepository,
		cacheService:   cacheService,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\service\cart_service.go
====================
package service

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
	jwtentity "github.com/luzmareto/go-grpc-ecommerce-be/internal/entity/jwt"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/repository"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/cart"
)

type ICartService interface {
	AddProductToCart(ctx context.Context, request *cart.AddProductToCartRequest) (*cart.AddProductToCartResponse, error)
	ListCart(ctx context.Context,request *cart.ListCartRequest) (*cart.ListCartResponse, error)
	DeleteCart(ctx context.Context,request *cart.DeleteCartRequest) (*cart.DeleteCartResponse, error)
	UpdateCartQuantity(ctx context.Context, request *cart.UpdateCartQuantityRequest) (*cart.UpdateCartQuantityResponse, error)
}

type cartService struct {
	productRepository repository.IProductRepository
	cartRepository repository.ICartRepository
}

func (cs *cartService) AddProductToCart(ctx context.Context, request *cart.AddProductToCartRequest) (*cart.AddProductToCartResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}

	
	productEntity, err := cs.productRepository.GetProductById(ctx,request.ProductId)
	if err != nil {
		return nil, err
	}

	if productEntity == nil {
		return &cart.AddProductToCartResponse{
			Base: utils.NotFoundResponse("Product not found"),
		}, nil
	}

	cartEntity, err := cs.cartRepository.GetCartByProductAndUserId(ctx, request.ProductId, claims.Subject)
	if err != nil {
		return nil, err
	}

	if cartEntity != nil {
		now := time.Now()
		cartEntity.Quantity += 1
		cartEntity.UpdatedAt = &now
		cartEntity.UpdatedBy = &claims.Subject

		err = cs.cartRepository.UpdateCart(ctx, cartEntity)
		if err != nil {
			return nil, err
		}

		return &cart.AddProductToCartResponse{
		Base: utils.SuccessResponse(" Add product to cart success"),
		Id: cartEntity.Id,
	},nil 
	}

	newCartEntity := entity.UserCart{
		Id: uuid.NewString(),
		UserId: claims.Subject,
		ProductId: request.ProductId,
		Quantity: 1,
		CreatedAt: time.Now(),
		CreatedBy: claims.FullName,
	}
	err = cs.cartRepository.CreateNewCart(ctx, &newCartEntity)
	if err != nil {
		return nil, err
	}

	return &cart.AddProductToCartResponse{
		Base: utils.SuccessResponse(" Add product to cart success"),
		Id: newCartEntity.Id,
	},nil
}

func (cs *cartService) ListCart(ctx context.Context,request *cart.ListCartRequest) (*cart.ListCartResponse, error){
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}

	carts, err :=  cs.cartRepository.GetlistCart(ctx, claims.Subject)
	if err != nil {
		return nil, err
	}

	var items []*cart.ListCartResponseItem = make([]*cart.ListCartResponseItem, 0)
	for _, cartEntity := range carts {
		item := cart.ListCartResponseItem{
			CartId: cartEntity.Id,
			ProductId: cartEntity.Product.Id,
			ProductName: cartEntity.Product.Name,
			ProductImageUrl: fmt.Sprintf("%s/product/%s", os.Getenv("STORAGE_SERVICE_URL"), cartEntity.Product.ImageFileName),
			ProductPrice: cartEntity.Product.Price,
			Quantity: int64(cartEntity.Quantity),
		}
	
	items = append(items, &item)
	}

	return &cart.ListCartResponse{
		Base: utils.SuccessResponse("Get list cart success"),
		Items: items,
	},nil
	
}

func (cs *cartService) DeleteCart(ctx context.Context,request *cart.DeleteCartRequest) (*cart.DeleteCartResponse, error){
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}

	cartEtnity, err := cs.cartRepository.GetCartById(ctx, request.CartId)
	if err != nil {
		return nil, err
	}
	if cartEtnity == nil {
		return  &cart.DeleteCartResponse{
			Base: utils.NotFoundResponse("Cart not found"),
		}, nil
	}
	
	if cartEtnity.UserId != claims.Subject{
		return &cart.DeleteCartResponse{
			Base: utils.BadRequestResponse("Cart user is not matched"),
		}, nil
	}

	err  = cs.cartRepository.DeleteCart(ctx, request.CartId)
	if err != nil {
		return nil, err
	}
	return  &cart.DeleteCartResponse{
		Base: utils.SuccessResponse("Delete cart success"),
	}, nil
}

func (cs *cartService) UpdateCartQuantity(ctx context.Context, request *cart.UpdateCartQuantityRequest) (*cart.UpdateCartQuantityResponse, error){
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}

	
	cartEntity, err := cs.cartRepository.GetCartById(ctx, request.CartId)
	if err != nil {
		return nil, err
	}
	if cartEntity == nil {
		return  &cart.UpdateCartQuantityResponse{
			Base: utils.NotFoundResponse("Cart not found"),
		}, nil
	}

	if cartEntity.UserId != claims.Subject {
		return  &cart.UpdateCartQuantityResponse{
			Base: utils.BadRequestResponse("Cart user is not matched"),
		}, nil		
	}

	if request.NewQuantity == 0 {
		err =cs.cartRepository.DeleteCart(ctx, request.CartId)
		if err != nil {
			return nil, err
		}

		return &cart.UpdateCartQuantityResponse{
			Base: utils.SuccessResponse("Update cart quantity success"),
		}, nil
	}
	now := time.Now()
	cartEntity.Quantity = int(request.NewQuantity)
	cartEntity.UpdatedAt = &now
	cartEntity.UpdatedBy = &claims.FullName

	err = cs.cartRepository.UpdateCart(ctx, cartEntity)
	if err != nil {
		return nil, err
	}

	return &cart.UpdateCartQuantityResponse{
		Base: utils.SuccessResponse("Update cart quantity success"),
	}, nil

}

func NewCartService(productRepository repository.IProductRepository, cartRepository repository.ICartRepository) ICartService {
	return  &cartService{
		productRepository: productRepository,
		cartRepository: cartRepository,
	}
}



====================
FILE: D:\go-grpc-ecommerce-be\internal\service\order_service.go
====================
package service

import (
	"context"
	"database/sql"
	"fmt"
	operatingsystem "os"
	"runtime/debug"
	"time"

	"github.com/google/uuid"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
	jwtentity "github.com/luzmareto/go-grpc-ecommerce-be/internal/entity/jwt"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/repository"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/order"
	"github.com/xendit/xendit-go"
	"github.com/xendit/xendit-go/invoice"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type IOrderService interface {
	CreateOrder(ctx context.Context, request *order.CreateOrderRequest) (*order.CreateOrderResponse, error)
	ListOrderAdmin(ctx context.Context, request *order.ListOrderAdminRequest) (*order.ListOrderAdminResponse, error)
	ListOrder(ctx context.Context, request *order.ListOrderRequest) (*order.ListOrderResponse, error)
	DetailOrder(ctx context.Context, request *order.DetailOrderRequest) (*order.DetailOrderResponse, error)
	UpdateOrderStatus(ctx context.Context, request *order.UpdateOrderStatusRequest) (*order.UpdateOrderStatusResponse, error)
}

type orderService struct {
	db               *sql.DB
	orderRepository  repository.IOrderRepository
	productRepostory repository.IProductRepository
}

func (os *orderService) CreateOrder(ctx context.Context, request *order.CreateOrderRequest) (*order.CreateOrderResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}

	tx, err := os.db.Begin()
	if err != nil {
		return nil, err
	}
	defer func() {
		if e := recover(); e != nil {
			if tx != nil {
				tx.Rollback()
			}

			debug.PrintStack()
			panic(e)
		}
	}()
	defer func() {
		if err != nil && tx != nil {
			tx.Rollback()
		}
	}()

	orderRepo := os.orderRepository.WithTrancastion(tx)
	productRepo := os.productRepostory.WithTrancastion(tx)

	numbering, err := orderRepo.GetNumbering(ctx, "order")
	if err != nil {
		return nil, err
	}

	var productIds = make([]string, len(request.Products))
	for i := range request.Products {
		productIds[i] = request.Products[i].Id
	}

	products, err := productRepo.GetProductsByIds(ctx, productIds)
	if err != nil {
		return nil, err
	}

	productMap := make(map[string]*entity.Product)
	for i := range products {
		productMap[products[i].Id] = products[i]
	}

	var total float64 = 0
	for _, p := range request.Products {
		if productMap[p.Id] == nil {
			return &order.CreateOrderResponse{
				Base: utils.NotFoundResponse(fmt.Sprintf("Product %s not found", p.Id)),
			}, nil
		}
		total += productMap[p.Id].Price * float64(p.Quantity)
	}

	now := time.Now()
	expiredAt := now.Add(24 * time.Hour)
	orderEntity := entity.Order{
		Id:              uuid.NewString(),
		Number:          fmt.Sprintf("ORD-%d%08d", now.Year(), numbering.Number),
		UserId:          claims.Subject,
		OrderStatusCode: entity.OrderStatusCodeUnpaid,
		UserFullName:    request.FullName,
		Address:         request.Address,
		PhoneNumber:     request.PhoneNumber,
		Notes:           &request.Notes,
		Total:           total,
		ExpiredAt:       &expiredAt,
		CreatedAt:       now,
		CreatedBy:       claims.FullName,
	}

	invoiceItems := make([]xendit.InvoiceItem, 0)
	for _, p := range request.Products {
		prod := productMap[p.Id]
		if prod != nil {
			invoiceItems = append(invoiceItems, xendit.InvoiceItem{
				Name:     prod.Name,
				Price:    prod.Price,
				Quantity: int(p.Quantity),
			})
		}
	}
	xenditInvoice, xenditErr := invoice.CreateWithContext(ctx, &invoice.CreateParams{
		ExternalID: orderEntity.Id,
		Amount:     total,
		Customer: xendit.InvoiceCustomer{
			GivenNames: claims.FullName,
		},
		Currency:           "IDR",
		SuccessRedirectURL: fmt.Sprintf("%s/checkout/%s/success", operatingsystem.Getenv("FRONTEND_BASE_URL"), orderEntity.Id),
		Items:              invoiceItems,
	})
	if xenditErr != nil {
		err = xenditErr
		return nil, err
	}

	orderEntity.XenditInvoiceId = &xenditInvoice.ID
	orderEntity.XenditInvoiceUrl = &xenditInvoice.InvoiceURL

	err = orderRepo.CreateOrder(ctx, &orderEntity)
	if err != nil {
		return nil, err
	}

	for _, p := range request.Products {
		var orderItem = entity.OrderItem{
			Id:                   uuid.NewString(),
			ProductId:            p.Id,
			ProductName:          productMap[p.Id].Name,
			ProductImageFileName: productMap[p.Id].ImageFileName,
			ProductPrice:         productMap[p.Id].Price,
			Quantity:             p.Quantity,
			OrderId:              orderEntity.Id,
			CreatedAt:            now,
			CreatedBy:            claims.FullName,
		}

		err = orderRepo.CreateOrderItem(ctx, &orderItem)
		if err != nil {
			return nil, err
		}
	}

	numbering.Number++
	err = orderRepo.UpdateNumbering(ctx, numbering)
	if err != nil {
		return nil, err
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}

	return &order.CreateOrderResponse{
		Base: utils.SuccessResponse("Create order success"),
		Id:   orderEntity.Id,
	}, nil
}

func (os *orderService) ListOrderAdmin(ctx context.Context, request *order.ListOrderAdminRequest) (*order.ListOrderAdminResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}
	if claims.Role != entity.UserRoleAdmin {
		return nil, utils.UnauthenticatedResponse()
	}

	orders, metadata, err := os.orderRepository.GetListOrderAdminPagination(ctx, request.Pagination)
	if err != nil {
		return nil,
			err
	}

	items := make([]*order.ListOrderAdminResponseItem, 0)
	for _, o := range orders {

		products := make([]*order.ListOrderAdminResponseItemProduct, 0)
		for _, oi := range o.Items {
			products = append(products, &order.ListOrderAdminResponseItemProduct{
				Id:       oi.ProductId,
				Name:     oi.ProductName,
				Price:    oi.ProductPrice,
				Quantity: oi.Quantity,
			})
		}

		orderStatusCode := o.OrderStatusCode
		if o.OrderStatusCode == entity.OrderStatusCodeUnpaid && time.Now().After(*o.ExpiredAt) {
			orderStatusCode = entity.OrderStatusCodeExpired
		}

		items = append(items, &order.ListOrderAdminResponseItem{
			Id:         o.Id,
			Number:     o.Number,
			Customer:   o.UserFullName,
			StatusCode: orderStatusCode,
			Total:      o.Total,
			CreatedAt:  timestamppb.New(o.CreatedAt),
			Products:   products,
		})
	}

	return &order.ListOrderAdminResponse{
		Base:       utils.SuccessResponse("Get list order admin success"),
		Pagination: metadata,
		Items:      items,
	}, nil
}

func (os *orderService) ListOrder(ctx context.Context, request *order.ListOrderRequest) (*order.ListOrderResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}

	orders, metadata, err := os.orderRepository.GetListOrderPagination(ctx, request.Pagination, claims.Subject)
	if err != nil {
		return nil,
			err
	}

	items := make([]*order.ListOrderResponseItem, 0)
	for _, o := range orders {

		products := make([]*order.ListOrderResponseItemProduct, 0)
		for _, oi := range o.Items {
			products = append(products, &order.ListOrderResponseItemProduct{
				Id:       oi.ProductId,
				Name:     oi.ProductName,
				Price:    oi.ProductPrice,
				Quantity: oi.Quantity,
			})
		}

		orderStatusCode := o.OrderStatusCode
		if o.OrderStatusCode == entity.OrderStatusCodeUnpaid && time.Now().After(*o.ExpiredAt) {
			orderStatusCode = entity.OrderStatusCodeExpired
		}

		xenditInoviceUrl := ""
		if o.XenditInvoiceUrl != nil {
			xenditInoviceUrl = *o.XenditInvoiceUrl
		}
		items = append(items, &order.ListOrderResponseItem{
			Id:              o.Id,
			Number:          o.Number,
			Customer:        o.UserFullName,
			StatusCode:      orderStatusCode,
			Total:           o.Total,
			CreatedAt:       timestamppb.New(o.CreatedAt),
			Products:        products,
			XenditNvoiceUrl: xenditInoviceUrl,
		})
	}

	return &order.ListOrderResponse{
		Base:       utils.SuccessResponse("Get list order success"),
		Pagination: metadata,
		Items:      items,
	}, nil
}

func (os *orderService) DetailOrder(ctx context.Context, request *order.DetailOrderRequest) (*order.DetailOrderResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}

	orderEntity, err := os.orderRepository.GetOrderById(ctx, request.Id)
	if err != nil {
		return nil, err
	}

	if claims.Role != entity.UserRoleAdmin && claims.Subject != orderEntity.UserId {
		return &order.DetailOrderResponse{
			Base: utils.BadRequestResponse("User id is not matched"),
		}, nil
	}

	notes := ""
	if orderEntity.Notes != nil {
		notes = *orderEntity.Notes
	}
	xenditInvoiceUrl := ""
	if orderEntity.XenditInvoiceUrl != nil {
		xenditInvoiceUrl = *orderEntity.XenditInvoiceUrl
	}

	orderStatusCode := orderEntity.OrderStatusCode
	if orderEntity.OrderStatusCode == entity.OrderStatusCodeUnpaid && time.Now().After(*orderEntity.ExpiredAt) {
		orderStatusCode = entity.OrderStatusCodeExpired
	}

	items := make([]*order.DetailOrderResponseItem, 0)
	for _, oi := range orderEntity.Items {
		items = append(items, &order.DetailOrderResponseItem{
			Id:       oi.ProductId,
			Name:     oi.ProductName,
			Price:    oi.ProductPrice,
			Quantity: oi.Quantity,
		})
	}
	return &order.DetailOrderResponse{
		Base:             utils.SuccessResponse("get order detail success"),
		Id:               orderEntity.Id,
		Number:           orderEntity.Number,
		UserFullName:     orderEntity.UserFullName,
		Address:          orderEntity.Address,
		PhoneNumber:      orderEntity.PhoneNumber,
		Notes:            notes,
		OrderStatusCode:  orderStatusCode,
		CreatedAt:        timestamppb.New(orderEntity.CreatedAt),
		XenditInvoiceUrl: xenditInvoiceUrl,
		Items:            items,
		Total:            orderEntity.Total,
		ExpiredAt:        timestamppb.New(*orderEntity.ExpiredAt),
	}, nil
}

func (os *orderService) UpdateOrderStatus(ctx context.Context, request *order.UpdateOrderStatusRequest) (*order.UpdateOrderStatusResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}
	orderEntity, err := os.orderRepository.GetOrderById(ctx, request.OrderId)
	if err != nil {
		return nil, err
	}
	if orderEntity == nil {
		return &order.UpdateOrderStatusResponse{
			Base: utils.NotFoundResponse("Order not found"),
		}, nil
	}

	if claims.Role != entity.UserRoleAdmin && orderEntity.UserId != claims.Subject {
		return &order.UpdateOrderStatusResponse{
			Base: utils.BadRequestResponse("User id is not matched"),
		}, nil
	}

	if request.NewStatusCode == entity.OrderStatusCodePaid {
		if claims.Role != entity.UserRoleAdmin || orderEntity.OrderStatusCode != entity.OrderStatusCodeUnpaid {
			return &order.UpdateOrderStatusResponse{
				Base: utils.BadRequestResponse("Update status is not allowed"),
			}, nil
		}
	} else if request.NewStatusCode == entity.OrderStatusCodeCanceled {
		if orderEntity.OrderStatusCode != entity.OrderStatusCodeUnpaid {
			return &order.UpdateOrderStatusResponse{
				Base: utils.BadRequestResponse("Update status is not allowed"),
			}, nil
		}
	} else if request.NewStatusCode == entity.OrderStatusCodeShipped {
		if claims.Role != entity.UserRoleAdmin || orderEntity.OrderStatusCode != entity.OrderStatusCodePaid {
			return &order.UpdateOrderStatusResponse{
				Base: utils.BadRequestResponse("Update status is not allowed"),
			}, nil
		}
	} else if request.NewStatusCode == entity.OrderStatusCodeDone {
		if orderEntity.OrderStatusCode != entity.OrderStatusCodeShipped {
			return &order.UpdateOrderStatusResponse{
				Base: utils.BadRequestResponse("Update status is not allowed"),
			}, nil
		}
	} else {
		return &order.UpdateOrderStatusResponse{
			Base: utils.BadRequestResponse(" Invalid new status code"),
		}, nil
	}

	now := time.Now()
	orderEntity.OrderStatusCode = request.NewStatusCode
	orderEntity.UpdatedAt = &now
	orderEntity.UpdatedBy = &claims.Subject

	err = os.orderRepository.UpdateOrder(ctx, orderEntity)
	if err != nil {
		return nil, err
	}

	return &order.UpdateOrderStatusResponse{
		Base: utils.SuccessResponse("Update order status success"),
	}, nil
}

func NewOrderService(db *sql.DB, orderRepository repository.IOrderRepository, productRepository repository.IProductRepository) IOrderService {
	return &orderService{
		db:               db,
		orderRepository:  orderRepository,
		productRepostory: productRepository,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\service\product_service.go
====================
package service

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/google/uuid"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
	jwtentity "github.com/luzmareto/go-grpc-ecommerce-be/internal/entity/jwt"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/repository"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/utils"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/product"
)

type IProductService interface {
	CreateProduct(ctx context.Context, request *product.CreateProductRequest) (*product.CreateProductResponse, error)
	DetailProduct(ctx context.Context, request *product.DetailProductRequest) (*product.DetailProductResponse, error)
	EditProduct(ctx context.Context, request *product.EditProductRequest) (*product.EditProductResponse, error)
	DeleteProduct(ctx context.Context, request *product.DeleteProductRequest) (*product.DeleteProductResponse, error)
	ListProduct(ctx context.Context, request *product.ListProductRequest) (*product.ListProductResponse, error)
	ListProductAdmin(ctx context.Context, request *product.ListProductAdminRequest) (*product.ListProductAdminResponse, error)
	HighlightProducts(ctx context.Context,request *product.HighlightProductsRequest) (*product.HighlightProductsResponse, error)
}

type productService struct {
	productRepository repository.IProductRepository
}


func (ps *productService) CreateProduct(ctx context.Context, request *product.CreateProductRequest) (*product.CreateProductResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}
	// hanya admin yang bisa create product
	if claims.Role != entity.UserRoleAdmin {
		return nil, utils.UnauthenticatedResponse()
	}

	imagePath := filepath.Join("storage", "product", request.ImageFileName)
	_, err = os.Stat(imagePath)
	if err != nil {
		if os.IsNotExist(err) {
			return &product.CreateProductResponse{
				Base: utils.BadRequestResponse("file not found"),
			}, nil
		}

		return nil, err
	}

	productEntity := entity.Product{
		Id:            uuid.NewString(),
		Name:          request.Name,
		Description:   request.Description,
		Price:         request.Price,
		ImageFileName: request.ImageFileName,
		CreatedAt:     time.Now(),
		CreatedBy:     claims.FullName,
	}
	err = ps.productRepository.CreateNewProduct(ctx, &productEntity)
	if err != nil {
		return nil, err
	}

	return &product.CreateProductResponse{
		Base: utils.SuccessResponse("Product is created"),
		Id:   productEntity.Id,
	}, nil
}

func (ps *productService) DetailProduct(ctx context.Context, request *product.DetailProductRequest) (*product.DetailProductResponse, error) {
	productEntity, err := ps.productRepository.GetProductById(ctx, request.Id)
	if err != nil {
		return nil, err
	}
	if productEntity == nil {
		return &product.DetailProductResponse{
			Base: utils.NotFoundResponse("Product not found"),
		}, nil
	}
	return &product.DetailProductResponse{
		Base:        utils.SuccessResponse("Get product detail success"),
		Id:          productEntity.Id,
		Name:        productEntity.Name,
		Description: productEntity.Description,
		Price:       productEntity.Price,
		ImageUrl:    fmt.Sprintf("%s/product/%s", os.Getenv("STORAGE_SERVICE_URL"), productEntity.ImageFileName),
	}, nil
}

func (ps *productService) EditProduct(ctx context.Context, request *product.EditProductRequest) (*product.EditProductResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}
	// hanya admin yang bisa create product
	if claims.Role != entity.UserRoleAdmin {
		return nil, utils.UnauthenticatedResponse()
	}

	productEntity, err := ps.productRepository.GetProductById(ctx, request.Id)
	if err != nil {
		return nil, err
	}
	if productEntity == nil {
		return &product.EditProductResponse{
			Base: utils.NotFoundResponse("Product not found"),
		}, nil
	}

	// delete gambar lama
	if productEntity.ImageFileName != request.ImageFileName {
		newImagePath := filepath.Join("storage", "product", request.ImageFileName)
		_, err = os.Stat(newImagePath)
		if err != nil {
			if os.IsNotExist(err) {
				return &product.EditProductResponse{
					Base: utils.BadRequestResponse("Image not found"),
				}, nil
			}
			return nil, err
		}

		oldImagePath := filepath.Join("storage", "product", productEntity.ImageFileName)
		err = os.Remove(oldImagePath)
		if err != nil {
			return nil, err
		}
	}

	newProduct := entity.Product{
		Id:            request.Id,
		Name:          request.Name,
		Description:   request.Description,
		Price:         request.Price,
		ImageFileName: request.ImageFileName,
		UpdatedAt:     time.Now(),
		UpdatedBy:     &claims.FullName,
	}

	err = ps.productRepository.UpdateProduct(ctx, &newProduct)
	if err != nil {
		return nil, err
	}

	return &product.EditProductResponse{
		Base: utils.SuccessResponse("Edit product success"),
		Id:   request.Id,
	}, nil
}
func (ps *productService) DeleteProduct(ctx context.Context, request *product.DeleteProductRequest) (*product.DeleteProductResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}
	// hanya admin yang bisa create product
	if claims.Role != entity.UserRoleAdmin {
		return nil, utils.UnauthenticatedResponse()
	}

	productEntity, err := ps.productRepository.GetProductById(ctx, request.Id)
	if err != nil {
		return nil, err
	}
	if productEntity == nil {
		return &product.DeleteProductResponse{
			Base: utils.NotFoundResponse("Product not found"),
		}, nil
	}

	err = ps.productRepository.DeleteProduct(ctx, request.Id, time.Now(), claims.FullName)
	if err != nil {
		return nil, err
	}

	return &product.DeleteProductResponse{
		Base: utils.SuccessResponse("Delete product success"),
	}, nil
}

func (ps *productService) ListProduct(ctx context.Context, request *product.ListProductRequest) (*product.ListProductResponse, error) {
	products, paginationResponse, err := ps.productRepository.GetProductsPagination(ctx, request.Pagination)
	if err != nil {
		return nil, err
	}

	var data []*product.ListProductResponseItem = make([]*product.ListProductResponseItem, 0)
	for _, prod := range products {
		data = append(data, &product.ListProductResponseItem{
			Id:          prod.Id,
			Name:        prod.Name,
			Description: prod.Description,
			Price:       prod.Price,
			ImageUrl:    fmt.Sprintf("%s/products/%s", os.Getenv("STORAGE_SERVICE_URL"), prod.ImageFileName),
		})
	}

	return &product.ListProductResponse{
		Base:       utils.SuccessResponse("Get list product success"),
		Pagination: paginationResponse,
		Data:       data,
	}, nil
}

func (ps *productService) ListProductAdmin(ctx context.Context, request *product.ListProductAdminRequest) (*product.ListProductAdminResponse, error) {
	claims, err := jwtentity.GetClaimsFromContext(ctx)
	if err != nil {
		return nil, err
	}
	// hanya admin yang bisa create product
	if claims.Role != entity.UserRoleAdmin {
		return nil, utils.UnauthenticatedResponse()
	}

	products, paginationResponse, err := ps.productRepository.GetProductsPaginationAdmin(ctx, request.Pagination)
	if err != nil {
		return nil, err
	}

	var data []*product.ListProductAdminResponseItem = make([]*product.ListProductAdminResponseItem, 0)
	for _, prod := range products {
		data = append(data, &product.ListProductAdminResponseItem{
			Id:          prod.Id,
			Name:        prod.Name,
			Description: prod.Description,
			Price:       prod.Price,
			ImageUrl:    fmt.Sprintf("%s/products/%s", os.Getenv("STORAGE_SERVICE_URL"), prod.ImageFileName),
		})
	}

	return &product.ListProductAdminResponse{
		Base:       utils.SuccessResponse("Get list product admin success"),
		Pagination: paginationResponse,
		Data:       data,
	}, nil
}


func (ps *productService) HighlightProducts(ctx context.Context,request *product.HighlightProductsRequest) (*product.HighlightProductsResponse, error) {
	products,err := ps.productRepository.GetProductHighlight(ctx)
	if err != nil {
		return nil, err
	}

	var data []*product.HighlightProductsResponseItem = make([]*product.HighlightProductsResponseItem, 0)
	for _, prod := range products {
		data = append(data, &product.HighlightProductsResponseItem{
			Id:          prod.Id,
			Name:        prod.Name,
			Description: prod.Description,
			Price:       prod.Price,
			ImageUrl:    fmt.Sprintf("%s/products/%s", os.Getenv("STORAGE_SERVICE_URL"), prod.ImageFileName),
		})
	}

	return &product.HighlightProductsResponse{
		Base:       utils.SuccessResponse("Get highlight product success"),
		Data:       data,
	}, nil
}

func NewProductService(productRepository repository.IProductRepository) IProductService {
	return &productService{
		productRepository: productRepository,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\service\webhook_service.go
====================
package service

import (
	"context"
	"errors"
	"time"

	"github.com/luzmareto/go-grpc-ecommerce-be/internal/dto"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/entity"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/repository"
)

type IWebhookService interface {
	ReceiveInvoice(ctx context.Context, request *dto.XenditInvoiceRequest) error
}

type webhookService struct {
	orderRepository repository.IOrderRepository
}

func (ws *webhookService) ReceiveInvoice(ctx context.Context, request *dto.XenditInvoiceRequest) error {
	orderEntity, err := ws.orderRepository.GetOrderById(ctx, request.ExternalID)
	if err != nil {
		return err
	} //logic jika order tidak ditemukan
	if orderEntity == nil {
		return errors.New("order not found")
	}

	now := time.Now()
	updatedBy := "System"
	orderEntity.OrderStatusCode = entity.OrderStatusCodePaid
	orderEntity.UpdatedAt = &now
	orderEntity.UpdatedBy = &updatedBy
	orderEntity.XenditPaidAt = &now
	orderEntity.XenditPaymentChannel = &request.PaymentChannel
	orderEntity.XenditPaymentMethod = &request.PaymentMethod

	err = ws.orderRepository.UpdateOrder(ctx, orderEntity)
	if err != nil {
		return err
	}

	return nil
}

func NewWebhookService(orderRepository repository.IOrderRepository) IWebhookService {
	return &webhookService{
		orderRepository: orderRepository,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\utils\response.go
====================
package utils

import (
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func SuccessResponse(message string) *common.BaseResponse {
	return &common.BaseResponse{
		StatusCode: 200,
		Message:    message,
	}
}

func BadRequestResponse(message string) *common.BaseResponse {
	return &common.BaseResponse{
		StatusCode: 400,
		Message:    message,
		IsError:    true,
	}
}

func NotFoundResponse(message string) *common.BaseResponse {
	return &common.BaseResponse{
		StatusCode: 404,
		Message:    message,
		IsError:    true,
	}
}

func UnauthenticatedResponse() error {
	return status.Error(codes.Unauthenticated, "Unauthenticated")
}

func ValidationErrorResponse(validationError []*common.ValidationError) *common.BaseResponse {
	return &common.BaseResponse{
		StatusCode:       400,
		Message:          "validation error",
		IsError:          true,
		ValidationErrors: validationError,
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\internal\utils\validator.go
====================
package utils

import (
	"errors"

	"buf.build/go/protovalidate"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	"google.golang.org/protobuf/proto"
)

func CheckValidation(req proto.Message) ([]*common.ValidationError, error) {
	if err := protovalidate.Validate(req); err != nil {
		var validationError *protovalidate.ValidationError
		if errors.As(err, &validationError) {

			var validationErrorResponse []*common.ValidationError = make([]*common.ValidationError, 0)
			for _, violation := range validationError.Violations {
				validationErrorResponse = append(validationErrorResponse, &common.ValidationError{
					Field:   *violation.Proto.Field.Elements[0].FieldName,
					Message: *violation.Proto.Message,
				})
			}
			return validationErrorResponse, nil
		}
		return nil, err
	}

	return nil, nil

}




====================
FILE: D:\go-grpc-ecommerce-be\main.go
====================
package main

import (
	"context"
	"log"
	"net"
	"os"
	"time"

	"github.com/joho/godotenv" //import manual
	grpcmiddleware "github.com/luzmareto/go-grpc-ecommerce-be/internal/grpcMiddleware"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/handler"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/repository"
	"github.com/luzmareto/go-grpc-ecommerce-be/internal/service"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/auth"
	"github.com/luzmareto/go-grpc-ecommerce-be/pb/product"
	"github.com/luzmareto/go-grpc-ecommerce-be/pkg/database"
	gocache "github.com/patrickmn/go-cache"
	"google.golang.org/grpc"            //import manual
	"google.golang.org/grpc/reflection" //import manual
)

func main() {
	ctx := context.Background()
	godotenv.Load()
	lis, err := net.Listen("tcp", ":50052")
	if err != nil {
		log.Panicf("error when listen %v", err)
	}

	db := database.ConnectDB(ctx, os.Getenv("DB_URI"))
	log.Println("Connected to database")

	cacheService := gocache.New(time.Hour*24, time.Hour)

	authMiddleware := grpcmiddleware.NewAuthMiddleware(cacheService)

	authRepository := repository.NewAuthRepository(db)
	authService := service.NewAuthService(authRepository, cacheService)
	authHandler := handler.NewAuthHandler(authService)

	productRepository := repository.NewProductRepository(db)
	productService := service.NewProductService(productRepository)
	productHandler := handler.NewProductHandler(productService)

	serv := grpc.NewServer(
		grpc.ChainUnaryInterceptor(
			grpcmiddleware.ErrorMiddleware,
			authMiddleware.Middleware,
		),
	)

	auth.RegisterAuthServiceServer(serv, authHandler)
	product.RegisterProductServiceServer(serv, productHandler)

	if os.Getenv("ENVIRONMENT") == "dev" {
		reflection.Register(serv)
		log.Println("Reflection is registered.")
	}

	log.Println("Server is runing on :50052 port.")
	if err := serv.Serve(lis); err != nil {
		log.Panicf("Server is error %v", err)
	}
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\auth\auth.pb.go
====================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v5.29.3
// source: auth/auth.proto

package auth

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	common "github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RegisterRequest struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	FullName             string                 `protobuf:"bytes,1,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	Email                string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	Password             string                 `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	PasswordConfirmation string                 `protobuf:"bytes,4,opt,name=password_confirmation,json=passwordConfirmation,proto3" json:"password_confirmation,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *RegisterRequest) Reset() {
	*x = RegisterRequest{}
	mi := &file_auth_auth_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterRequest) ProtoMessage() {}

func (x *RegisterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{0}
}

func (x *RegisterRequest) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *RegisterRequest) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *RegisterRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *RegisterRequest) GetPasswordConfirmation() string {
	if x != nil {
		return x.PasswordConfirmation
	}
	return ""
}

type RegisterResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterResponse) Reset() {
	*x = RegisterResponse{}
	mi := &file_auth_auth_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterResponse) ProtoMessage() {}

func (x *RegisterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{1}
}

func (x *RegisterResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

type LoginRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Email         string                 `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LoginRequest) Reset() {
	*x = LoginRequest{}
	mi := &file_auth_auth_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoginRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoginRequest) ProtoMessage() {}

func (x *LoginRequest) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{2}
}

func (x *LoginRequest) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *LoginRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type LoginResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	AccessToken   string                 `protobuf:"bytes,2,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LoginResponse) Reset() {
	*x = LoginResponse{}
	mi := &file_auth_auth_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LoginResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LoginResponse) ProtoMessage() {}

func (x *LoginResponse) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{3}
}

func (x *LoginResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *LoginResponse) GetAccessToken() string {
	if x != nil {
		return x.AccessToken
	}
	return ""
}

type LogoutRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogoutRequest) Reset() {
	*x = LogoutRequest{}
	mi := &file_auth_auth_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogoutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogoutRequest) ProtoMessage() {}

func (x *LogoutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{4}
}

type LogoutResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogoutResponse) Reset() {
	*x = LogoutResponse{}
	mi := &file_auth_auth_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogoutResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogoutResponse) ProtoMessage() {}

func (x *LogoutResponse) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogoutResponse.ProtoReflect.Descriptor instead.
func (*LogoutResponse) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{5}
}

func (x *LogoutResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

type ChangePasswordRequest struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	OldPassword             string                 `protobuf:"bytes,1,opt,name=old_password,json=oldPassword,proto3" json:"old_password,omitempty"`
	NewPassword             string                 `protobuf:"bytes,2,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
	NewPasswordConfirmation string                 `protobuf:"bytes,3,opt,name=new_password_confirmation,json=newPasswordConfirmation,proto3" json:"new_password_confirmation,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ChangePasswordRequest) Reset() {
	*x = ChangePasswordRequest{}
	mi := &file_auth_auth_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChangePasswordRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChangePasswordRequest) ProtoMessage() {}

func (x *ChangePasswordRequest) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChangePasswordRequest.ProtoReflect.Descriptor instead.
func (*ChangePasswordRequest) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{6}
}

func (x *ChangePasswordRequest) GetOldPassword() string {
	if x != nil {
		return x.OldPassword
	}
	return ""
}

func (x *ChangePasswordRequest) GetNewPassword() string {
	if x != nil {
		return x.NewPassword
	}
	return ""
}

func (x *ChangePasswordRequest) GetNewPasswordConfirmation() string {
	if x != nil {
		return x.NewPasswordConfirmation
	}
	return ""
}

type ChangePasswordResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChangePasswordResponse) Reset() {
	*x = ChangePasswordResponse{}
	mi := &file_auth_auth_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChangePasswordResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChangePasswordResponse) ProtoMessage() {}

func (x *ChangePasswordResponse) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChangePasswordResponse.ProtoReflect.Descriptor instead.
func (*ChangePasswordResponse) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{7}
}

func (x *ChangePasswordResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

type GetProfileRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetProfileRequest) Reset() {
	*x = GetProfileRequest{}
	mi := &file_auth_auth_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetProfileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetProfileRequest) ProtoMessage() {}

func (x *GetProfileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetProfileRequest.ProtoReflect.Descriptor instead.
func (*GetProfileRequest) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{8}
}

type GetProfileResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	UserId        string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FullName      string                 `protobuf:"bytes,3,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	Email         string                 `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty"`
	RoleCode      string                 `protobuf:"bytes,5,opt,name=role_code,json=roleCode,proto3" json:"role_code,omitempty"`
	MemberSince   *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=member_since,json=memberSince,proto3" json:"member_since,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetProfileResponse) Reset() {
	*x = GetProfileResponse{}
	mi := &file_auth_auth_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetProfileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetProfileResponse) ProtoMessage() {}

func (x *GetProfileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_auth_auth_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetProfileResponse.ProtoReflect.Descriptor instead.
func (*GetProfileResponse) Descriptor() ([]byte, []int) {
	return file_auth_auth_proto_rawDescGZIP(), []int{9}
}

func (x *GetProfileResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *GetProfileResponse) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *GetProfileResponse) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *GetProfileResponse) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *GetProfileResponse) GetRoleCode() string {
	if x != nil {
		return x.RoleCode
	}
	return ""
}

func (x *GetProfileResponse) GetMemberSince() *timestamppb.Timestamp {
	if x != nil {
		return x.MemberSince
	}
	return nil
}

var File_auth_auth_proto protoreflect.FileDescriptor

const file_auth_auth_proto_rawDesc = "" +
	"\n" +
	"\x0fauth/auth.proto\x12\x04auth\x1a\x1acommon/base_response.proto\x1a\x1bbuf/validate/validate.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xc7\x01\n" +
	"\x0fRegisterRequest\x12'\n" +
	"\tfull_name\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\bfullName\x12\"\n" +
	"\x05email\x18\x02 \x01(\tB\f\xbaH\tr\a\x10\x01\x18\xff\x01`\x01R\x05email\x12&\n" +
	"\bpassword\x18\x03 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\bpassword\x12?\n" +
	"\x15password_confirmation\x18\x04 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x14passwordConfirmation\"<\n" +
	"\x10RegisterResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\"Z\n" +
	"\fLoginRequest\x12\"\n" +
	"\x05email\x18\x01 \x01(\tB\f\xbaH\tr\a\x10\x01\x18\xff\x01`\x01R\x05email\x12&\n" +
	"\bpassword\x18\x02 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\bpassword\"\\\n" +
	"\rLoginResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12!\n" +
	"\faccess_token\x18\x02 \x01(\tR\vaccessToken\"\x0f\n" +
	"\rLogoutRequest\":\n" +
	"\x0eLogoutResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\"\xbd\x01\n" +
	"\x15ChangePasswordRequest\x12-\n" +
	"\fold_password\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\voldPassword\x12-\n" +
	"\fnew_password\x18\x02 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\vnewPassword\x12F\n" +
	"\x19new_password_confirmation\x18\x03 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x17newPasswordConfirmation\"B\n" +
	"\x16ChangePasswordResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\"\x13\n" +
	"\x11GetProfileRequest\"\xe6\x01\n" +
	"\x12GetProfileResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\x12\x1b\n" +
	"\tfull_name\x18\x03 \x01(\tR\bfullName\x12\x14\n" +
	"\x05email\x18\x04 \x01(\tR\x05email\x12\x1b\n" +
	"\trole_code\x18\x05 \x01(\tR\broleCode\x12=\n" +
	"\fmember_since\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\vmemberSince2\xbd\x02\n" +
	"\vAuthService\x129\n" +
	"\bRegister\x12\x15.auth.RegisterRequest\x1a\x16.auth.RegisterResponse\x120\n" +
	"\x05Login\x12\x12.auth.LoginRequest\x1a\x13.auth.LoginResponse\x123\n" +
	"\x06Logout\x12\x13.auth.LogoutRequest\x1a\x14.auth.LogoutResponse\x12K\n" +
	"\x0eChangePassword\x12\x1b.auth.ChangePasswordRequest\x1a\x1c.auth.ChangePasswordResponse\x12?\n" +
	"\n" +
	"GetProfile\x12\x17.auth.GetProfileRequest\x1a\x18.auth.GetProfileResponseB3Z1github.com/luzmareto/go-grpc-ecommerce-be/pb/authb\x06proto3"

var (
	file_auth_auth_proto_rawDescOnce sync.Once
	file_auth_auth_proto_rawDescData []byte
)

func file_auth_auth_proto_rawDescGZIP() []byte {
	file_auth_auth_proto_rawDescOnce.Do(func() {
		file_auth_auth_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_auth_auth_proto_rawDesc), len(file_auth_auth_proto_rawDesc)))
	})
	return file_auth_auth_proto_rawDescData
}

var file_auth_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_auth_auth_proto_goTypes = []any{
	(*RegisterRequest)(nil),        // 0: auth.RegisterRequest
	(*RegisterResponse)(nil),       // 1: auth.RegisterResponse
	(*LoginRequest)(nil),           // 2: auth.LoginRequest
	(*LoginResponse)(nil),          // 3: auth.LoginResponse
	(*LogoutRequest)(nil),          // 4: auth.LogoutRequest
	(*LogoutResponse)(nil),         // 5: auth.LogoutResponse
	(*ChangePasswordRequest)(nil),  // 6: auth.ChangePasswordRequest
	(*ChangePasswordResponse)(nil), // 7: auth.ChangePasswordResponse
	(*GetProfileRequest)(nil),      // 8: auth.GetProfileRequest
	(*GetProfileResponse)(nil),     // 9: auth.GetProfileResponse
	(*common.BaseResponse)(nil),    // 10: common.BaseResponse
	(*timestamppb.Timestamp)(nil),  // 11: google.protobuf.Timestamp
}
var file_auth_auth_proto_depIdxs = []int32{
	10, // 0: auth.RegisterResponse.base:type_name -> common.BaseResponse
	10, // 1: auth.LoginResponse.base:type_name -> common.BaseResponse
	10, // 2: auth.LogoutResponse.base:type_name -> common.BaseResponse
	10, // 3: auth.ChangePasswordResponse.base:type_name -> common.BaseResponse
	10, // 4: auth.GetProfileResponse.base:type_name -> common.BaseResponse
	11, // 5: auth.GetProfileResponse.member_since:type_name -> google.protobuf.Timestamp
	0,  // 6: auth.AuthService.Register:input_type -> auth.RegisterRequest
	2,  // 7: auth.AuthService.Login:input_type -> auth.LoginRequest
	4,  // 8: auth.AuthService.Logout:input_type -> auth.LogoutRequest
	6,  // 9: auth.AuthService.ChangePassword:input_type -> auth.ChangePasswordRequest
	8,  // 10: auth.AuthService.GetProfile:input_type -> auth.GetProfileRequest
	1,  // 11: auth.AuthService.Register:output_type -> auth.RegisterResponse
	3,  // 12: auth.AuthService.Login:output_type -> auth.LoginResponse
	5,  // 13: auth.AuthService.Logout:output_type -> auth.LogoutResponse
	7,  // 14: auth.AuthService.ChangePassword:output_type -> auth.ChangePasswordResponse
	9,  // 15: auth.AuthService.GetProfile:output_type -> auth.GetProfileResponse
	11, // [11:16] is the sub-list for method output_type
	6,  // [6:11] is the sub-list for method input_type
	6,  // [6:6] is the sub-list for extension type_name
	6,  // [6:6] is the sub-list for extension extendee
	0,  // [0:6] is the sub-list for field type_name
}

func init() { file_auth_auth_proto_init() }
func file_auth_auth_proto_init() {
	if File_auth_auth_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_auth_auth_proto_rawDesc), len(file_auth_auth_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_auth_auth_proto_goTypes,
		DependencyIndexes: file_auth_auth_proto_depIdxs,
		MessageInfos:      file_auth_auth_proto_msgTypes,
	}.Build()
	File_auth_auth_proto = out.File
	file_auth_auth_proto_goTypes = nil
	file_auth_auth_proto_depIdxs = nil
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\auth\auth_grpc.pb.go
====================
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: auth/auth.proto

package auth

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuthService_Register_FullMethodName       = "/auth.AuthService/Register"
	AuthService_Login_FullMethodName          = "/auth.AuthService/Login"
	AuthService_Logout_FullMethodName         = "/auth.AuthService/Logout"
	AuthService_ChangePassword_FullMethodName = "/auth.AuthService/ChangePassword"
	AuthService_GetProfile_FullMethodName     = "/auth.AuthService/GetProfile"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
	ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error)
	GetProfile(ctx context.Context, in *GetProfileRequest, opts ...grpc.CallOption) (*GetProfileResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, AuthService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, AuthService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangePasswordResponse)
	err := c.cc.Invoke(ctx, AuthService_ChangePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetProfile(ctx context.Context, in *GetProfileRequest, opts ...grpc.CallOption) (*GetProfileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProfileResponse)
	err := c.cc.Invoke(ctx, AuthService_GetProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error)
	GetProfile(context.Context, *GetProfileRequest) (*GetProfileResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedAuthServiceServer) ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedAuthServiceServer) GetProfile(context.Context, *GetProfileRequest) (*GetProfileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfile not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_GetProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetProfile(ctx, req.(*GetProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _AuthService_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _AuthService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _AuthService_Logout_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _AuthService_ChangePassword_Handler,
		},
		{
			MethodName: "GetProfile",
			Handler:    _AuthService_GetProfile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth/auth.proto",
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\cart\cart.pb.go
====================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v5.29.3
// source: cart/cart.proto

package cart

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	common "github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AddProductToCartRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ProductId     string                 `protobuf:"bytes,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddProductToCartRequest) Reset() {
	*x = AddProductToCartRequest{}
	mi := &file_cart_cart_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddProductToCartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddProductToCartRequest) ProtoMessage() {}

func (x *AddProductToCartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddProductToCartRequest.ProtoReflect.Descriptor instead.
func (*AddProductToCartRequest) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{0}
}

func (x *AddProductToCartRequest) GetProductId() string {
	if x != nil {
		return x.ProductId
	}
	return ""
}

type AddProductToCartResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Id            string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddProductToCartResponse) Reset() {
	*x = AddProductToCartResponse{}
	mi := &file_cart_cart_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddProductToCartResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddProductToCartResponse) ProtoMessage() {}

func (x *AddProductToCartResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddProductToCartResponse.ProtoReflect.Descriptor instead.
func (*AddProductToCartResponse) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{1}
}

func (x *AddProductToCartResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *AddProductToCartResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type ListCartRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCartRequest) Reset() {
	*x = ListCartRequest{}
	mi := &file_cart_cart_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCartRequest) ProtoMessage() {}

func (x *ListCartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCartRequest.ProtoReflect.Descriptor instead.
func (*ListCartRequest) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{2}
}

type ListCartResponseItem struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	CartId          string                 `protobuf:"bytes,1,opt,name=cart_id,json=cartId,proto3" json:"cart_id,omitempty"`
	ProductId       string                 `protobuf:"bytes,2,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	ProductName     string                 `protobuf:"bytes,3,opt,name=product_name,json=productName,proto3" json:"product_name,omitempty"`
	ProductImageUrl string                 `protobuf:"bytes,4,opt,name=product_image_url,json=productImageUrl,proto3" json:"product_image_url,omitempty"`
	ProductPrice    float64                `protobuf:"fixed64,5,opt,name=product_price,json=productPrice,proto3" json:"product_price,omitempty"`
	Quantity        int64                  `protobuf:"varint,6,opt,name=quantity,proto3" json:"quantity,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ListCartResponseItem) Reset() {
	*x = ListCartResponseItem{}
	mi := &file_cart_cart_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCartResponseItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCartResponseItem) ProtoMessage() {}

func (x *ListCartResponseItem) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCartResponseItem.ProtoReflect.Descriptor instead.
func (*ListCartResponseItem) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{3}
}

func (x *ListCartResponseItem) GetCartId() string {
	if x != nil {
		return x.CartId
	}
	return ""
}

func (x *ListCartResponseItem) GetProductId() string {
	if x != nil {
		return x.ProductId
	}
	return ""
}

func (x *ListCartResponseItem) GetProductName() string {
	if x != nil {
		return x.ProductName
	}
	return ""
}

func (x *ListCartResponseItem) GetProductImageUrl() string {
	if x != nil {
		return x.ProductImageUrl
	}
	return ""
}

func (x *ListCartResponseItem) GetProductPrice() float64 {
	if x != nil {
		return x.ProductPrice
	}
	return 0
}

func (x *ListCartResponseItem) GetQuantity() int64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

type ListCartResponse struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	Base          *common.BaseResponse    `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Items         []*ListCartResponseItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCartResponse) Reset() {
	*x = ListCartResponse{}
	mi := &file_cart_cart_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCartResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCartResponse) ProtoMessage() {}

func (x *ListCartResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCartResponse.ProtoReflect.Descriptor instead.
func (*ListCartResponse) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{4}
}

func (x *ListCartResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *ListCartResponse) GetItems() []*ListCartResponseItem {
	if x != nil {
		return x.Items
	}
	return nil
}

type DeleteCartRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CartId        string                 `protobuf:"bytes,1,opt,name=cart_id,json=cartId,proto3" json:"cart_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteCartRequest) Reset() {
	*x = DeleteCartRequest{}
	mi := &file_cart_cart_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteCartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteCartRequest) ProtoMessage() {}

func (x *DeleteCartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteCartRequest.ProtoReflect.Descriptor instead.
func (*DeleteCartRequest) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{5}
}

func (x *DeleteCartRequest) GetCartId() string {
	if x != nil {
		return x.CartId
	}
	return ""
}

type DeleteCartResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteCartResponse) Reset() {
	*x = DeleteCartResponse{}
	mi := &file_cart_cart_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteCartResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteCartResponse) ProtoMessage() {}

func (x *DeleteCartResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteCartResponse.ProtoReflect.Descriptor instead.
func (*DeleteCartResponse) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{6}
}

func (x *DeleteCartResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

type UpdateCartQuantityRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CartId        string                 `protobuf:"bytes,1,opt,name=cart_id,json=cartId,proto3" json:"cart_id,omitempty"`
	NewQuantity   int64                  `protobuf:"varint,2,opt,name=new_quantity,json=newQuantity,proto3" json:"new_quantity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateCartQuantityRequest) Reset() {
	*x = UpdateCartQuantityRequest{}
	mi := &file_cart_cart_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateCartQuantityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateCartQuantityRequest) ProtoMessage() {}

func (x *UpdateCartQuantityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateCartQuantityRequest.ProtoReflect.Descriptor instead.
func (*UpdateCartQuantityRequest) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{7}
}

func (x *UpdateCartQuantityRequest) GetCartId() string {
	if x != nil {
		return x.CartId
	}
	return ""
}

func (x *UpdateCartQuantityRequest) GetNewQuantity() int64 {
	if x != nil {
		return x.NewQuantity
	}
	return 0
}

type UpdateCartQuantityResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateCartQuantityResponse) Reset() {
	*x = UpdateCartQuantityResponse{}
	mi := &file_cart_cart_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateCartQuantityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateCartQuantityResponse) ProtoMessage() {}

func (x *UpdateCartQuantityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cart_cart_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateCartQuantityResponse.ProtoReflect.Descriptor instead.
func (*UpdateCartQuantityResponse) Descriptor() ([]byte, []int) {
	return file_cart_cart_proto_rawDescGZIP(), []int{8}
}

func (x *UpdateCartQuantityResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

var File_cart_cart_proto protoreflect.FileDescriptor

const file_cart_cart_proto_rawDesc = "" +
	"\n" +
	"\x0fcart/cart.proto\x12\x04cart\x1a\x1acommon/base_response.proto\x1a\x1bbuf/validate/validate.proto\"D\n" +
	"\x17AddProductToCartRequest\x12)\n" +
	"\n" +
	"product_id\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\tproductId\"T\n" +
	"\x18AddProductToCartResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\"\x11\n" +
	"\x0fListCartRequest\"\xde\x01\n" +
	"\x14ListCartResponseItem\x12\x17\n" +
	"\acart_id\x18\x01 \x01(\tR\x06cartId\x12\x1d\n" +
	"\n" +
	"product_id\x18\x02 \x01(\tR\tproductId\x12!\n" +
	"\fproduct_name\x18\x03 \x01(\tR\vproductName\x12*\n" +
	"\x11product_image_url\x18\x04 \x01(\tR\x0fproductImageUrl\x12#\n" +
	"\rproduct_price\x18\x05 \x01(\x01R\fproductPrice\x12\x1a\n" +
	"\bquantity\x18\x06 \x01(\x03R\bquantity\"n\n" +
	"\x10ListCartResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x120\n" +
	"\x05items\x18\x02 \x03(\v2\x1a.cart.ListCartResponseItemR\x05items\"8\n" +
	"\x11DeleteCartRequest\x12#\n" +
	"\acart_id\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x06cartId\">\n" +
	"\x12DeleteCartResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\"l\n" +
	"\x19UpdateCartQuantityRequest\x12#\n" +
	"\acart_id\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x06cartId\x12*\n" +
	"\fnew_quantity\x18\x02 \x01(\x03B\a\xbaH\x04\"\x02(\x00R\vnewQuantity\"F\n" +
	"\x1aUpdateCartQuantityResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base2\xb5\x02\n" +
	"\vCartService\x12Q\n" +
	"\x10AddProductToCart\x12\x1d.cart.AddProductToCartRequest\x1a\x1e.cart.AddProductToCartResponse\x129\n" +
	"\bListCart\x12\x15.cart.ListCartRequest\x1a\x16.cart.ListCartResponse\x12?\n" +
	"\n" +
	"DeleteCart\x12\x17.cart.DeleteCartRequest\x1a\x18.cart.DeleteCartResponse\x12W\n" +
	"\x12UpdateCartQuantity\x12\x1f.cart.UpdateCartQuantityRequest\x1a .cart.UpdateCartQuantityResponseB3Z1github.com/luzmareto/go-grpc-ecommerce-be/pb/cartb\x06proto3"

var (
	file_cart_cart_proto_rawDescOnce sync.Once
	file_cart_cart_proto_rawDescData []byte
)

func file_cart_cart_proto_rawDescGZIP() []byte {
	file_cart_cart_proto_rawDescOnce.Do(func() {
		file_cart_cart_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cart_cart_proto_rawDesc), len(file_cart_cart_proto_rawDesc)))
	})
	return file_cart_cart_proto_rawDescData
}

var file_cart_cart_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_cart_cart_proto_goTypes = []any{
	(*AddProductToCartRequest)(nil),    // 0: cart.AddProductToCartRequest
	(*AddProductToCartResponse)(nil),   // 1: cart.AddProductToCartResponse
	(*ListCartRequest)(nil),            // 2: cart.ListCartRequest
	(*ListCartResponseItem)(nil),       // 3: cart.ListCartResponseItem
	(*ListCartResponse)(nil),           // 4: cart.ListCartResponse
	(*DeleteCartRequest)(nil),          // 5: cart.DeleteCartRequest
	(*DeleteCartResponse)(nil),         // 6: cart.DeleteCartResponse
	(*UpdateCartQuantityRequest)(nil),  // 7: cart.UpdateCartQuantityRequest
	(*UpdateCartQuantityResponse)(nil), // 8: cart.UpdateCartQuantityResponse
	(*common.BaseResponse)(nil),        // 9: common.BaseResponse
}
var file_cart_cart_proto_depIdxs = []int32{
	9, // 0: cart.AddProductToCartResponse.base:type_name -> common.BaseResponse
	9, // 1: cart.ListCartResponse.base:type_name -> common.BaseResponse
	3, // 2: cart.ListCartResponse.items:type_name -> cart.ListCartResponseItem
	9, // 3: cart.DeleteCartResponse.base:type_name -> common.BaseResponse
	9, // 4: cart.UpdateCartQuantityResponse.base:type_name -> common.BaseResponse
	0, // 5: cart.CartService.AddProductToCart:input_type -> cart.AddProductToCartRequest
	2, // 6: cart.CartService.ListCart:input_type -> cart.ListCartRequest
	5, // 7: cart.CartService.DeleteCart:input_type -> cart.DeleteCartRequest
	7, // 8: cart.CartService.UpdateCartQuantity:input_type -> cart.UpdateCartQuantityRequest
	1, // 9: cart.CartService.AddProductToCart:output_type -> cart.AddProductToCartResponse
	4, // 10: cart.CartService.ListCart:output_type -> cart.ListCartResponse
	6, // 11: cart.CartService.DeleteCart:output_type -> cart.DeleteCartResponse
	8, // 12: cart.CartService.UpdateCartQuantity:output_type -> cart.UpdateCartQuantityResponse
	9, // [9:13] is the sub-list for method output_type
	5, // [5:9] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_cart_cart_proto_init() }
func file_cart_cart_proto_init() {
	if File_cart_cart_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cart_cart_proto_rawDesc), len(file_cart_cart_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_cart_cart_proto_goTypes,
		DependencyIndexes: file_cart_cart_proto_depIdxs,
		MessageInfos:      file_cart_cart_proto_msgTypes,
	}.Build()
	File_cart_cart_proto = out.File
	file_cart_cart_proto_goTypes = nil
	file_cart_cart_proto_depIdxs = nil
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\cart\cart_grpc.pb.go
====================
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: cart/cart.proto

package cart

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CartService_AddProductToCart_FullMethodName   = "/cart.CartService/AddProductToCart"
	CartService_ListCart_FullMethodName           = "/cart.CartService/ListCart"
	CartService_DeleteCart_FullMethodName         = "/cart.CartService/DeleteCart"
	CartService_UpdateCartQuantity_FullMethodName = "/cart.CartService/UpdateCartQuantity"
)

// CartServiceClient is the client API for CartService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CartServiceClient interface {
	AddProductToCart(ctx context.Context, in *AddProductToCartRequest, opts ...grpc.CallOption) (*AddProductToCartResponse, error)
	ListCart(ctx context.Context, in *ListCartRequest, opts ...grpc.CallOption) (*ListCartResponse, error)
	DeleteCart(ctx context.Context, in *DeleteCartRequest, opts ...grpc.CallOption) (*DeleteCartResponse, error)
	UpdateCartQuantity(ctx context.Context, in *UpdateCartQuantityRequest, opts ...grpc.CallOption) (*UpdateCartQuantityResponse, error)
}

type cartServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCartServiceClient(cc grpc.ClientConnInterface) CartServiceClient {
	return &cartServiceClient{cc}
}

func (c *cartServiceClient) AddProductToCart(ctx context.Context, in *AddProductToCartRequest, opts ...grpc.CallOption) (*AddProductToCartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddProductToCartResponse)
	err := c.cc.Invoke(ctx, CartService_AddProductToCart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartServiceClient) ListCart(ctx context.Context, in *ListCartRequest, opts ...grpc.CallOption) (*ListCartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCartResponse)
	err := c.cc.Invoke(ctx, CartService_ListCart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartServiceClient) DeleteCart(ctx context.Context, in *DeleteCartRequest, opts ...grpc.CallOption) (*DeleteCartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCartResponse)
	err := c.cc.Invoke(ctx, CartService_DeleteCart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartServiceClient) UpdateCartQuantity(ctx context.Context, in *UpdateCartQuantityRequest, opts ...grpc.CallOption) (*UpdateCartQuantityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCartQuantityResponse)
	err := c.cc.Invoke(ctx, CartService_UpdateCartQuantity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CartServiceServer is the server API for CartService service.
// All implementations must embed UnimplementedCartServiceServer
// for forward compatibility.
type CartServiceServer interface {
	AddProductToCart(context.Context, *AddProductToCartRequest) (*AddProductToCartResponse, error)
	ListCart(context.Context, *ListCartRequest) (*ListCartResponse, error)
	DeleteCart(context.Context, *DeleteCartRequest) (*DeleteCartResponse, error)
	UpdateCartQuantity(context.Context, *UpdateCartQuantityRequest) (*UpdateCartQuantityResponse, error)
	mustEmbedUnimplementedCartServiceServer()
}

// UnimplementedCartServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCartServiceServer struct{}

func (UnimplementedCartServiceServer) AddProductToCart(context.Context, *AddProductToCartRequest) (*AddProductToCartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddProductToCart not implemented")
}
func (UnimplementedCartServiceServer) ListCart(context.Context, *ListCartRequest) (*ListCartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCart not implemented")
}
func (UnimplementedCartServiceServer) DeleteCart(context.Context, *DeleteCartRequest) (*DeleteCartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCart not implemented")
}
func (UnimplementedCartServiceServer) UpdateCartQuantity(context.Context, *UpdateCartQuantityRequest) (*UpdateCartQuantityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCartQuantity not implemented")
}
func (UnimplementedCartServiceServer) mustEmbedUnimplementedCartServiceServer() {}
func (UnimplementedCartServiceServer) testEmbeddedByValue()                     {}

// UnsafeCartServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CartServiceServer will
// result in compilation errors.
type UnsafeCartServiceServer interface {
	mustEmbedUnimplementedCartServiceServer()
}

func RegisterCartServiceServer(s grpc.ServiceRegistrar, srv CartServiceServer) {
	// If the following call pancis, it indicates UnimplementedCartServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CartService_ServiceDesc, srv)
}

func _CartService_AddProductToCart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProductToCartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartServiceServer).AddProductToCart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartService_AddProductToCart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartServiceServer).AddProductToCart(ctx, req.(*AddProductToCartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartService_ListCart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartServiceServer).ListCart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartService_ListCart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartServiceServer).ListCart(ctx, req.(*ListCartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartService_DeleteCart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartServiceServer).DeleteCart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartService_DeleteCart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartServiceServer).DeleteCart(ctx, req.(*DeleteCartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartService_UpdateCartQuantity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCartQuantityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartServiceServer).UpdateCartQuantity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartService_UpdateCartQuantity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartServiceServer).UpdateCartQuantity(ctx, req.(*UpdateCartQuantityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CartService_ServiceDesc is the grpc.ServiceDesc for CartService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CartService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cart.CartService",
	HandlerType: (*CartServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddProductToCart",
			Handler:    _CartService_AddProductToCart_Handler,
		},
		{
			MethodName: "ListCart",
			Handler:    _CartService_ListCart_Handler,
		},
		{
			MethodName: "DeleteCart",
			Handler:    _CartService_DeleteCart_Handler,
		},
		{
			MethodName: "UpdateCartQuantity",
			Handler:    _CartService_UpdateCartQuantity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cart/cart.proto",
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\common\base_response.pb.go
====================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v5.29.3
// source: common/base_response.proto

// generated proto: protoc --go_out=./pb --go-grpc_out=./pb --proto_path=./proto --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative common/base_response.proto

package common

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ValidationError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Field         string                 `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidationError) Reset() {
	*x = ValidationError{}
	mi := &file_common_base_response_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidationError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidationError) ProtoMessage() {}

func (x *ValidationError) ProtoReflect() protoreflect.Message {
	mi := &file_common_base_response_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidationError.ProtoReflect.Descriptor instead.
func (*ValidationError) Descriptor() ([]byte, []int) {
	return file_common_base_response_proto_rawDescGZIP(), []int{0}
}

func (x *ValidationError) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *ValidationError) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type BaseResponse struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	StatusCode       int64                  `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	Message          string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	IsError          bool                   `protobuf:"varint,3,opt,name=is_error,json=isError,proto3" json:"is_error,omitempty"`
	ValidationErrors []*ValidationError     `protobuf:"bytes,4,rep,name=validation_errors,json=validationErrors,proto3" json:"validation_errors,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *BaseResponse) Reset() {
	*x = BaseResponse{}
	mi := &file_common_base_response_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BaseResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BaseResponse) ProtoMessage() {}

func (x *BaseResponse) ProtoReflect() protoreflect.Message {
	mi := &file_common_base_response_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BaseResponse.ProtoReflect.Descriptor instead.
func (*BaseResponse) Descriptor() ([]byte, []int) {
	return file_common_base_response_proto_rawDescGZIP(), []int{1}
}

func (x *BaseResponse) GetStatusCode() int64 {
	if x != nil {
		return x.StatusCode
	}
	return 0
}

func (x *BaseResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *BaseResponse) GetIsError() bool {
	if x != nil {
		return x.IsError
	}
	return false
}

func (x *BaseResponse) GetValidationErrors() []*ValidationError {
	if x != nil {
		return x.ValidationErrors
	}
	return nil
}

var File_common_base_response_proto protoreflect.FileDescriptor

const file_common_base_response_proto_rawDesc = "" +
	"\n" +
	"\x1acommon/base_response.proto\x12\x06common\"A\n" +
	"\x0fValidationError\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"\xaa\x01\n" +
	"\fBaseResponse\x12\x1f\n" +
	"\vstatus_code\x18\x01 \x01(\x03R\n" +
	"statusCode\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x19\n" +
	"\bis_error\x18\x03 \x01(\bR\aisError\x12D\n" +
	"\x11validation_errors\x18\x04 \x03(\v2\x17.common.ValidationErrorR\x10validationErrorsB5Z3github.com/luzmareto/go-grpc-ecommerce-be/pb/commonb\x06proto3"

var (
	file_common_base_response_proto_rawDescOnce sync.Once
	file_common_base_response_proto_rawDescData []byte
)

func file_common_base_response_proto_rawDescGZIP() []byte {
	file_common_base_response_proto_rawDescOnce.Do(func() {
		file_common_base_response_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_common_base_response_proto_rawDesc), len(file_common_base_response_proto_rawDesc)))
	})
	return file_common_base_response_proto_rawDescData
}

var file_common_base_response_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_common_base_response_proto_goTypes = []any{
	(*ValidationError)(nil), // 0: common.ValidationError
	(*BaseResponse)(nil),    // 1: common.BaseResponse
}
var file_common_base_response_proto_depIdxs = []int32{
	0, // 0: common.BaseResponse.validation_errors:type_name -> common.ValidationError
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_common_base_response_proto_init() }
func file_common_base_response_proto_init() {
	if File_common_base_response_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_common_base_response_proto_rawDesc), len(file_common_base_response_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_common_base_response_proto_goTypes,
		DependencyIndexes: file_common_base_response_proto_depIdxs,
		MessageInfos:      file_common_base_response_proto_msgTypes,
	}.Build()
	File_common_base_response_proto = out.File
	file_common_base_response_proto_goTypes = nil
	file_common_base_response_proto_depIdxs = nil
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\common\pagination.pb.go
====================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v5.29.3
// source: common/pagination.proto

// generated proto: protoc --go_out=./pb --go-grpc_out=./pb --proto_path=./proto --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative common/pagination.proto

package common

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PaginationSortRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Field         string                 `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
	Direction     string                 `protobuf:"bytes,2,opt,name=direction,proto3" json:"direction,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PaginationSortRequest) Reset() {
	*x = PaginationSortRequest{}
	mi := &file_common_pagination_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PaginationSortRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PaginationSortRequest) ProtoMessage() {}

func (x *PaginationSortRequest) ProtoReflect() protoreflect.Message {
	mi := &file_common_pagination_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PaginationSortRequest.ProtoReflect.Descriptor instead.
func (*PaginationSortRequest) Descriptor() ([]byte, []int) {
	return file_common_pagination_proto_rawDescGZIP(), []int{0}
}

func (x *PaginationSortRequest) GetField() string {
	if x != nil {
		return x.Field
	}
	return ""
}

func (x *PaginationSortRequest) GetDirection() string {
	if x != nil {
		return x.Direction
	}
	return ""
}

type PaginationRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CurrentPage   int32                  `protobuf:"varint,1,opt,name=current_page,json=currentPage,proto3" json:"current_page,omitempty"`
	ItemPerPage   int32                  `protobuf:"varint,2,opt,name=item_per_page,json=itemPerPage,proto3" json:"item_per_page,omitempty"`
	Sort          *PaginationSortRequest `protobuf:"bytes,3,opt,name=sort,proto3" json:"sort,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PaginationRequest) Reset() {
	*x = PaginationRequest{}
	mi := &file_common_pagination_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PaginationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PaginationRequest) ProtoMessage() {}

func (x *PaginationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_common_pagination_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PaginationRequest.ProtoReflect.Descriptor instead.
func (*PaginationRequest) Descriptor() ([]byte, []int) {
	return file_common_pagination_proto_rawDescGZIP(), []int{1}
}

func (x *PaginationRequest) GetCurrentPage() int32 {
	if x != nil {
		return x.CurrentPage
	}
	return 0
}

func (x *PaginationRequest) GetItemPerPage() int32 {
	if x != nil {
		return x.ItemPerPage
	}
	return 0
}

func (x *PaginationRequest) GetSort() *PaginationSortRequest {
	if x != nil {
		return x.Sort
	}
	return nil
}

type PaginationResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	CurrentPage    int32                  `protobuf:"varint,1,opt,name=current_page,json=currentPage,proto3" json:"current_page,omitempty"`
	TotalPageCount int32                  `protobuf:"varint,2,opt,name=total_page_count,json=totalPageCount,proto3" json:"total_page_count,omitempty"`
	ItemPerPage    int32                  `protobuf:"varint,3,opt,name=item_per_page,json=itemPerPage,proto3" json:"item_per_page,omitempty"`
	TotalItemCount int32                  `protobuf:"varint,4,opt,name=total_item_count,json=totalItemCount,proto3" json:"total_item_count,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PaginationResponse) Reset() {
	*x = PaginationResponse{}
	mi := &file_common_pagination_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PaginationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PaginationResponse) ProtoMessage() {}

func (x *PaginationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_common_pagination_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PaginationResponse.ProtoReflect.Descriptor instead.
func (*PaginationResponse) Descriptor() ([]byte, []int) {
	return file_common_pagination_proto_rawDescGZIP(), []int{2}
}

func (x *PaginationResponse) GetCurrentPage() int32 {
	if x != nil {
		return x.CurrentPage
	}
	return 0
}

func (x *PaginationResponse) GetTotalPageCount() int32 {
	if x != nil {
		return x.TotalPageCount
	}
	return 0
}

func (x *PaginationResponse) GetItemPerPage() int32 {
	if x != nil {
		return x.ItemPerPage
	}
	return 0
}

func (x *PaginationResponse) GetTotalItemCount() int32 {
	if x != nil {
		return x.TotalItemCount
	}
	return 0
}

var File_common_pagination_proto protoreflect.FileDescriptor

const file_common_pagination_proto_rawDesc = "" +
	"\n" +
	"\x17common/pagination.proto\x12\x06common\"K\n" +
	"\x15PaginationSortRequest\x12\x14\n" +
	"\x05field\x18\x01 \x01(\tR\x05field\x12\x1c\n" +
	"\tdirection\x18\x02 \x01(\tR\tdirection\"\x8d\x01\n" +
	"\x11PaginationRequest\x12!\n" +
	"\fcurrent_page\x18\x01 \x01(\x05R\vcurrentPage\x12\"\n" +
	"\ritem_per_page\x18\x02 \x01(\x05R\vitemPerPage\x121\n" +
	"\x04sort\x18\x03 \x01(\v2\x1d.common.PaginationSortRequestR\x04sort\"\xaf\x01\n" +
	"\x12PaginationResponse\x12!\n" +
	"\fcurrent_page\x18\x01 \x01(\x05R\vcurrentPage\x12(\n" +
	"\x10total_page_count\x18\x02 \x01(\x05R\x0etotalPageCount\x12\"\n" +
	"\ritem_per_page\x18\x03 \x01(\x05R\vitemPerPage\x12(\n" +
	"\x10total_item_count\x18\x04 \x01(\x05R\x0etotalItemCountB5Z3github.com/luzmareto/go-grpc-ecommerce-be/pb/commonb\x06proto3"

var (
	file_common_pagination_proto_rawDescOnce sync.Once
	file_common_pagination_proto_rawDescData []byte
)

func file_common_pagination_proto_rawDescGZIP() []byte {
	file_common_pagination_proto_rawDescOnce.Do(func() {
		file_common_pagination_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_common_pagination_proto_rawDesc), len(file_common_pagination_proto_rawDesc)))
	})
	return file_common_pagination_proto_rawDescData
}

var file_common_pagination_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_common_pagination_proto_goTypes = []any{
	(*PaginationSortRequest)(nil), // 0: common.PaginationSortRequest
	(*PaginationRequest)(nil),     // 1: common.PaginationRequest
	(*PaginationResponse)(nil),    // 2: common.PaginationResponse
}
var file_common_pagination_proto_depIdxs = []int32{
	0, // 0: common.PaginationRequest.sort:type_name -> common.PaginationSortRequest
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_common_pagination_proto_init() }
func file_common_pagination_proto_init() {
	if File_common_pagination_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_common_pagination_proto_rawDesc), len(file_common_pagination_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_common_pagination_proto_goTypes,
		DependencyIndexes: file_common_pagination_proto_depIdxs,
		MessageInfos:      file_common_pagination_proto_msgTypes,
	}.Build()
	File_common_pagination_proto = out.File
	file_common_pagination_proto_goTypes = nil
	file_common_pagination_proto_depIdxs = nil
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\order\order.pb.go
====================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: order/order.proto

package order

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	common "github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateOrderRequestProductItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Quantity      int64                  `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateOrderRequestProductItem) Reset() {
	*x = CreateOrderRequestProductItem{}
	mi := &file_order_order_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateOrderRequestProductItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateOrderRequestProductItem) ProtoMessage() {}

func (x *CreateOrderRequestProductItem) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateOrderRequestProductItem.ProtoReflect.Descriptor instead.
func (*CreateOrderRequestProductItem) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{0}
}

func (x *CreateOrderRequestProductItem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CreateOrderRequestProductItem) GetQuantity() int64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

type CreateOrderRequest struct {
	state         protoimpl.MessageState           `protogen:"open.v1"`
	FullName      string                           `protobuf:"bytes,1,opt,name=full_name,json=fullName,proto3" json:"full_name,omitempty"`
	Address       string                           `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	PhoneNumber   string                           `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Notes         string                           `protobuf:"bytes,4,opt,name=notes,proto3" json:"notes,omitempty"`
	Products      []*CreateOrderRequestProductItem `protobuf:"bytes,5,rep,name=products,proto3" json:"products,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateOrderRequest) Reset() {
	*x = CreateOrderRequest{}
	mi := &file_order_order_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateOrderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateOrderRequest) ProtoMessage() {}

func (x *CreateOrderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateOrderRequest.ProtoReflect.Descriptor instead.
func (*CreateOrderRequest) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{1}
}

func (x *CreateOrderRequest) GetFullName() string {
	if x != nil {
		return x.FullName
	}
	return ""
}

func (x *CreateOrderRequest) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *CreateOrderRequest) GetPhoneNumber() string {
	if x != nil {
		return x.PhoneNumber
	}
	return ""
}

func (x *CreateOrderRequest) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

func (x *CreateOrderRequest) GetProducts() []*CreateOrderRequestProductItem {
	if x != nil {
		return x.Products
	}
	return nil
}

type CreateOrderResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Id            string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateOrderResponse) Reset() {
	*x = CreateOrderResponse{}
	mi := &file_order_order_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateOrderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateOrderResponse) ProtoMessage() {}

func (x *CreateOrderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateOrderResponse.ProtoReflect.Descriptor instead.
func (*CreateOrderResponse) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{2}
}

func (x *CreateOrderResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *CreateOrderResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type ListOrderAdminRequest struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Pagination    *common.PaginationRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListOrderAdminRequest) Reset() {
	*x = ListOrderAdminRequest{}
	mi := &file_order_order_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOrderAdminRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrderAdminRequest) ProtoMessage() {}

func (x *ListOrderAdminRequest) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrderAdminRequest.ProtoReflect.Descriptor instead.
func (*ListOrderAdminRequest) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{3}
}

func (x *ListOrderAdminRequest) GetPagination() *common.PaginationRequest {
	if x != nil {
		return x.Pagination
	}
	return nil
}

type ListOrderAdminResponseItemProduct struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Price         float64                `protobuf:"fixed64,3,opt,name=price,proto3" json:"price,omitempty"`
	Quantity      int64                  `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListOrderAdminResponseItemProduct) Reset() {
	*x = ListOrderAdminResponseItemProduct{}
	mi := &file_order_order_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOrderAdminResponseItemProduct) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrderAdminResponseItemProduct) ProtoMessage() {}

func (x *ListOrderAdminResponseItemProduct) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrderAdminResponseItemProduct.ProtoReflect.Descriptor instead.
func (*ListOrderAdminResponseItemProduct) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{4}
}

func (x *ListOrderAdminResponseItemProduct) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ListOrderAdminResponseItemProduct) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListOrderAdminResponseItemProduct) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *ListOrderAdminResponseItemProduct) GetQuantity() int64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

type ListOrderAdminResponseItem struct {
	state         protoimpl.MessageState               `protogen:"open.v1"`
	Id            string                               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Number        string                               `protobuf:"bytes,2,opt,name=number,proto3" json:"number,omitempty"`
	Customer      string                               `protobuf:"bytes,3,opt,name=customer,proto3" json:"customer,omitempty"`
	StatusCode    string                               `protobuf:"bytes,4,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	Total         float64                              `protobuf:"fixed64,5,opt,name=total,proto3" json:"total,omitempty"`
	CreatedAt     *timestamppb.Timestamp               `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Products      []*ListOrderAdminResponseItemProduct `protobuf:"bytes,7,rep,name=products,proto3" json:"products,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListOrderAdminResponseItem) Reset() {
	*x = ListOrderAdminResponseItem{}
	mi := &file_order_order_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOrderAdminResponseItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrderAdminResponseItem) ProtoMessage() {}

func (x *ListOrderAdminResponseItem) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrderAdminResponseItem.ProtoReflect.Descriptor instead.
func (*ListOrderAdminResponseItem) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{5}
}

func (x *ListOrderAdminResponseItem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ListOrderAdminResponseItem) GetNumber() string {
	if x != nil {
		return x.Number
	}
	return ""
}

func (x *ListOrderAdminResponseItem) GetCustomer() string {
	if x != nil {
		return x.Customer
	}
	return ""
}

func (x *ListOrderAdminResponseItem) GetStatusCode() string {
	if x != nil {
		return x.StatusCode
	}
	return ""
}

func (x *ListOrderAdminResponseItem) GetTotal() float64 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *ListOrderAdminResponseItem) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *ListOrderAdminResponseItem) GetProducts() []*ListOrderAdminResponseItemProduct {
	if x != nil {
		return x.Products
	}
	return nil
}

type ListOrderAdminResponse struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	Base          *common.BaseResponse          `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Pagination    *common.PaginationResponse    `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	Items         []*ListOrderAdminResponseItem `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListOrderAdminResponse) Reset() {
	*x = ListOrderAdminResponse{}
	mi := &file_order_order_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOrderAdminResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrderAdminResponse) ProtoMessage() {}

func (x *ListOrderAdminResponse) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrderAdminResponse.ProtoReflect.Descriptor instead.
func (*ListOrderAdminResponse) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{6}
}

func (x *ListOrderAdminResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *ListOrderAdminResponse) GetPagination() *common.PaginationResponse {
	if x != nil {
		return x.Pagination
	}
	return nil
}

func (x *ListOrderAdminResponse) GetItems() []*ListOrderAdminResponseItem {
	if x != nil {
		return x.Items
	}
	return nil
}

type ListOrderRequest struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Pagination    *common.PaginationRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListOrderRequest) Reset() {
	*x = ListOrderRequest{}
	mi := &file_order_order_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOrderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrderRequest) ProtoMessage() {}

func (x *ListOrderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrderRequest.ProtoReflect.Descriptor instead.
func (*ListOrderRequest) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{7}
}

func (x *ListOrderRequest) GetPagination() *common.PaginationRequest {
	if x != nil {
		return x.Pagination
	}
	return nil
}

type ListOrderResponseItemProduct struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Price         float64                `protobuf:"fixed64,3,opt,name=price,proto3" json:"price,omitempty"`
	Quantity      int64                  `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListOrderResponseItemProduct) Reset() {
	*x = ListOrderResponseItemProduct{}
	mi := &file_order_order_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOrderResponseItemProduct) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrderResponseItemProduct) ProtoMessage() {}

func (x *ListOrderResponseItemProduct) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrderResponseItemProduct.ProtoReflect.Descriptor instead.
func (*ListOrderResponseItemProduct) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{8}
}

func (x *ListOrderResponseItemProduct) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ListOrderResponseItemProduct) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListOrderResponseItemProduct) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *ListOrderResponseItemProduct) GetQuantity() int64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

type ListOrderResponseItem struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	Id              string                          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Number          string                          `protobuf:"bytes,2,opt,name=number,proto3" json:"number,omitempty"`
	Customer        string                          `protobuf:"bytes,3,opt,name=customer,proto3" json:"customer,omitempty"`
	StatusCode      string                          `protobuf:"bytes,4,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	Total           float64                         `protobuf:"fixed64,5,opt,name=total,proto3" json:"total,omitempty"`
	CreatedAt       *timestamppb.Timestamp          `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Products        []*ListOrderResponseItemProduct `protobuf:"bytes,7,rep,name=products,proto3" json:"products,omitempty"`
	XenditNvoiceUrl string                          `protobuf:"bytes,8,opt,name=xendit_nvoice_url,json=xenditNvoiceUrl,proto3" json:"xendit_nvoice_url,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ListOrderResponseItem) Reset() {
	*x = ListOrderResponseItem{}
	mi := &file_order_order_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOrderResponseItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrderResponseItem) ProtoMessage() {}

func (x *ListOrderResponseItem) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrderResponseItem.ProtoReflect.Descriptor instead.
func (*ListOrderResponseItem) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{9}
}

func (x *ListOrderResponseItem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ListOrderResponseItem) GetNumber() string {
	if x != nil {
		return x.Number
	}
	return ""
}

func (x *ListOrderResponseItem) GetCustomer() string {
	if x != nil {
		return x.Customer
	}
	return ""
}

func (x *ListOrderResponseItem) GetStatusCode() string {
	if x != nil {
		return x.StatusCode
	}
	return ""
}

func (x *ListOrderResponseItem) GetTotal() float64 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *ListOrderResponseItem) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *ListOrderResponseItem) GetProducts() []*ListOrderResponseItemProduct {
	if x != nil {
		return x.Products
	}
	return nil
}

func (x *ListOrderResponseItem) GetXenditNvoiceUrl() string {
	if x != nil {
		return x.XenditNvoiceUrl
	}
	return ""
}

type ListOrderResponse struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	Base          *common.BaseResponse       `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Pagination    *common.PaginationResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	Items         []*ListOrderResponseItem   `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListOrderResponse) Reset() {
	*x = ListOrderResponse{}
	mi := &file_order_order_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListOrderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOrderResponse) ProtoMessage() {}

func (x *ListOrderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOrderResponse.ProtoReflect.Descriptor instead.
func (*ListOrderResponse) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{10}
}

func (x *ListOrderResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *ListOrderResponse) GetPagination() *common.PaginationResponse {
	if x != nil {
		return x.Pagination
	}
	return nil
}

func (x *ListOrderResponse) GetItems() []*ListOrderResponseItem {
	if x != nil {
		return x.Items
	}
	return nil
}

type DetailOrderRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DetailOrderRequest) Reset() {
	*x = DetailOrderRequest{}
	mi := &file_order_order_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DetailOrderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetailOrderRequest) ProtoMessage() {}

func (x *DetailOrderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetailOrderRequest.ProtoReflect.Descriptor instead.
func (*DetailOrderRequest) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{11}
}

func (x *DetailOrderRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type DetailOrderResponseItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Price         float64                `protobuf:"fixed64,3,opt,name=price,proto3" json:"price,omitempty"`
	Quantity      int64                  `protobuf:"varint,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DetailOrderResponseItem) Reset() {
	*x = DetailOrderResponseItem{}
	mi := &file_order_order_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DetailOrderResponseItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetailOrderResponseItem) ProtoMessage() {}

func (x *DetailOrderResponseItem) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetailOrderResponseItem.ProtoReflect.Descriptor instead.
func (*DetailOrderResponseItem) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{12}
}

func (x *DetailOrderResponseItem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DetailOrderResponseItem) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DetailOrderResponseItem) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *DetailOrderResponseItem) GetQuantity() int64 {
	if x != nil {
		return x.Quantity
	}
	return 0
}

type DetailOrderResponse struct {
	state            protoimpl.MessageState     `protogen:"open.v1"`
	Base             *common.BaseResponse       `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Id               string                     `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Number           string                     `protobuf:"bytes,3,opt,name=number,proto3" json:"number,omitempty"`
	UserFullName     string                     `protobuf:"bytes,4,opt,name=user_full_name,json=userFullName,proto3" json:"user_full_name,omitempty"`
	Address          string                     `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
	PhoneNumber      string                     `protobuf:"bytes,6,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Notes            string                     `protobuf:"bytes,7,opt,name=notes,proto3" json:"notes,omitempty"`
	OrderStatusCode  string                     `protobuf:"bytes,8,opt,name=order_status_code,json=orderStatusCode,proto3" json:"order_status_code,omitempty"`
	CreatedAt        *timestamppb.Timestamp     `protobuf:"bytes,9,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	XenditInvoiceUrl string                     `protobuf:"bytes,10,opt,name=xendit_invoice_url,json=xenditInvoiceUrl,proto3" json:"xendit_invoice_url,omitempty"`
	Items            []*DetailOrderResponseItem `protobuf:"bytes,11,rep,name=items,proto3" json:"items,omitempty"`
	Total            float64                    `protobuf:"fixed64,12,opt,name=total,proto3" json:"total,omitempty"`
	ExpiredAt        *timestamppb.Timestamp     `protobuf:"bytes,13,opt,name=expired_at,json=expiredAt,proto3" json:"expired_at,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DetailOrderResponse) Reset() {
	*x = DetailOrderResponse{}
	mi := &file_order_order_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DetailOrderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetailOrderResponse) ProtoMessage() {}

func (x *DetailOrderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetailOrderResponse.ProtoReflect.Descriptor instead.
func (*DetailOrderResponse) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{13}
}

func (x *DetailOrderResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *DetailOrderResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DetailOrderResponse) GetNumber() string {
	if x != nil {
		return x.Number
	}
	return ""
}

func (x *DetailOrderResponse) GetUserFullName() string {
	if x != nil {
		return x.UserFullName
	}
	return ""
}

func (x *DetailOrderResponse) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *DetailOrderResponse) GetPhoneNumber() string {
	if x != nil {
		return x.PhoneNumber
	}
	return ""
}

func (x *DetailOrderResponse) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

func (x *DetailOrderResponse) GetOrderStatusCode() string {
	if x != nil {
		return x.OrderStatusCode
	}
	return ""
}

func (x *DetailOrderResponse) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *DetailOrderResponse) GetXenditInvoiceUrl() string {
	if x != nil {
		return x.XenditInvoiceUrl
	}
	return ""
}

func (x *DetailOrderResponse) GetItems() []*DetailOrderResponseItem {
	if x != nil {
		return x.Items
	}
	return nil
}

func (x *DetailOrderResponse) GetTotal() float64 {
	if x != nil {
		return x.Total
	}
	return 0
}

func (x *DetailOrderResponse) GetExpiredAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiredAt
	}
	return nil
}

type UpdateOrderStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	OrderId       string                 `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	NewStatusCode string                 `protobuf:"bytes,2,opt,name=new_status_code,json=newStatusCode,proto3" json:"new_status_code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOrderStatusRequest) Reset() {
	*x = UpdateOrderStatusRequest{}
	mi := &file_order_order_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOrderStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOrderStatusRequest) ProtoMessage() {}

func (x *UpdateOrderStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOrderStatusRequest.ProtoReflect.Descriptor instead.
func (*UpdateOrderStatusRequest) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{14}
}

func (x *UpdateOrderStatusRequest) GetOrderId() string {
	if x != nil {
		return x.OrderId
	}
	return ""
}

func (x *UpdateOrderStatusRequest) GetNewStatusCode() string {
	if x != nil {
		return x.NewStatusCode
	}
	return ""
}

type UpdateOrderStatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateOrderStatusResponse) Reset() {
	*x = UpdateOrderStatusResponse{}
	mi := &file_order_order_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateOrderStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateOrderStatusResponse) ProtoMessage() {}

func (x *UpdateOrderStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_order_order_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateOrderStatusResponse.ProtoReflect.Descriptor instead.
func (*UpdateOrderStatusResponse) Descriptor() ([]byte, []int) {
	return file_order_order_proto_rawDescGZIP(), []int{15}
}

func (x *UpdateOrderStatusResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

var File_order_order_proto protoreflect.FileDescriptor

const file_order_order_proto_rawDesc = "" +
	"\n" +
	"\x11order/order.proto\x12\x05order\x1a\x1bbuf/validate/validate.proto\x1a\x1acommon/base_response.proto\x1a\x17common/pagination.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"K\n" +
	"\x1dCreateOrderRequestProductItem\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1a\n" +
	"\bquantity\x18\x02 \x01(\x03R\bquantity\"\xf4\x01\n" +
	"\x12CreateOrderRequest\x12'\n" +
	"\tfull_name\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\bfullName\x12$\n" +
	"\aaddress\x18\x02 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\aaddress\x12-\n" +
	"\fphone_number\x18\x03 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\vphoneNumber\x12\x1e\n" +
	"\x05notes\x18\x04 \x01(\tB\b\xbaH\x05r\x03\x18\xff\x01R\x05notes\x12@\n" +
	"\bproducts\x18\x05 \x03(\v2$.order.CreateOrderRequestProductItemR\bproducts\"O\n" +
	"\x13CreateOrderResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\"R\n" +
	"\x15ListOrderAdminRequest\x129\n" +
	"\n" +
	"pagination\x18\x01 \x01(\v2\x19.common.PaginationRequestR\n" +
	"pagination\"y\n" +
	"!ListOrderAdminResponseItemProduct\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05price\x18\x03 \x01(\x01R\x05price\x12\x1a\n" +
	"\bquantity\x18\x04 \x01(\x03R\bquantity\"\x98\x02\n" +
	"\x1aListOrderAdminResponseItem\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06number\x18\x02 \x01(\tR\x06number\x12\x1a\n" +
	"\bcustomer\x18\x03 \x01(\tR\bcustomer\x12\x1f\n" +
	"\vstatus_code\x18\x04 \x01(\tR\n" +
	"statusCode\x12\x14\n" +
	"\x05total\x18\x05 \x01(\x01R\x05total\x129\n" +
	"\n" +
	"created_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12D\n" +
	"\bproducts\x18\a \x03(\v2(.order.ListOrderAdminResponseItemProductR\bproducts\"\xb7\x01\n" +
	"\x16ListOrderAdminResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12:\n" +
	"\n" +
	"pagination\x18\x02 \x01(\v2\x1a.common.PaginationResponseR\n" +
	"pagination\x127\n" +
	"\x05items\x18\x03 \x03(\v2!.order.ListOrderAdminResponseItemR\x05items\"M\n" +
	"\x10ListOrderRequest\x129\n" +
	"\n" +
	"pagination\x18\x01 \x01(\v2\x19.common.PaginationRequestR\n" +
	"pagination\"t\n" +
	"\x1cListOrderResponseItemProduct\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05price\x18\x03 \x01(\x01R\x05price\x12\x1a\n" +
	"\bquantity\x18\x04 \x01(\x03R\bquantity\"\xba\x02\n" +
	"\x15ListOrderResponseItem\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x16\n" +
	"\x06number\x18\x02 \x01(\tR\x06number\x12\x1a\n" +
	"\bcustomer\x18\x03 \x01(\tR\bcustomer\x12\x1f\n" +
	"\vstatus_code\x18\x04 \x01(\tR\n" +
	"statusCode\x12\x14\n" +
	"\x05total\x18\x05 \x01(\x01R\x05total\x129\n" +
	"\n" +
	"created_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12?\n" +
	"\bproducts\x18\a \x03(\v2#.order.ListOrderResponseItemProductR\bproducts\x12*\n" +
	"\x11xendit_nvoice_url\x18\b \x01(\tR\x0fxenditNvoiceUrl\"\xad\x01\n" +
	"\x11ListOrderResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12:\n" +
	"\n" +
	"pagination\x18\x02 \x01(\v2\x1a.common.PaginationResponseR\n" +
	"pagination\x122\n" +
	"\x05items\x18\x03 \x03(\v2\x1c.order.ListOrderResponseItemR\x05items\"0\n" +
	"\x12DetailOrderRequest\x12\x1a\n" +
	"\x02id\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x02id\"o\n" +
	"\x17DetailOrderResponseItem\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05price\x18\x03 \x01(\x01R\x05price\x12\x1a\n" +
	"\bquantity\x18\x04 \x01(\x03R\bquantity\"\xfc\x03\n" +
	"\x13DetailOrderResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\x12\x16\n" +
	"\x06number\x18\x03 \x01(\tR\x06number\x12$\n" +
	"\x0euser_full_name\x18\x04 \x01(\tR\fuserFullName\x12\x18\n" +
	"\aaddress\x18\x05 \x01(\tR\aaddress\x12!\n" +
	"\fphone_number\x18\x06 \x01(\tR\vphoneNumber\x12\x14\n" +
	"\x05notes\x18\a \x01(\tR\x05notes\x12*\n" +
	"\x11order_status_code\x18\b \x01(\tR\x0forderStatusCode\x129\n" +
	"\n" +
	"created_at\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12,\n" +
	"\x12xendit_invoice_url\x18\n" +
	" \x01(\tR\x10xenditInvoiceUrl\x124\n" +
	"\x05items\x18\v \x03(\v2\x1e.order.DetailOrderResponseItemR\x05items\x12\x14\n" +
	"\x05total\x18\f \x01(\x01R\x05total\x129\n" +
	"\n" +
	"expired_at\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\texpiredAt\"u\n" +
	"\x18UpdateOrderStatusRequest\x12%\n" +
	"\border_id\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\aorderId\x122\n" +
	"\x0fnew_status_code\x18\x02 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\rnewStatusCode\"E\n" +
	"\x19UpdateOrderStatusResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base2\x81\x03\n" +
	"\fOrderService\x12D\n" +
	"\vCreateOrder\x12\x19.order.CreateOrderRequest\x1a\x1a.order.CreateOrderResponse\x12M\n" +
	"\x0eListOrderAdmin\x12\x1c.order.ListOrderAdminRequest\x1a\x1d.order.ListOrderAdminResponse\x12>\n" +
	"\tListOrder\x12\x17.order.ListOrderRequest\x1a\x18.order.ListOrderResponse\x12D\n" +
	"\vDetailOrder\x12\x19.order.DetailOrderRequest\x1a\x1a.order.DetailOrderResponse\x12V\n" +
	"\x11UpdateOrderStatus\x12\x1f.order.UpdateOrderStatusRequest\x1a .order.UpdateOrderStatusResponseB4Z2github.com/luzmareto/go-grpc-ecommerce-be/pb/orderb\x06proto3"

var (
	file_order_order_proto_rawDescOnce sync.Once
	file_order_order_proto_rawDescData []byte
)

func file_order_order_proto_rawDescGZIP() []byte {
	file_order_order_proto_rawDescOnce.Do(func() {
		file_order_order_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_order_order_proto_rawDesc), len(file_order_order_proto_rawDesc)))
	})
	return file_order_order_proto_rawDescData
}

var file_order_order_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_order_order_proto_goTypes = []any{
	(*CreateOrderRequestProductItem)(nil),     // 0: order.CreateOrderRequestProductItem
	(*CreateOrderRequest)(nil),                // 1: order.CreateOrderRequest
	(*CreateOrderResponse)(nil),               // 2: order.CreateOrderResponse
	(*ListOrderAdminRequest)(nil),             // 3: order.ListOrderAdminRequest
	(*ListOrderAdminResponseItemProduct)(nil), // 4: order.ListOrderAdminResponseItemProduct
	(*ListOrderAdminResponseItem)(nil),        // 5: order.ListOrderAdminResponseItem
	(*ListOrderAdminResponse)(nil),            // 6: order.ListOrderAdminResponse
	(*ListOrderRequest)(nil),                  // 7: order.ListOrderRequest
	(*ListOrderResponseItemProduct)(nil),      // 8: order.ListOrderResponseItemProduct
	(*ListOrderResponseItem)(nil),             // 9: order.ListOrderResponseItem
	(*ListOrderResponse)(nil),                 // 10: order.ListOrderResponse
	(*DetailOrderRequest)(nil),                // 11: order.DetailOrderRequest
	(*DetailOrderResponseItem)(nil),           // 12: order.DetailOrderResponseItem
	(*DetailOrderResponse)(nil),               // 13: order.DetailOrderResponse
	(*UpdateOrderStatusRequest)(nil),          // 14: order.UpdateOrderStatusRequest
	(*UpdateOrderStatusResponse)(nil),         // 15: order.UpdateOrderStatusResponse
	(*common.BaseResponse)(nil),               // 16: common.BaseResponse
	(*common.PaginationRequest)(nil),          // 17: common.PaginationRequest
	(*timestamppb.Timestamp)(nil),             // 18: google.protobuf.Timestamp
	(*common.PaginationResponse)(nil),         // 19: common.PaginationResponse
}
var file_order_order_proto_depIdxs = []int32{
	0,  // 0: order.CreateOrderRequest.products:type_name -> order.CreateOrderRequestProductItem
	16, // 1: order.CreateOrderResponse.base:type_name -> common.BaseResponse
	17, // 2: order.ListOrderAdminRequest.pagination:type_name -> common.PaginationRequest
	18, // 3: order.ListOrderAdminResponseItem.created_at:type_name -> google.protobuf.Timestamp
	4,  // 4: order.ListOrderAdminResponseItem.products:type_name -> order.ListOrderAdminResponseItemProduct
	16, // 5: order.ListOrderAdminResponse.base:type_name -> common.BaseResponse
	19, // 6: order.ListOrderAdminResponse.pagination:type_name -> common.PaginationResponse
	5,  // 7: order.ListOrderAdminResponse.items:type_name -> order.ListOrderAdminResponseItem
	17, // 8: order.ListOrderRequest.pagination:type_name -> common.PaginationRequest
	18, // 9: order.ListOrderResponseItem.created_at:type_name -> google.protobuf.Timestamp
	8,  // 10: order.ListOrderResponseItem.products:type_name -> order.ListOrderResponseItemProduct
	16, // 11: order.ListOrderResponse.base:type_name -> common.BaseResponse
	19, // 12: order.ListOrderResponse.pagination:type_name -> common.PaginationResponse
	9,  // 13: order.ListOrderResponse.items:type_name -> order.ListOrderResponseItem
	16, // 14: order.DetailOrderResponse.base:type_name -> common.BaseResponse
	18, // 15: order.DetailOrderResponse.created_at:type_name -> google.protobuf.Timestamp
	12, // 16: order.DetailOrderResponse.items:type_name -> order.DetailOrderResponseItem
	18, // 17: order.DetailOrderResponse.expired_at:type_name -> google.protobuf.Timestamp
	16, // 18: order.UpdateOrderStatusResponse.base:type_name -> common.BaseResponse
	1,  // 19: order.OrderService.CreateOrder:input_type -> order.CreateOrderRequest
	3,  // 20: order.OrderService.ListOrderAdmin:input_type -> order.ListOrderAdminRequest
	7,  // 21: order.OrderService.ListOrder:input_type -> order.ListOrderRequest
	11, // 22: order.OrderService.DetailOrder:input_type -> order.DetailOrderRequest
	14, // 23: order.OrderService.UpdateOrderStatus:input_type -> order.UpdateOrderStatusRequest
	2,  // 24: order.OrderService.CreateOrder:output_type -> order.CreateOrderResponse
	6,  // 25: order.OrderService.ListOrderAdmin:output_type -> order.ListOrderAdminResponse
	10, // 26: order.OrderService.ListOrder:output_type -> order.ListOrderResponse
	13, // 27: order.OrderService.DetailOrder:output_type -> order.DetailOrderResponse
	15, // 28: order.OrderService.UpdateOrderStatus:output_type -> order.UpdateOrderStatusResponse
	24, // [24:29] is the sub-list for method output_type
	19, // [19:24] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_order_order_proto_init() }
func file_order_order_proto_init() {
	if File_order_order_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_order_order_proto_rawDesc), len(file_order_order_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_order_order_proto_goTypes,
		DependencyIndexes: file_order_order_proto_depIdxs,
		MessageInfos:      file_order_order_proto_msgTypes,
	}.Build()
	File_order_order_proto = out.File
	file_order_order_proto_goTypes = nil
	file_order_order_proto_depIdxs = nil
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\order\order_grpc.pb.go
====================
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: order/order.proto

package order

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	OrderService_CreateOrder_FullMethodName       = "/order.OrderService/CreateOrder"
	OrderService_ListOrderAdmin_FullMethodName    = "/order.OrderService/ListOrderAdmin"
	OrderService_ListOrder_FullMethodName         = "/order.OrderService/ListOrder"
	OrderService_DetailOrder_FullMethodName       = "/order.OrderService/DetailOrder"
	OrderService_UpdateOrderStatus_FullMethodName = "/order.OrderService/UpdateOrderStatus"
)

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrderServiceClient interface {
	CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error)
	ListOrderAdmin(ctx context.Context, in *ListOrderAdminRequest, opts ...grpc.CallOption) (*ListOrderAdminResponse, error)
	ListOrder(ctx context.Context, in *ListOrderRequest, opts ...grpc.CallOption) (*ListOrderResponse, error)
	DetailOrder(ctx context.Context, in *DetailOrderRequest, opts ...grpc.CallOption) (*DetailOrderResponse, error)
	UpdateOrderStatus(ctx context.Context, in *UpdateOrderStatusRequest, opts ...grpc.CallOption) (*UpdateOrderStatusResponse, error)
}

type orderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOrderServiceClient(cc grpc.ClientConnInterface) OrderServiceClient {
	return &orderServiceClient{cc}
}

func (c *orderServiceClient) CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*CreateOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOrderResponse)
	err := c.cc.Invoke(ctx, OrderService_CreateOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) ListOrderAdmin(ctx context.Context, in *ListOrderAdminRequest, opts ...grpc.CallOption) (*ListOrderAdminResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOrderAdminResponse)
	err := c.cc.Invoke(ctx, OrderService_ListOrderAdmin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) ListOrder(ctx context.Context, in *ListOrderRequest, opts ...grpc.CallOption) (*ListOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOrderResponse)
	err := c.cc.Invoke(ctx, OrderService_ListOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) DetailOrder(ctx context.Context, in *DetailOrderRequest, opts ...grpc.CallOption) (*DetailOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DetailOrderResponse)
	err := c.cc.Invoke(ctx, OrderService_DetailOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderServiceClient) UpdateOrderStatus(ctx context.Context, in *UpdateOrderStatusRequest, opts ...grpc.CallOption) (*UpdateOrderStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateOrderStatusResponse)
	err := c.cc.Invoke(ctx, OrderService_UpdateOrderStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServiceServer is the server API for OrderService service.
// All implementations must embed UnimplementedOrderServiceServer
// for forward compatibility.
type OrderServiceServer interface {
	CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error)
	ListOrderAdmin(context.Context, *ListOrderAdminRequest) (*ListOrderAdminResponse, error)
	ListOrder(context.Context, *ListOrderRequest) (*ListOrderResponse, error)
	DetailOrder(context.Context, *DetailOrderRequest) (*DetailOrderResponse, error)
	UpdateOrderStatus(context.Context, *UpdateOrderStatusRequest) (*UpdateOrderStatusResponse, error)
	mustEmbedUnimplementedOrderServiceServer()
}

// UnimplementedOrderServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrderServiceServer struct{}

func (UnimplementedOrderServiceServer) CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrder not implemented")
}
func (UnimplementedOrderServiceServer) ListOrderAdmin(context.Context, *ListOrderAdminRequest) (*ListOrderAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrderAdmin not implemented")
}
func (UnimplementedOrderServiceServer) ListOrder(context.Context, *ListOrderRequest) (*ListOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrder not implemented")
}
func (UnimplementedOrderServiceServer) DetailOrder(context.Context, *DetailOrderRequest) (*DetailOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetailOrder not implemented")
}
func (UnimplementedOrderServiceServer) UpdateOrderStatus(context.Context, *UpdateOrderStatusRequest) (*UpdateOrderStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOrderStatus not implemented")
}
func (UnimplementedOrderServiceServer) mustEmbedUnimplementedOrderServiceServer() {}
func (UnimplementedOrderServiceServer) testEmbeddedByValue()                      {}

// UnsafeOrderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrderServiceServer will
// result in compilation errors.
type UnsafeOrderServiceServer interface {
	mustEmbedUnimplementedOrderServiceServer()
}

func RegisterOrderServiceServer(s grpc.ServiceRegistrar, srv OrderServiceServer) {
	// If the following call pancis, it indicates UnimplementedOrderServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OrderService_ServiceDesc, srv)
}

func _OrderService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_CreateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).CreateOrder(ctx, req.(*CreateOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_ListOrderAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrderAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).ListOrderAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_ListOrderAdmin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).ListOrderAdmin(ctx, req.(*ListOrderAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_ListOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).ListOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_ListOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).ListOrder(ctx, req.(*ListOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_DetailOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetailOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).DetailOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_DetailOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).DetailOrder(ctx, req.(*DetailOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrderService_UpdateOrderStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOrderStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServiceServer).UpdateOrderStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrderService_UpdateOrderStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServiceServer).UpdateOrderStatus(ctx, req.(*UpdateOrderStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OrderService_ServiceDesc is the grpc.ServiceDesc for OrderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "order.OrderService",
	HandlerType: (*OrderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrder",
			Handler:    _OrderService_CreateOrder_Handler,
		},
		{
			MethodName: "ListOrderAdmin",
			Handler:    _OrderService_ListOrderAdmin_Handler,
		},
		{
			MethodName: "ListOrder",
			Handler:    _OrderService_ListOrder_Handler,
		},
		{
			MethodName: "DetailOrder",
			Handler:    _OrderService_DetailOrder_Handler,
		},
		{
			MethodName: "UpdateOrderStatus",
			Handler:    _OrderService_UpdateOrderStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "order/order.proto",
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\product\product.pb.go
====================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v5.29.3
// source: product/product.proto

package product

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	common "github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateProductRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Price         float64                `protobuf:"fixed64,3,opt,name=price,proto3" json:"price,omitempty"`
	ImageFileName string                 `protobuf:"bytes,4,opt,name=image_file_name,json=imageFileName,proto3" json:"image_file_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateProductRequest) Reset() {
	*x = CreateProductRequest{}
	mi := &file_product_product_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateProductRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateProductRequest) ProtoMessage() {}

func (x *CreateProductRequest) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateProductRequest.ProtoReflect.Descriptor instead.
func (*CreateProductRequest) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{0}
}

func (x *CreateProductRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateProductRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *CreateProductRequest) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *CreateProductRequest) GetImageFileName() string {
	if x != nil {
		return x.ImageFileName
	}
	return ""
}

type CreateProductResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Id            string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateProductResponse) Reset() {
	*x = CreateProductResponse{}
	mi := &file_product_product_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateProductResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateProductResponse) ProtoMessage() {}

func (x *CreateProductResponse) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateProductResponse.ProtoReflect.Descriptor instead.
func (*CreateProductResponse) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{1}
}

func (x *CreateProductResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *CreateProductResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type DetailProductRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DetailProductRequest) Reset() {
	*x = DetailProductRequest{}
	mi := &file_product_product_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DetailProductRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetailProductRequest) ProtoMessage() {}

func (x *DetailProductRequest) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetailProductRequest.ProtoReflect.Descriptor instead.
func (*DetailProductRequest) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{2}
}

func (x *DetailProductRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type DetailProductResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Id            string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Price         float64                `protobuf:"fixed64,5,opt,name=price,proto3" json:"price,omitempty"`
	ImageUrl      string                 `protobuf:"bytes,6,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DetailProductResponse) Reset() {
	*x = DetailProductResponse{}
	mi := &file_product_product_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DetailProductResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DetailProductResponse) ProtoMessage() {}

func (x *DetailProductResponse) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DetailProductResponse.ProtoReflect.Descriptor instead.
func (*DetailProductResponse) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{3}
}

func (x *DetailProductResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *DetailProductResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DetailProductResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DetailProductResponse) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *DetailProductResponse) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *DetailProductResponse) GetImageUrl() string {
	if x != nil {
		return x.ImageUrl
	}
	return ""
}

type EditProductRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Price         float64                `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
	ImageFileName string                 `protobuf:"bytes,5,opt,name=image_file_name,json=imageFileName,proto3" json:"image_file_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EditProductRequest) Reset() {
	*x = EditProductRequest{}
	mi := &file_product_product_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EditProductRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EditProductRequest) ProtoMessage() {}

func (x *EditProductRequest) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EditProductRequest.ProtoReflect.Descriptor instead.
func (*EditProductRequest) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{4}
}

func (x *EditProductRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *EditProductRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EditProductRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *EditProductRequest) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *EditProductRequest) GetImageFileName() string {
	if x != nil {
		return x.ImageFileName
	}
	return ""
}

type EditProductResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Id            string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EditProductResponse) Reset() {
	*x = EditProductResponse{}
	mi := &file_product_product_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EditProductResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EditProductResponse) ProtoMessage() {}

func (x *EditProductResponse) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EditProductResponse.ProtoReflect.Descriptor instead.
func (*EditProductResponse) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{5}
}

func (x *EditProductResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *EditProductResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type DeleteProductRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteProductRequest) Reset() {
	*x = DeleteProductRequest{}
	mi := &file_product_product_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteProductRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteProductRequest) ProtoMessage() {}

func (x *DeleteProductRequest) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteProductRequest.ProtoReflect.Descriptor instead.
func (*DeleteProductRequest) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{6}
}

func (x *DeleteProductRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type DeleteProductResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteProductResponse) Reset() {
	*x = DeleteProductResponse{}
	mi := &file_product_product_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteProductResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteProductResponse) ProtoMessage() {}

func (x *DeleteProductResponse) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteProductResponse.ProtoReflect.Descriptor instead.
func (*DeleteProductResponse) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{7}
}

func (x *DeleteProductResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

type ListProductRequest struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Pagination    *common.PaginationRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProductRequest) Reset() {
	*x = ListProductRequest{}
	mi := &file_product_product_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProductRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProductRequest) ProtoMessage() {}

func (x *ListProductRequest) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProductRequest.ProtoReflect.Descriptor instead.
func (*ListProductRequest) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{8}
}

func (x *ListProductRequest) GetPagination() *common.PaginationRequest {
	if x != nil {
		return x.Pagination
	}
	return nil
}

type ListProductResponseItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Price         float64                `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
	ImageUrl      string                 `protobuf:"bytes,5,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProductResponseItem) Reset() {
	*x = ListProductResponseItem{}
	mi := &file_product_product_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProductResponseItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProductResponseItem) ProtoMessage() {}

func (x *ListProductResponseItem) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProductResponseItem.ProtoReflect.Descriptor instead.
func (*ListProductResponseItem) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{9}
}

func (x *ListProductResponseItem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ListProductResponseItem) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListProductResponseItem) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ListProductResponseItem) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *ListProductResponseItem) GetImageUrl() string {
	if x != nil {
		return x.ImageUrl
	}
	return ""
}

type ListProductResponse struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	Base          *common.BaseResponse       `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Pagination    *common.PaginationResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	Data          []*ListProductResponseItem `protobuf:"bytes,3,rep,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProductResponse) Reset() {
	*x = ListProductResponse{}
	mi := &file_product_product_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProductResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProductResponse) ProtoMessage() {}

func (x *ListProductResponse) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProductResponse.ProtoReflect.Descriptor instead.
func (*ListProductResponse) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{10}
}

func (x *ListProductResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *ListProductResponse) GetPagination() *common.PaginationResponse {
	if x != nil {
		return x.Pagination
	}
	return nil
}

func (x *ListProductResponse) GetData() []*ListProductResponseItem {
	if x != nil {
		return x.Data
	}
	return nil
}

type ListProductAdminRequest struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Pagination    *common.PaginationRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProductAdminRequest) Reset() {
	*x = ListProductAdminRequest{}
	mi := &file_product_product_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProductAdminRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProductAdminRequest) ProtoMessage() {}

func (x *ListProductAdminRequest) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProductAdminRequest.ProtoReflect.Descriptor instead.
func (*ListProductAdminRequest) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{11}
}

func (x *ListProductAdminRequest) GetPagination() *common.PaginationRequest {
	if x != nil {
		return x.Pagination
	}
	return nil
}

type ListProductAdminResponseItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Price         float64                `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
	ImageUrl      string                 `protobuf:"bytes,5,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProductAdminResponseItem) Reset() {
	*x = ListProductAdminResponseItem{}
	mi := &file_product_product_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProductAdminResponseItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProductAdminResponseItem) ProtoMessage() {}

func (x *ListProductAdminResponseItem) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProductAdminResponseItem.ProtoReflect.Descriptor instead.
func (*ListProductAdminResponseItem) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{12}
}

func (x *ListProductAdminResponseItem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ListProductAdminResponseItem) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListProductAdminResponseItem) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ListProductAdminResponseItem) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *ListProductAdminResponseItem) GetImageUrl() string {
	if x != nil {
		return x.ImageUrl
	}
	return ""
}

type ListProductAdminResponse struct {
	state         protoimpl.MessageState          `protogen:"open.v1"`
	Base          *common.BaseResponse            `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Pagination    *common.PaginationResponse      `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	Data          []*ListProductAdminResponseItem `protobuf:"bytes,3,rep,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProductAdminResponse) Reset() {
	*x = ListProductAdminResponse{}
	mi := &file_product_product_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProductAdminResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProductAdminResponse) ProtoMessage() {}

func (x *ListProductAdminResponse) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProductAdminResponse.ProtoReflect.Descriptor instead.
func (*ListProductAdminResponse) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{13}
}

func (x *ListProductAdminResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *ListProductAdminResponse) GetPagination() *common.PaginationResponse {
	if x != nil {
		return x.Pagination
	}
	return nil
}

func (x *ListProductAdminResponse) GetData() []*ListProductAdminResponseItem {
	if x != nil {
		return x.Data
	}
	return nil
}

type HighlightProductsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HighlightProductsRequest) Reset() {
	*x = HighlightProductsRequest{}
	mi := &file_product_product_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HighlightProductsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HighlightProductsRequest) ProtoMessage() {}

func (x *HighlightProductsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HighlightProductsRequest.ProtoReflect.Descriptor instead.
func (*HighlightProductsRequest) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{14}
}

type HighlightProductsResponseItem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Price         float64                `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
	ImageUrl      string                 `protobuf:"bytes,5,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HighlightProductsResponseItem) Reset() {
	*x = HighlightProductsResponseItem{}
	mi := &file_product_product_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HighlightProductsResponseItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HighlightProductsResponseItem) ProtoMessage() {}

func (x *HighlightProductsResponseItem) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HighlightProductsResponseItem.ProtoReflect.Descriptor instead.
func (*HighlightProductsResponseItem) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{15}
}

func (x *HighlightProductsResponseItem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *HighlightProductsResponseItem) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *HighlightProductsResponseItem) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *HighlightProductsResponseItem) GetPrice() float64 {
	if x != nil {
		return x.Price
	}
	return 0
}

func (x *HighlightProductsResponseItem) GetImageUrl() string {
	if x != nil {
		return x.ImageUrl
	}
	return ""
}

type HighlightProductsResponse struct {
	state         protoimpl.MessageState           `protogen:"open.v1"`
	Base          *common.BaseResponse             `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Data          []*HighlightProductsResponseItem `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HighlightProductsResponse) Reset() {
	*x = HighlightProductsResponse{}
	mi := &file_product_product_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HighlightProductsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HighlightProductsResponse) ProtoMessage() {}

func (x *HighlightProductsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_product_product_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HighlightProductsResponse.ProtoReflect.Descriptor instead.
func (*HighlightProductsResponse) Descriptor() ([]byte, []int) {
	return file_product_product_proto_rawDescGZIP(), []int{16}
}

func (x *HighlightProductsResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *HighlightProductsResponse) GetData() []*HighlightProductsResponseItem {
	if x != nil {
		return x.Data
	}
	return nil
}

var File_product_product_proto protoreflect.FileDescriptor

const file_product_product_proto_rawDesc = "" +
	"\n" +
	"\x15product/product.proto\x12\aproduct\x1a\x1acommon/base_response.proto\x1a\x17common/pagination.proto\x1a\x1bbuf/validate/validate.proto\"\xbe\x01\n" +
	"\x14CreateProductRequest\x12\x1e\n" +
	"\x04name\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x04name\x12,\n" +
	"\vdescription\x18\x02 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\vdescription\x12$\n" +
	"\x05price\x18\x03 \x01(\x01B\x0e\xbaH\v\x12\t)\x00\x00\x00\x00\x00\x00\x00\x00R\x05price\x122\n" +
	"\x0fimage_file_name\x18\x04 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\rimageFileName\"Q\n" +
	"\x15CreateProductResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\"2\n" +
	"\x14DetailProductRequest\x12\x1a\n" +
	"\x02id\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x02id\"\xba\x01\n" +
	"\x15DetailProductResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12\x14\n" +
	"\x05price\x18\x05 \x01(\x01R\x05price\x12\x1b\n" +
	"\timage_url\x18\x06 \x01(\tR\bimageUrl\"\xd8\x01\n" +
	"\x12EditProductRequest\x12\x1a\n" +
	"\x02id\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x02id\x12\x1e\n" +
	"\x04name\x18\x02 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x04name\x12,\n" +
	"\vdescription\x18\x03 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\vdescription\x12$\n" +
	"\x05price\x18\x04 \x01(\x01B\x0e\xbaH\v\x12\t)\x00\x00\x00\x00\x00\x00\x00\x00R\x05price\x122\n" +
	"\x0fimage_file_name\x18\x05 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\rimageFileName\"O\n" +
	"\x13EditProductResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\"2\n" +
	"\x14DeleteProductRequest\x12\x1a\n" +
	"\x02id\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x02id\"A\n" +
	"\x15DeleteProductResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\"O\n" +
	"\x12ListProductRequest\x129\n" +
	"\n" +
	"pagination\x18\x01 \x01(\v2\x19.common.PaginationRequestR\n" +
	"pagination\"\x92\x01\n" +
	"\x17ListProductResponseItem\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x14\n" +
	"\x05price\x18\x04 \x01(\x01R\x05price\x12\x1b\n" +
	"\timage_url\x18\x05 \x01(\tR\bimageUrl\"\xb1\x01\n" +
	"\x13ListProductResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12:\n" +
	"\n" +
	"pagination\x18\x02 \x01(\v2\x1a.common.PaginationResponseR\n" +
	"pagination\x124\n" +
	"\x04data\x18\x03 \x03(\v2 .product.ListProductResponseItemR\x04data\"T\n" +
	"\x17ListProductAdminRequest\x129\n" +
	"\n" +
	"pagination\x18\x01 \x01(\v2\x19.common.PaginationRequestR\n" +
	"pagination\"\x97\x01\n" +
	"\x1cListProductAdminResponseItem\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x14\n" +
	"\x05price\x18\x04 \x01(\x01R\x05price\x12\x1b\n" +
	"\timage_url\x18\x05 \x01(\tR\bimageUrl\"\xbb\x01\n" +
	"\x18ListProductAdminResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12:\n" +
	"\n" +
	"pagination\x18\x02 \x01(\v2\x1a.common.PaginationResponseR\n" +
	"pagination\x129\n" +
	"\x04data\x18\x03 \x03(\v2%.product.ListProductAdminResponseItemR\x04data\"\x1a\n" +
	"\x18HighlightProductsRequest\"\x98\x01\n" +
	"\x1dHighlightProductsResponseItem\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x14\n" +
	"\x05price\x18\x04 \x01(\x01R\x05price\x12\x1b\n" +
	"\timage_url\x18\x05 \x01(\tR\bimageUrl\"\x81\x01\n" +
	"\x19HighlightProductsResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12:\n" +
	"\x04data\x18\x02 \x03(\v2&.product.HighlightProductsResponseItemR\x04data2\xc9\x04\n" +
	"\x0eProductService\x12N\n" +
	"\rCreateProduct\x12\x1d.product.CreateProductRequest\x1a\x1e.product.CreateProductResponse\x12N\n" +
	"\rDetailProduct\x12\x1d.product.DetailProductRequest\x1a\x1e.product.DetailProductResponse\x12H\n" +
	"\vEditProduct\x12\x1b.product.EditProductRequest\x1a\x1c.product.EditProductResponse\x12N\n" +
	"\rDeleteProduct\x12\x1d.product.DeleteProductRequest\x1a\x1e.product.DeleteProductResponse\x12H\n" +
	"\vListProduct\x12\x1b.product.ListProductRequest\x1a\x1c.product.ListProductResponse\x12W\n" +
	"\x10ListProductAdmin\x12 .product.ListProductAdminRequest\x1a!.product.ListProductAdminResponse\x12Z\n" +
	"\x11HighlightProducts\x12!.product.HighlightProductsRequest\x1a\".product.HighlightProductsResponseB6Z4github.com/luzmareto/go-grpc-ecommerce-be/pb/productb\x06proto3"

var (
	file_product_product_proto_rawDescOnce sync.Once
	file_product_product_proto_rawDescData []byte
)

func file_product_product_proto_rawDescGZIP() []byte {
	file_product_product_proto_rawDescOnce.Do(func() {
		file_product_product_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_product_product_proto_rawDesc), len(file_product_product_proto_rawDesc)))
	})
	return file_product_product_proto_rawDescData
}

var file_product_product_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_product_product_proto_goTypes = []any{
	(*CreateProductRequest)(nil),          // 0: product.CreateProductRequest
	(*CreateProductResponse)(nil),         // 1: product.CreateProductResponse
	(*DetailProductRequest)(nil),          // 2: product.DetailProductRequest
	(*DetailProductResponse)(nil),         // 3: product.DetailProductResponse
	(*EditProductRequest)(nil),            // 4: product.EditProductRequest
	(*EditProductResponse)(nil),           // 5: product.EditProductResponse
	(*DeleteProductRequest)(nil),          // 6: product.DeleteProductRequest
	(*DeleteProductResponse)(nil),         // 7: product.DeleteProductResponse
	(*ListProductRequest)(nil),            // 8: product.ListProductRequest
	(*ListProductResponseItem)(nil),       // 9: product.ListProductResponseItem
	(*ListProductResponse)(nil),           // 10: product.ListProductResponse
	(*ListProductAdminRequest)(nil),       // 11: product.ListProductAdminRequest
	(*ListProductAdminResponseItem)(nil),  // 12: product.ListProductAdminResponseItem
	(*ListProductAdminResponse)(nil),      // 13: product.ListProductAdminResponse
	(*HighlightProductsRequest)(nil),      // 14: product.HighlightProductsRequest
	(*HighlightProductsResponseItem)(nil), // 15: product.HighlightProductsResponseItem
	(*HighlightProductsResponse)(nil),     // 16: product.HighlightProductsResponse
	(*common.BaseResponse)(nil),           // 17: common.BaseResponse
	(*common.PaginationRequest)(nil),      // 18: common.PaginationRequest
	(*common.PaginationResponse)(nil),     // 19: common.PaginationResponse
}
var file_product_product_proto_depIdxs = []int32{
	17, // 0: product.CreateProductResponse.base:type_name -> common.BaseResponse
	17, // 1: product.DetailProductResponse.base:type_name -> common.BaseResponse
	17, // 2: product.EditProductResponse.base:type_name -> common.BaseResponse
	17, // 3: product.DeleteProductResponse.base:type_name -> common.BaseResponse
	18, // 4: product.ListProductRequest.pagination:type_name -> common.PaginationRequest
	17, // 5: product.ListProductResponse.base:type_name -> common.BaseResponse
	19, // 6: product.ListProductResponse.pagination:type_name -> common.PaginationResponse
	9,  // 7: product.ListProductResponse.data:type_name -> product.ListProductResponseItem
	18, // 8: product.ListProductAdminRequest.pagination:type_name -> common.PaginationRequest
	17, // 9: product.ListProductAdminResponse.base:type_name -> common.BaseResponse
	19, // 10: product.ListProductAdminResponse.pagination:type_name -> common.PaginationResponse
	12, // 11: product.ListProductAdminResponse.data:type_name -> product.ListProductAdminResponseItem
	17, // 12: product.HighlightProductsResponse.base:type_name -> common.BaseResponse
	15, // 13: product.HighlightProductsResponse.data:type_name -> product.HighlightProductsResponseItem
	0,  // 14: product.ProductService.CreateProduct:input_type -> product.CreateProductRequest
	2,  // 15: product.ProductService.DetailProduct:input_type -> product.DetailProductRequest
	4,  // 16: product.ProductService.EditProduct:input_type -> product.EditProductRequest
	6,  // 17: product.ProductService.DeleteProduct:input_type -> product.DeleteProductRequest
	8,  // 18: product.ProductService.ListProduct:input_type -> product.ListProductRequest
	11, // 19: product.ProductService.ListProductAdmin:input_type -> product.ListProductAdminRequest
	14, // 20: product.ProductService.HighlightProducts:input_type -> product.HighlightProductsRequest
	1,  // 21: product.ProductService.CreateProduct:output_type -> product.CreateProductResponse
	3,  // 22: product.ProductService.DetailProduct:output_type -> product.DetailProductResponse
	5,  // 23: product.ProductService.EditProduct:output_type -> product.EditProductResponse
	7,  // 24: product.ProductService.DeleteProduct:output_type -> product.DeleteProductResponse
	10, // 25: product.ProductService.ListProduct:output_type -> product.ListProductResponse
	13, // 26: product.ProductService.ListProductAdmin:output_type -> product.ListProductAdminResponse
	16, // 27: product.ProductService.HighlightProducts:output_type -> product.HighlightProductsResponse
	21, // [21:28] is the sub-list for method output_type
	14, // [14:21] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_product_product_proto_init() }
func file_product_product_proto_init() {
	if File_product_product_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_product_product_proto_rawDesc), len(file_product_product_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_product_product_proto_goTypes,
		DependencyIndexes: file_product_product_proto_depIdxs,
		MessageInfos:      file_product_product_proto_msgTypes,
	}.Build()
	File_product_product_proto = out.File
	file_product_product_proto_goTypes = nil
	file_product_product_proto_depIdxs = nil
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\product\product_grpc.pb.go
====================
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: product/product.proto

package product

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ProductService_CreateProduct_FullMethodName     = "/product.ProductService/CreateProduct"
	ProductService_DetailProduct_FullMethodName     = "/product.ProductService/DetailProduct"
	ProductService_EditProduct_FullMethodName       = "/product.ProductService/EditProduct"
	ProductService_DeleteProduct_FullMethodName     = "/product.ProductService/DeleteProduct"
	ProductService_ListProduct_FullMethodName       = "/product.ProductService/ListProduct"
	ProductService_ListProductAdmin_FullMethodName  = "/product.ProductService/ListProductAdmin"
	ProductService_HighlightProducts_FullMethodName = "/product.ProductService/HighlightProducts"
)

// ProductServiceClient is the client API for ProductService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductServiceClient interface {
	CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*CreateProductResponse, error)
	DetailProduct(ctx context.Context, in *DetailProductRequest, opts ...grpc.CallOption) (*DetailProductResponse, error)
	EditProduct(ctx context.Context, in *EditProductRequest, opts ...grpc.CallOption) (*EditProductResponse, error)
	DeleteProduct(ctx context.Context, in *DeleteProductRequest, opts ...grpc.CallOption) (*DeleteProductResponse, error)
	ListProduct(ctx context.Context, in *ListProductRequest, opts ...grpc.CallOption) (*ListProductResponse, error)
	ListProductAdmin(ctx context.Context, in *ListProductAdminRequest, opts ...grpc.CallOption) (*ListProductAdminResponse, error)
	HighlightProducts(ctx context.Context, in *HighlightProductsRequest, opts ...grpc.CallOption) (*HighlightProductsResponse, error)
}

type productServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProductServiceClient(cc grpc.ClientConnInterface) ProductServiceClient {
	return &productServiceClient{cc}
}

func (c *productServiceClient) CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*CreateProductResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateProductResponse)
	err := c.cc.Invoke(ctx, ProductService_CreateProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) DetailProduct(ctx context.Context, in *DetailProductRequest, opts ...grpc.CallOption) (*DetailProductResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DetailProductResponse)
	err := c.cc.Invoke(ctx, ProductService_DetailProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) EditProduct(ctx context.Context, in *EditProductRequest, opts ...grpc.CallOption) (*EditProductResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditProductResponse)
	err := c.cc.Invoke(ctx, ProductService_EditProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) DeleteProduct(ctx context.Context, in *DeleteProductRequest, opts ...grpc.CallOption) (*DeleteProductResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteProductResponse)
	err := c.cc.Invoke(ctx, ProductService_DeleteProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) ListProduct(ctx context.Context, in *ListProductRequest, opts ...grpc.CallOption) (*ListProductResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProductResponse)
	err := c.cc.Invoke(ctx, ProductService_ListProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) ListProductAdmin(ctx context.Context, in *ListProductAdminRequest, opts ...grpc.CallOption) (*ListProductAdminResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProductAdminResponse)
	err := c.cc.Invoke(ctx, ProductService_ListProductAdmin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productServiceClient) HighlightProducts(ctx context.Context, in *HighlightProductsRequest, opts ...grpc.CallOption) (*HighlightProductsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HighlightProductsResponse)
	err := c.cc.Invoke(ctx, ProductService_HighlightProducts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductServiceServer is the server API for ProductService service.
// All implementations must embed UnimplementedProductServiceServer
// for forward compatibility.
type ProductServiceServer interface {
	CreateProduct(context.Context, *CreateProductRequest) (*CreateProductResponse, error)
	DetailProduct(context.Context, *DetailProductRequest) (*DetailProductResponse, error)
	EditProduct(context.Context, *EditProductRequest) (*EditProductResponse, error)
	DeleteProduct(context.Context, *DeleteProductRequest) (*DeleteProductResponse, error)
	ListProduct(context.Context, *ListProductRequest) (*ListProductResponse, error)
	ListProductAdmin(context.Context, *ListProductAdminRequest) (*ListProductAdminResponse, error)
	HighlightProducts(context.Context, *HighlightProductsRequest) (*HighlightProductsResponse, error)
	mustEmbedUnimplementedProductServiceServer()
}

// UnimplementedProductServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProductServiceServer struct{}

func (UnimplementedProductServiceServer) CreateProduct(context.Context, *CreateProductRequest) (*CreateProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProduct not implemented")
}
func (UnimplementedProductServiceServer) DetailProduct(context.Context, *DetailProductRequest) (*DetailProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetailProduct not implemented")
}
func (UnimplementedProductServiceServer) EditProduct(context.Context, *EditProductRequest) (*EditProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditProduct not implemented")
}
func (UnimplementedProductServiceServer) DeleteProduct(context.Context, *DeleteProductRequest) (*DeleteProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProduct not implemented")
}
func (UnimplementedProductServiceServer) ListProduct(context.Context, *ListProductRequest) (*ListProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProduct not implemented")
}
func (UnimplementedProductServiceServer) ListProductAdmin(context.Context, *ListProductAdminRequest) (*ListProductAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProductAdmin not implemented")
}
func (UnimplementedProductServiceServer) HighlightProducts(context.Context, *HighlightProductsRequest) (*HighlightProductsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HighlightProducts not implemented")
}
func (UnimplementedProductServiceServer) mustEmbedUnimplementedProductServiceServer() {}
func (UnimplementedProductServiceServer) testEmbeddedByValue()                        {}

// UnsafeProductServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductServiceServer will
// result in compilation errors.
type UnsafeProductServiceServer interface {
	mustEmbedUnimplementedProductServiceServer()
}

func RegisterProductServiceServer(s grpc.ServiceRegistrar, srv ProductServiceServer) {
	// If the following call pancis, it indicates UnimplementedProductServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProductService_ServiceDesc, srv)
}

func _ProductService_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductService_CreateProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).CreateProduct(ctx, req.(*CreateProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_DetailProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetailProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).DetailProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductService_DetailProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).DetailProduct(ctx, req.(*DetailProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_EditProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).EditProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductService_EditProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).EditProduct(ctx, req.(*EditProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_DeleteProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).DeleteProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductService_DeleteProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).DeleteProduct(ctx, req.(*DeleteProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_ListProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).ListProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductService_ListProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).ListProduct(ctx, req.(*ListProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_ListProductAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).ListProductAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductService_ListProductAdmin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).ListProductAdmin(ctx, req.(*ListProductAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProductService_HighlightProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HighlightProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServiceServer).HighlightProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProductService_HighlightProducts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServiceServer).HighlightProducts(ctx, req.(*HighlightProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProductService_ServiceDesc is the grpc.ServiceDesc for ProductService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProductService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "product.ProductService",
	HandlerType: (*ProductServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProduct",
			Handler:    _ProductService_CreateProduct_Handler,
		},
		{
			MethodName: "DetailProduct",
			Handler:    _ProductService_DetailProduct_Handler,
		},
		{
			MethodName: "EditProduct",
			Handler:    _ProductService_EditProduct_Handler,
		},
		{
			MethodName: "DeleteProduct",
			Handler:    _ProductService_DeleteProduct_Handler,
		},
		{
			MethodName: "ListProduct",
			Handler:    _ProductService_ListProduct_Handler,
		},
		{
			MethodName: "ListProductAdmin",
			Handler:    _ProductService_ListProductAdmin_Handler,
		},
		{
			MethodName: "HighlightProducts",
			Handler:    _ProductService_HighlightProducts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "product/product.proto",
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\service\service.pb.go
====================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v5.29.3
// source: service/service.proto

package service

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	common "github.com/luzmareto/go-grpc-ecommerce-be/pb/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type HelloWordlRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HelloWordlRequest) Reset() {
	*x = HelloWordlRequest{}
	mi := &file_service_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HelloWordlRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HelloWordlRequest) ProtoMessage() {}

func (x *HelloWordlRequest) ProtoReflect() protoreflect.Message {
	mi := &file_service_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HelloWordlRequest.ProtoReflect.Descriptor instead.
func (*HelloWordlRequest) Descriptor() ([]byte, []int) {
	return file_service_service_proto_rawDescGZIP(), []int{0}
}

func (x *HelloWordlRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type HelloWorldResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Base          *common.BaseResponse   `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HelloWorldResponse) Reset() {
	*x = HelloWorldResponse{}
	mi := &file_service_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HelloWorldResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HelloWorldResponse) ProtoMessage() {}

func (x *HelloWorldResponse) ProtoReflect() protoreflect.Message {
	mi := &file_service_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HelloWorldResponse.ProtoReflect.Descriptor instead.
func (*HelloWorldResponse) Descriptor() ([]byte, []int) {
	return file_service_service_proto_rawDescGZIP(), []int{1}
}

func (x *HelloWorldResponse) GetBase() *common.BaseResponse {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *HelloWorldResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

var File_service_service_proto protoreflect.FileDescriptor

const file_service_service_proto_rawDesc = "" +
	"\n" +
	"\x15service/service.proto\x12\aservice\x1a\x1acommon/base_response.proto\x1a\x1bbuf/validate/validate.proto\"3\n" +
	"\x11HelloWordlRequest\x12\x1e\n" +
	"\x04name\x18\x01 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\xff\x01R\x04name\"X\n" +
	"\x12HelloWorldResponse\x12(\n" +
	"\x04base\x18\x01 \x01(\v2\x14.common.BaseResponseR\x04base\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage2Z\n" +
	"\x11HelloWorldService\x12E\n" +
	"\n" +
	"HelloWorld\x12\x1a.service.HelloWordlRequest\x1a\x1b.service.HelloWorldResponseB6Z4github.com/luzmareto/go-grpc-ecommerce-be/pb/serviceb\x06proto3"

var (
	file_service_service_proto_rawDescOnce sync.Once
	file_service_service_proto_rawDescData []byte
)

func file_service_service_proto_rawDescGZIP() []byte {
	file_service_service_proto_rawDescOnce.Do(func() {
		file_service_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_service_service_proto_rawDesc), len(file_service_service_proto_rawDesc)))
	})
	return file_service_service_proto_rawDescData
}

var file_service_service_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_service_service_proto_goTypes = []any{
	(*HelloWordlRequest)(nil),   // 0: service.HelloWordlRequest
	(*HelloWorldResponse)(nil),  // 1: service.HelloWorldResponse
	(*common.BaseResponse)(nil), // 2: common.BaseResponse
}
var file_service_service_proto_depIdxs = []int32{
	2, // 0: service.HelloWorldResponse.base:type_name -> common.BaseResponse
	0, // 1: service.HelloWorldService.HelloWorld:input_type -> service.HelloWordlRequest
	1, // 2: service.HelloWorldService.HelloWorld:output_type -> service.HelloWorldResponse
	2, // [2:3] is the sub-list for method output_type
	1, // [1:2] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_service_service_proto_init() }
func file_service_service_proto_init() {
	if File_service_service_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_service_service_proto_rawDesc), len(file_service_service_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_service_service_proto_goTypes,
		DependencyIndexes: file_service_service_proto_depIdxs,
		MessageInfos:      file_service_service_proto_msgTypes,
	}.Build()
	File_service_service_proto = out.File
	file_service_service_proto_goTypes = nil
	file_service_service_proto_depIdxs = nil
}




====================
FILE: D:\go-grpc-ecommerce-be\pb\service\service_grpc.pb.go
====================
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: service/service.proto

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	HelloWorldService_HelloWorld_FullMethodName = "/service.HelloWorldService/HelloWorld"
)

// HelloWorldServiceClient is the client API for HelloWorldService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HelloWorldServiceClient interface {
	HelloWorld(ctx context.Context, in *HelloWordlRequest, opts ...grpc.CallOption) (*HelloWorldResponse, error)
}

type helloWorldServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHelloWorldServiceClient(cc grpc.ClientConnInterface) HelloWorldServiceClient {
	return &helloWorldServiceClient{cc}
}

func (c *helloWorldServiceClient) HelloWorld(ctx context.Context, in *HelloWordlRequest, opts ...grpc.CallOption) (*HelloWorldResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HelloWorldResponse)
	err := c.cc.Invoke(ctx, HelloWorldService_HelloWorld_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HelloWorldServiceServer is the server API for HelloWorldService service.
// All implementations must embed UnimplementedHelloWorldServiceServer
// for forward compatibility.
type HelloWorldServiceServer interface {
	HelloWorld(context.Context, *HelloWordlRequest) (*HelloWorldResponse, error)
	mustEmbedUnimplementedHelloWorldServiceServer()
}

// UnimplementedHelloWorldServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHelloWorldServiceServer struct{}

func (UnimplementedHelloWorldServiceServer) HelloWorld(context.Context, *HelloWordlRequest) (*HelloWorldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HelloWorld not implemented")
}
func (UnimplementedHelloWorldServiceServer) mustEmbedUnimplementedHelloWorldServiceServer() {}
func (UnimplementedHelloWorldServiceServer) testEmbeddedByValue()                           {}

// UnsafeHelloWorldServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HelloWorldServiceServer will
// result in compilation errors.
type UnsafeHelloWorldServiceServer interface {
	mustEmbedUnimplementedHelloWorldServiceServer()
}

func RegisterHelloWorldServiceServer(s grpc.ServiceRegistrar, srv HelloWorldServiceServer) {
	// If the following call pancis, it indicates UnimplementedHelloWorldServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HelloWorldService_ServiceDesc, srv)
}

func _HelloWorldService_HelloWorld_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloWordlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HelloWorldServiceServer).HelloWorld(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HelloWorldService_HelloWorld_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HelloWorldServiceServer).HelloWorld(ctx, req.(*HelloWordlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HelloWorldService_ServiceDesc is the grpc.ServiceDesc for HelloWorldService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HelloWorldService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.HelloWorldService",
	HandlerType: (*HelloWorldServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HelloWorld",
			Handler:    _HelloWorldService_HelloWorld_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/service.proto",
}




====================
FILE: D:\go-grpc-ecommerce-be\pkg\database\connection.go
====================
package database

import (
	"context"

	_ "github.com/lib/pq"

	"database/sql"
)

func ConnectDB(ctx context.Context, connstr string) *sql.DB {
	db, err := sql.Open("postgres", connstr)
	if err != nil {
		panic(err)
	}

	err = db.PingContext(ctx)
	if err != nil {
		panic(err)
	}

	return db
}




====================
FILE: D:\go-grpc-ecommerce-be\pkg\database\database_query.go
====================
package database

import (
	"context"
	"database/sql"
)

type DatabaseQuery interface {
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}




====================
FILE: D:\go-grpc-ecommerce-be\proto\auth\auth.proto
====================
syntax  = "proto3";

package auth;

import "common/base_response.proto";
import "buf/validate/validate.proto";
import "google/protobuf/timestamp.proto";


option go_package = "github.com/luzmareto/go-grpc-ecommerce-be/pb/auth";

service AuthService {
    rpc Register(RegisterRequest) returns (RegisterResponse);
    rpc Login(LoginRequest) returns (LoginResponse);
    rpc Logout(LogoutRequest) returns (LogoutResponse);
    rpc ChangePassword(ChangePasswordRequest) returns (ChangePasswordResponse);
    rpc GetProfile(GetProfileRequest) returns (GetProfileResponse);
}

message RegisterRequest {
  string full_name = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
  string email = 2 [(buf.validate.field).string = { email: true, min_len: 1, max_len: 255 }];
  string password = 3 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
  string password_confirmation = 4 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}


message RegisterResponse {
    common.BaseResponse base = 1;
}

message LoginRequest {
  string email = 1 [(buf.validate.field).string = { email: true, min_len: 1, max_len: 255 }];
  string password = 2 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}


message LoginResponse {
    common.BaseResponse base = 1;
    string access_token = 2;
  }

message LogoutRequest {}


message LogoutResponse {
    common.BaseResponse base = 1;
  }

message ChangePasswordRequest {
  string old_password = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
  string new_password = 2 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
  string new_password_confirmation = 3 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}


message ChangePasswordResponse {
    common.BaseResponse base = 1;
  }

message GetProfileRequest {
}


message GetProfileResponse {
    common.BaseResponse base = 1;
    string user_id = 2;
    string full_name = 3;
    string email = 4;
    string role_code = 5;
    google.protobuf.Timestamp member_since = 6;
  }



====================
FILE: D:\go-grpc-ecommerce-be\proto\buf\validate\validate.proto
====================
// Copyright 2023-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";

package buf.validate;

import "google/protobuf/descriptor.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

option go_package = "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate";
option java_multiple_files = true;
option java_outer_classname = "ValidateProto";
option java_package = "build.buf.validate";

// MessageOptions is an extension to google.protobuf.MessageOptions. It allows
// the addition of validation rules at the message level. These rules can be
// applied to incoming messages to ensure they meet certain criteria before
// being processed.
extend google.protobuf.MessageOptions {
  // Rules specify the validations to be performed on this message. By default,
  // no validation is performed against a message.
  optional MessageRules message = 1159;
}

// OneofOptions is an extension to google.protobuf.OneofOptions. It allows
// the addition of validation rules on a oneof. These rules can be
// applied to incoming messages to ensure they meet certain criteria before
// being processed.
extend google.protobuf.OneofOptions {
  // Rules specify the validations to be performed on this oneof. By default,
  // no validation is performed against a oneof.
  optional OneofRules oneof = 1159;
}

// FieldOptions is an extension to google.protobuf.FieldOptions. It allows
// the addition of validation rules at the field level. These rules can be
// applied to incoming messages to ensure they meet certain criteria before
// being processed.
extend google.protobuf.FieldOptions {
  // Rules specify the validations to be performed on this field. By default,
  // no validation is performed against a field.
  optional FieldRules field = 1159;

  // Specifies predefined rules. When extending a standard rule message,
  // this adds additional CEL expressions that apply when the extension is used.
  //
  // ```proto
  // extend buf.validate.Int32Rules {
  //   bool is_zero [(buf.validate.predefined).cel = {
  //     id: "int32.is_zero",
  //     message: "value must be zero",
  //     expression: "!rule || this == 0",
  //   }];
  // }
  //
  // message Foo {
  //   int32 reserved = 1 [(buf.validate.field).int32.(is_zero) = true];
  // }
  // ```
  optional PredefinedRules predefined = 1160;
}

// `Rule` represents a validation rule written in the Common Expression
// Language (CEL) syntax. Each Rule includes a unique identifier, an
// optional error message, and the CEL expression to evaluate. For more
// information, [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
//
// ```proto
// message Foo {
//   option (buf.validate.message).cel = {
//     id: "foo.bar"
//     message: "bar must be greater than 0"
//     expression: "this.bar > 0"
//   };
//   int32 bar = 1;
// }
// ```
message Rule {
  // `id` is a string that serves as a machine-readable name for this Rule.
  // It should be unique within its scope, which could be either a message or a field.
  optional string id = 1;

  // `message` is an optional field that provides a human-readable error message
  // for this Rule when the CEL expression evaluates to false. If a
  // non-empty message is provided, any strings resulting from the CEL
  // expression evaluation are ignored.
  optional string message = 2;

  // `expression` is the actual CEL expression that will be evaluated for
  // validation. This string must resolve to either a boolean or a string
  // value. If the expression evaluates to false or a non-empty string, the
  // validation is considered failed, and the message is rejected.
  optional string expression = 3;
}

// MessageRules represents validation rules that are applied to the entire message.
// It includes disabling options and a list of Rule messages representing Common Expression Language (CEL) validation rules.
message MessageRules {
  // `cel` is a repeated field of type Rule. Each Rule specifies a validation rule to be applied to this message.
  // These rules are written in Common Expression Language (CEL) syntax. For more information,
  // [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
  //
  //
  // ```proto
  // message MyMessage {
  //   // The field `foo` must be greater than 42.
  //   option (buf.validate.message).cel = {
  //     id: "my_message.value",
  //     message: "value must be greater than 42",
  //     expression: "this.foo > 42",
  //   };
  //   optional int32 foo = 1;
  // }
  // ```
  repeated Rule cel = 3;

  // `oneof` is a repeated field of type MessageOneofRule that specifies a list of fields
  // of which at most one can be present. If `required` is also specified, then exactly one
  // of the specified fields _must_ be present.
  //
  // This will enforce oneof-like constraints with a few features not provided by
  // actual Protobuf oneof declarations:
  //   1. Repeated and map fields are allowed in this validation. In a Protobuf oneof,
  //      only scalar fields are allowed.
  //   2. Fields with implicit presence are allowed. In a Protobuf oneof, all member
  //      fields have explicit presence. This means that, for the purpose of determining
  //      how many fields are set, explicitly setting such a field to its zero value is
  //      effectively the same as not setting it at all.
  //   3. This will always generate validation errors for a message unmarshalled from
  //      serialized data that sets more than one field. With a Protobuf oneof, when
  //      multiple fields are present in the serialized form, earlier values are usually
  //      silently ignored when unmarshalling, with only the last field being set when
  //      unmarshalling completes.
  //
  // Note that adding a field to a `oneof` will also set the IGNORE_IF_ZERO_VALUE on the fields. This means
  // only the field that is set will be validated and the unset fields are not validated according to the field rules.
  // This behavior can be overridden by setting `ignore` against a field.
  //
  // ```proto
  // message MyMessage {
  //   // Only one of `field1` or `field2` _can_ be present in this message.
  //   option (buf.validate.message).oneof = { fields: ["field1", "field2"] };
  //   // Exactly one of `field3` or `field4` _must_ be present in this message.
  //   option (buf.validate.message).oneof = { fields: ["field3", "field4"], required: true };
  //   string field1 = 1;
  //   bytes field2 = 2;
  //   bool field3 = 3;
  //   int32 field4 = 4;
  // }
  // ```
  repeated MessageOneofRule oneof = 4;

  reserved 1;
  reserved "disabled";
}

message MessageOneofRule {
  // A list of field names to include in the oneof. All field names must be
  // defined in the message. At least one field must be specified, and
  // duplicates are not permitted.
  repeated string fields = 1;
  // If true, one of the fields specified _must_ be set.
  optional bool required = 2;
}

// The `OneofRules` message type enables you to manage rules for
// oneof fields in your protobuf messages.
message OneofRules {
  // If `required` is true, exactly one field of the oneof must be set. A
  // validation error is returned if no fields in the oneof are set. Further rules
  // should be placed on the fields themselves to ensure they are valid values,
  // such as `min_len` or `gt`.
  //
  // ```proto
  // message MyMessage {
  //   oneof value {
  //     // Either `a` or `b` must be set. If `a` is set, it must also be
  //     // non-empty; whereas if `b` is set, it can still be an empty string.
  //     option (buf.validate.oneof).required = true;
  //     string a = 1 [(buf.validate.field).string.min_len = 1];
  //     string b = 2;
  //   }
  // }
  // ```
  optional bool required = 1;
}

// FieldRules encapsulates the rules for each type of field. Depending on
// the field, the correct set should be used to ensure proper validations.
message FieldRules {
  // `cel` is a repeated field used to represent a textual expression
  // in the Common Expression Language (CEL) syntax. For more information,
  // [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
  //
  // ```proto
  // message MyMessage {
  //   // The field `value` must be greater than 42.
  //   optional int32 value = 1 [(buf.validate.field).cel = {
  //     id: "my_message.value",
  //     message: "value must be greater than 42",
  //     expression: "this > 42",
  //   }];
  // }
  // ```
  repeated Rule cel = 23;
  // If `required` is true, the field must be set. A validation error is returned
  // if the field is not set.
  //
  // ```proto
  // syntax="proto3";
  //
  // message FieldsWithPresence {
  //   // Requires any string to be set, including the empty string.
  //   optional string link = 1 [
  //     (buf.validate.field).required = true
  //   ];
  //   // Requires true or false to be set.
  //   optional bool disabled = 2 [
  //     (buf.validate.field).required = true
  //   ];
  //   // Requires a message to be set, including the empty message.
  //   SomeMessage msg = 4 [
  //     (buf.validate.field).required = true
  //   ];
  // }
  // ```
  //
  // All fields in the example above track presence. By default, Protovalidate
  // ignores rules on those fields if no value is set. `required` ensures that
  // the fields are set and valid.
  //
  // Fields that don't track presence are always validated by Protovalidate,
  // whether they are set or not. It is not necessary to add `required`. It
  // can be added to indicate that the field cannot be the zero value.
  //
  // ```proto
  // syntax="proto3";
  //
  // message FieldsWithoutPresence {
  //   // `string.email` always applies, even to an empty string.
  //   string link = 1 [
  //     (buf.validate.field).string.email = true
  //   ];
  //   // `repeated.min_items` always applies, even to an empty list.
  //   repeated string labels = 2 [
  //     (buf.validate.field).repeated.min_items = 1
  //   ];
  //   // `required`, for fields that don't track presence, indicates
  //   // the value of the field can't be the zero value.
  //   int32 zero_value_not_allowed = 3 [
  //     (buf.validate.field).required = true
  //   ];
  // }
  // ```
  //
  // To learn which fields track presence, see the
  // [Field Presence cheat sheet](https://protobuf.dev/programming-guides/field_presence/#cheat).
  //
  // Note: While field rules can be applied to repeated items, map keys, and map
  // values, the elements are always considered to be set. Consequently,
  // specifying `repeated.items.required` is redundant.
  optional bool required = 25;
  // Ignore validation rules on the field if its value matches the specified
  // criteria. See the `Ignore` enum for details.
  //
  // ```proto
  // message UpdateRequest {
  //   // The uri rule only applies if the field is not an empty string.
  //   string url = 1 [
  //     (buf.validate.field).ignore = IGNORE_IF_ZERO_VALUE,
  //     (buf.validate.field).string.uri = true
  //   ];
  // }
  // ```
  optional Ignore ignore = 27;

  oneof type {
    // Scalar Field Types
    FloatRules float = 1;
    DoubleRules double = 2;
    Int32Rules int32 = 3;
    Int64Rules int64 = 4;
    UInt32Rules uint32 = 5;
    UInt64Rules uint64 = 6;
    SInt32Rules sint32 = 7;
    SInt64Rules sint64 = 8;
    Fixed32Rules fixed32 = 9;
    Fixed64Rules fixed64 = 10;
    SFixed32Rules sfixed32 = 11;
    SFixed64Rules sfixed64 = 12;
    BoolRules bool = 13;
    StringRules string = 14;
    BytesRules bytes = 15;

    // Complex Field Types
    EnumRules enum = 16;
    RepeatedRules repeated = 18;
    MapRules map = 19;

    // Well-Known Field Types
    AnyRules any = 20;
    DurationRules duration = 21;
    TimestampRules timestamp = 22;
  }

  reserved 24, 26;
  reserved "skipped", "ignore_empty";
}

// PredefinedRules are custom rules that can be re-used with
// multiple fields.
message PredefinedRules {
  // `cel` is a repeated field used to represent a textual expression
  // in the Common Expression Language (CEL) syntax. For more information,
  // [see our documentation](https://buf.build/docs/protovalidate/schemas/predefined-rules/).
  //
  // ```proto
  // message MyMessage {
  //   // The field `value` must be greater than 42.
  //   optional int32 value = 1 [(buf.validate.predefined).cel = {
  //     id: "my_message.value",
  //     message: "value must be greater than 42",
  //     expression: "this > 42",
  //   }];
  // }
  // ```
  repeated Rule cel = 1;

  reserved 24, 26;
  reserved "skipped", "ignore_empty";
}

// Specifies how `FieldRules.ignore` behaves, depending on the field's value, and
// whether the field tracks presence.
enum Ignore {
  // Ignore rules if the field tracks presence and is unset. This is the default
  // behavior.
  //
  // In proto3, only message fields, members of a Protobuf `oneof`, and fields
  // with the `optional` label track presence. Consequently, the following fields
  // are always validated, whether a value is set or not:
  //
  // ```proto
  // syntax="proto3";
  //
  // message RulesApply {
  //   string email = 1 [
  //     (buf.validate.field).string.email = true
  //   ];
  //   int32 age = 2 [
  //     (buf.validate.field).int32.gt = 0
  //   ];
  //   repeated string labels = 3 [
  //     (buf.validate.field).repeated.min_items = 1
  //   ];
  // }
  // ```
  //
  // In contrast, the following fields track presence, and are only validated if
  // a value is set:
  //
  // ```proto
  // syntax="proto3";
  //
  // message RulesApplyIfSet {
  //   optional string email = 1 [
  //     (buf.validate.field).string.email = true
  //   ];
  //   oneof ref {
  //     string reference = 2 [
  //       (buf.validate.field).string.uuid = true
  //     ];
  //     string name = 3 [
  //       (buf.validate.field).string.min_len = 4
  //     ];
  //   }
  //   SomeMessage msg = 4 [
  //     (buf.validate.field).cel = {/* ... */}
  //   ];
  // }
  // ```
  //
  // To ensure that such a field is set, add the `required` rule.
  //
  // To learn which fields track presence, see the
  // [Field Presence cheat sheet](https://protobuf.dev/programming-guides/field_presence/#cheat).
  IGNORE_UNSPECIFIED = 0;

  // Ignore rules if the field is unset, or set to the zero value.
  //
  // The zero value depends on the field type:
  // - For strings, the zero value is the empty string.
  // - For bytes, the zero value is empty bytes.
  // - For bool, the zero value is false.
  // - For numeric types, the zero value is zero.
  // - For enums, the zero value is the first defined enum value.
  // - For repeated fields, the zero is an empty list.
  // - For map fields, the zero is an empty map.
  // - For message fields, absence of the message (typically a null-value) is considered zero value.
  //
  // For fields that track presence (e.g. adding the `optional` label in proto3),
  // this a no-op and behavior is the same as the default `IGNORE_UNSPECIFIED`.
  IGNORE_IF_ZERO_VALUE = 1;

  // Always ignore rules, including the `required` rule.
  //
  // This is useful for ignoring the rules of a referenced message, or to
  // temporarily ignore rules during development.
  //
  // ```proto
  // message MyMessage {
  //   // The field's rules will always be ignored, including any validations
  //   // on value's fields.
  //   MyOtherMessage value = 1 [
  //     (buf.validate.field).ignore = IGNORE_ALWAYS
  //   ];
  // }
  // ```
  IGNORE_ALWAYS = 3;

  reserved 2;
  reserved "IGNORE_EMPTY", "IGNORE_DEFAULT", "IGNORE_IF_DEFAULT_VALUE", "IGNORE_IF_UNPOPULATED";
}

// FloatRules describes the rules applied to `float` values. These
// rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.
message FloatRules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyFloat {
  //   // value must equal 42.0
  //   float value = 1 [(buf.validate.field).float.const = 42.0];
  // }
  // ```
  optional float const = 1 [(predefined).cel = {
    id: "float.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];

  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyFloat {
    //   // value must be less than 10.0
    //   float value = 1 [(buf.validate.field).float.lt = 10.0];
    // }
    // ```
    float lt = 2 [(predefined).cel = {
      id: "float.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyFloat {
    //   // value must be less than or equal to 10.0
    //   float value = 1 [(buf.validate.field).float.lte = 10.0];
    // }
    // ```
    float lte = 3 [(predefined).cel = {
      id: "float.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }

  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFloat {
    //   // value must be greater than 5.0 [float.gt]
    //   float value = 1 [(buf.validate.field).float.gt = 5.0];
    //
    //   // value must be greater than 5 and less than 10.0 [float.gt_lt]
    //   float other_value = 2 [(buf.validate.field).float = { gt: 5.0, lt: 10.0 }];
    //
    //   // value must be greater than 10 or less than 5.0 [float.gt_lt_exclusive]
    //   float another_value = 3 [(buf.validate.field).float = { gt: 10.0, lt: 5.0 }];
    // }
    // ```
    float gt = 4 [
      (predefined).cel = {
        id: "float.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "float.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "float.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "float.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "float.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFloat {
    //   // value must be greater than or equal to 5.0 [float.gte]
    //   float value = 1 [(buf.validate.field).float.gte = 5.0];
    //
    //   // value must be greater than or equal to 5.0 and less than 10.0 [float.gte_lt]
    //   float other_value = 2 [(buf.validate.field).float = { gte: 5.0, lt: 10.0 }];
    //
    //   // value must be greater than or equal to 10.0 or less than 5.0 [float.gte_lt_exclusive]
    //   float another_value = 3 [(buf.validate.field).float = { gte: 10.0, lt: 5.0 }];
    // }
    // ```
    float gte = 5 [
      (predefined).cel = {
        id: "float.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "float.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "float.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "float.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "float.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message
  // is generated.
  //
  // ```proto
  // message MyFloat {
  //   // value must be in list [1.0, 2.0, 3.0]
  //   float value = 1 [(buf.validate.field).float = { in: [1.0, 2.0, 3.0] }];
  // }
  // ```
  repeated float in = 6 [(predefined).cel = {
    id: "float.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyFloat {
  //   // value must not be in list [1.0, 2.0, 3.0]
  //   float value = 1 [(buf.validate.field).float = { not_in: [1.0, 2.0, 3.0] }];
  // }
  // ```
  repeated float not_in = 7 [(predefined).cel = {
    id: "float.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `finite` requires the field value to be finite. If the field value is
  // infinite or NaN, an error message is generated.
  optional bool finite = 8 [(predefined).cel = {
    id: "float.finite"
    expression: "rules.finite ? (this.isNan() || this.isInf() ? 'value must be finite' : '') : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyFloat {
  //   float value = 1 [
  //     (buf.validate.field).float.example = 1.0,
  //     (buf.validate.field).float.example = inf
  //   ];
  // }
  // ```
  repeated float example = 9 [(predefined).cel = {
    id: "float.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// DoubleRules describes the rules applied to `double` values. These
// rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.
message DoubleRules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyDouble {
  //   // value must equal 42.0
  //   double value = 1 [(buf.validate.field).double.const = 42.0];
  // }
  // ```
  optional double const = 1 [(predefined).cel = {
    id: "double.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyDouble {
    //   // value must be less than 10.0
    //   double value = 1 [(buf.validate.field).double.lt = 10.0];
    // }
    // ```
    double lt = 2 [(predefined).cel = {
      id: "double.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified value
    // (field <= value). If the field value is greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyDouble {
    //   // value must be less than or equal to 10.0
    //   double value = 1 [(buf.validate.field).double.lte = 10.0];
    // }
    // ```
    double lte = 3 [(predefined).cel = {
      id: "double.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,
    // the range is reversed, and the field value must be outside the specified
    // range. If the field value doesn't meet the required conditions, an error
    // message is generated.
    //
    // ```proto
    // message MyDouble {
    //   // value must be greater than 5.0 [double.gt]
    //   double value = 1 [(buf.validate.field).double.gt = 5.0];
    //
    //   // value must be greater than 5 and less than 10.0 [double.gt_lt]
    //   double other_value = 2 [(buf.validate.field).double = { gt: 5.0, lt: 10.0 }];
    //
    //   // value must be greater than 10 or less than 5.0 [double.gt_lt_exclusive]
    //   double another_value = 3 [(buf.validate.field).double = { gt: 10.0, lt: 5.0 }];
    // }
    // ```
    double gt = 4 [
      (predefined).cel = {
        id: "double.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "double.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "double.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "double.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "double.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyDouble {
    //   // value must be greater than or equal to 5.0 [double.gte]
    //   double value = 1 [(buf.validate.field).double.gte = 5.0];
    //
    //   // value must be greater than or equal to 5.0 and less than 10.0 [double.gte_lt]
    //   double other_value = 2 [(buf.validate.field).double = { gte: 5.0, lt: 10.0 }];
    //
    //   // value must be greater than or equal to 10.0 or less than 5.0 [double.gte_lt_exclusive]
    //   double another_value = 3 [(buf.validate.field).double = { gte: 10.0, lt: 5.0 }];
    // }
    // ```
    double gte = 5 [
      (predefined).cel = {
        id: "double.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "double.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "double.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "double.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "double.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }
  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyDouble {
  //   // value must be in list [1.0, 2.0, 3.0]
  //   double value = 1 [(buf.validate.field).double = { in: [1.0, 2.0, 3.0] }];
  // }
  // ```
  repeated double in = 6 [(predefined).cel = {
    id: "double.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyDouble {
  //   // value must not be in list [1.0, 2.0, 3.0]
  //   double value = 1 [(buf.validate.field).double = { not_in: [1.0, 2.0, 3.0] }];
  // }
  // ```
  repeated double not_in = 7 [(predefined).cel = {
    id: "double.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `finite` requires the field value to be finite. If the field value is
  // infinite or NaN, an error message is generated.
  optional bool finite = 8 [(predefined).cel = {
    id: "double.finite"
    expression: "rules.finite ? (this.isNan() || this.isInf() ? 'value must be finite' : '') : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyDouble {
  //   double value = 1 [
  //     (buf.validate.field).double.example = 1.0,
  //     (buf.validate.field).double.example = inf
  //   ];
  // }
  // ```
  repeated double example = 9 [(predefined).cel = {
    id: "double.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// Int32Rules describes the rules applied to `int32` values. These
// rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.
message Int32Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyInt32 {
  //   // value must equal 42
  //   int32 value = 1 [(buf.validate.field).int32.const = 42];
  // }
  // ```
  optional int32 const = 1 [(predefined).cel = {
    id: "int32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field
    // < value). If the field value is equal to or greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyInt32 {
    //   // value must be less than 10
    //   int32 value = 1 [(buf.validate.field).int32.lt = 10];
    // }
    // ```
    int32 lt = 2 [(predefined).cel = {
      id: "int32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyInt32 {
    //   // value must be less than or equal to 10
    //   int32 value = 1 [(buf.validate.field).int32.lte = 10];
    // }
    // ```
    int32 lte = 3 [(predefined).cel = {
      id: "int32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyInt32 {
    //   // value must be greater than 5 [int32.gt]
    //   int32 value = 1 [(buf.validate.field).int32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [int32.gt_lt]
    //   int32 other_value = 2 [(buf.validate.field).int32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [int32.gt_lt_exclusive]
    //   int32 another_value = 3 [(buf.validate.field).int32 = { gt: 10, lt: 5 }];
    // }
    // ```
    int32 gt = 4 [
      (predefined).cel = {
        id: "int32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "int32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified value
    // (exclusive). If the value of `gte` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyInt32 {
    //   // value must be greater than or equal to 5 [int32.gte]
    //   int32 value = 1 [(buf.validate.field).int32.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [int32.gte_lt]
    //   int32 other_value = 2 [(buf.validate.field).int32 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [int32.gte_lt_exclusive]
    //   int32 another_value = 3 [(buf.validate.field).int32 = { gte: 10, lt: 5 }];
    // }
    // ```
    int32 gte = 5 [
      (predefined).cel = {
        id: "int32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "int32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "int32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyInt32 {
  //   // value must be in list [1, 2, 3]
  //   int32 value = 1 [(buf.validate.field).int32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated int32 in = 6 [(predefined).cel = {
    id: "int32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error message
  // is generated.
  //
  // ```proto
  // message MyInt32 {
  //   // value must not be in list [1, 2, 3]
  //   int32 value = 1 [(buf.validate.field).int32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated int32 not_in = 7 [(predefined).cel = {
    id: "int32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyInt32 {
  //   int32 value = 1 [
  //     (buf.validate.field).int32.example = 1,
  //     (buf.validate.field).int32.example = -10
  //   ];
  // }
  // ```
  repeated int32 example = 8 [(predefined).cel = {
    id: "int32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// Int64Rules describes the rules applied to `int64` values. These
// rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.
message Int64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyInt64 {
  //   // value must equal 42
  //   int64 value = 1 [(buf.validate.field).int64.const = 42];
  // }
  // ```
  optional int64 const = 1 [(predefined).cel = {
    id: "int64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyInt64 {
    //   // value must be less than 10
    //   int64 value = 1 [(buf.validate.field).int64.lt = 10];
    // }
    // ```
    int64 lt = 2 [(predefined).cel = {
      id: "int64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyInt64 {
    //   // value must be less than or equal to 10
    //   int64 value = 1 [(buf.validate.field).int64.lte = 10];
    // }
    // ```
    int64 lte = 3 [(predefined).cel = {
      id: "int64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyInt64 {
    //   // value must be greater than 5 [int64.gt]
    //   int64 value = 1 [(buf.validate.field).int64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [int64.gt_lt]
    //   int64 other_value = 2 [(buf.validate.field).int64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [int64.gt_lt_exclusive]
    //   int64 another_value = 3 [(buf.validate.field).int64 = { gt: 10, lt: 5 }];
    // }
    // ```
    int64 gt = 4 [
      (predefined).cel = {
        id: "int64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "int64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyInt64 {
    //   // value must be greater than or equal to 5 [int64.gte]
    //   int64 value = 1 [(buf.validate.field).int64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [int64.gte_lt]
    //   int64 other_value = 2 [(buf.validate.field).int64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [int64.gte_lt_exclusive]
    //   int64 another_value = 3 [(buf.validate.field).int64 = { gte: 10, lt: 5 }];
    // }
    // ```
    int64 gte = 5 [
      (predefined).cel = {
        id: "int64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "int64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "int64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyInt64 {
  //   // value must be in list [1, 2, 3]
  //   int64 value = 1 [(buf.validate.field).int64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated int64 in = 6 [(predefined).cel = {
    id: "int64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyInt64 {
  //   // value must not be in list [1, 2, 3]
  //   int64 value = 1 [(buf.validate.field).int64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated int64 not_in = 7 [(predefined).cel = {
    id: "int64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyInt64 {
  //   int64 value = 1 [
  //     (buf.validate.field).int64.example = 1,
  //     (buf.validate.field).int64.example = -10
  //   ];
  // }
  // ```
  repeated int64 example = 9 [(predefined).cel = {
    id: "int64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// UInt32Rules describes the rules applied to `uint32` values. These
// rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.
message UInt32Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyUInt32 {
  //   // value must equal 42
  //   uint32 value = 1 [(buf.validate.field).uint32.const = 42];
  // }
  // ```
  optional uint32 const = 1 [(predefined).cel = {
    id: "uint32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt32 {
    //   // value must be less than 10
    //   uint32 value = 1 [(buf.validate.field).uint32.lt = 10];
    // }
    // ```
    uint32 lt = 2 [(predefined).cel = {
      id: "uint32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyUInt32 {
    //   // value must be less than or equal to 10
    //   uint32 value = 1 [(buf.validate.field).uint32.lte = 10];
    // }
    // ```
    uint32 lte = 3 [(predefined).cel = {
      id: "uint32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt32 {
    //   // value must be greater than 5 [uint32.gt]
    //   uint32 value = 1 [(buf.validate.field).uint32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [uint32.gt_lt]
    //   uint32 other_value = 2 [(buf.validate.field).uint32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [uint32.gt_lt_exclusive]
    //   uint32 another_value = 3 [(buf.validate.field).uint32 = { gt: 10, lt: 5 }];
    // }
    // ```
    uint32 gt = 4 [
      (predefined).cel = {
        id: "uint32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt32 {
    //   // value must be greater than or equal to 5 [uint32.gte]
    //   uint32 value = 1 [(buf.validate.field).uint32.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [uint32.gte_lt]
    //   uint32 other_value = 2 [(buf.validate.field).uint32 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [uint32.gte_lt_exclusive]
    //   uint32 another_value = 3 [(buf.validate.field).uint32 = { gte: 10, lt: 5 }];
    // }
    // ```
    uint32 gte = 5 [
      (predefined).cel = {
        id: "uint32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyUInt32 {
  //   // value must be in list [1, 2, 3]
  //   uint32 value = 1 [(buf.validate.field).uint32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated uint32 in = 6 [(predefined).cel = {
    id: "uint32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyUInt32 {
  //   // value must not be in list [1, 2, 3]
  //   uint32 value = 1 [(buf.validate.field).uint32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated uint32 not_in = 7 [(predefined).cel = {
    id: "uint32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyUInt32 {
  //   uint32 value = 1 [
  //     (buf.validate.field).uint32.example = 1,
  //     (buf.validate.field).uint32.example = 10
  //   ];
  // }
  // ```
  repeated uint32 example = 8 [(predefined).cel = {
    id: "uint32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// UInt64Rules describes the rules applied to `uint64` values. These
// rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.
message UInt64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyUInt64 {
  //   // value must equal 42
  //   uint64 value = 1 [(buf.validate.field).uint64.const = 42];
  // }
  // ```
  optional uint64 const = 1 [(predefined).cel = {
    id: "uint64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt64 {
    //   // value must be less than 10
    //   uint64 value = 1 [(buf.validate.field).uint64.lt = 10];
    // }
    // ```
    uint64 lt = 2 [(predefined).cel = {
      id: "uint64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyUInt64 {
    //   // value must be less than or equal to 10
    //   uint64 value = 1 [(buf.validate.field).uint64.lte = 10];
    // }
    // ```
    uint64 lte = 3 [(predefined).cel = {
      id: "uint64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt64 {
    //   // value must be greater than 5 [uint64.gt]
    //   uint64 value = 1 [(buf.validate.field).uint64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [uint64.gt_lt]
    //   uint64 other_value = 2 [(buf.validate.field).uint64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [uint64.gt_lt_exclusive]
    //   uint64 another_value = 3 [(buf.validate.field).uint64 = { gt: 10, lt: 5 }];
    // }
    // ```
    uint64 gt = 4 [
      (predefined).cel = {
        id: "uint64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt64 {
    //   // value must be greater than or equal to 5 [uint64.gte]
    //   uint64 value = 1 [(buf.validate.field).uint64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [uint64.gte_lt]
    //   uint64 other_value = 2 [(buf.validate.field).uint64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [uint64.gte_lt_exclusive]
    //   uint64 another_value = 3 [(buf.validate.field).uint64 = { gte: 10, lt: 5 }];
    // }
    // ```
    uint64 gte = 5 [
      (predefined).cel = {
        id: "uint64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }
  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyUInt64 {
  //   // value must be in list [1, 2, 3]
  //   uint64 value = 1 [(buf.validate.field).uint64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated uint64 in = 6 [(predefined).cel = {
    id: "uint64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyUInt64 {
  //   // value must not be in list [1, 2, 3]
  //   uint64 value = 1 [(buf.validate.field).uint64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated uint64 not_in = 7 [(predefined).cel = {
    id: "uint64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyUInt64 {
  //   uint64 value = 1 [
  //     (buf.validate.field).uint64.example = 1,
  //     (buf.validate.field).uint64.example = -10
  //   ];
  // }
  // ```
  repeated uint64 example = 8 [(predefined).cel = {
    id: "uint64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// SInt32Rules describes the rules applied to `sint32` values.
message SInt32Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MySInt32 {
  //   // value must equal 42
  //   sint32 value = 1 [(buf.validate.field).sint32.const = 42];
  // }
  // ```
  optional sint32 const = 1 [(predefined).cel = {
    id: "sint32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field
    // < value). If the field value is equal to or greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySInt32 {
    //   // value must be less than 10
    //   sint32 value = 1 [(buf.validate.field).sint32.lt = 10];
    // }
    // ```
    sint32 lt = 2 [(predefined).cel = {
      id: "sint32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySInt32 {
    //   // value must be less than or equal to 10
    //   sint32 value = 1 [(buf.validate.field).sint32.lte = 10];
    // }
    // ```
    sint32 lte = 3 [(predefined).cel = {
      id: "sint32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySInt32 {
    //   // value must be greater than 5 [sint32.gt]
    //   sint32 value = 1 [(buf.validate.field).sint32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [sint32.gt_lt]
    //   sint32 other_value = 2 [(buf.validate.field).sint32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [sint32.gt_lt_exclusive]
    //   sint32 another_value = 3 [(buf.validate.field).sint32 = { gt: 10, lt: 5 }];
    // }
    // ```
    sint32 gt = 4 [
      (predefined).cel = {
        id: "sint32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySInt32 {
    //  // value must be greater than or equal to 5 [sint32.gte]
    //  sint32 value = 1 [(buf.validate.field).sint32.gte = 5];
    //
    //  // value must be greater than or equal to 5 and less than 10 [sint32.gte_lt]
    //  sint32 other_value = 2 [(buf.validate.field).sint32 = { gte: 5, lt: 10 }];
    //
    //  // value must be greater than or equal to 10 or less than 5 [sint32.gte_lt_exclusive]
    //  sint32 another_value = 3 [(buf.validate.field).sint32 = { gte: 10, lt: 5 }];
    // }
    // ```
    sint32 gte = 5 [
      (predefined).cel = {
        id: "sint32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MySInt32 {
  //   // value must be in list [1, 2, 3]
  //   sint32 value = 1 [(buf.validate.field).sint32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated sint32 in = 6 [(predefined).cel = {
    id: "sint32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MySInt32 {
  //   // value must not be in list [1, 2, 3]
  //   sint32 value = 1 [(buf.validate.field).sint32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated sint32 not_in = 7 [(predefined).cel = {
    id: "sint32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MySInt32 {
  //   sint32 value = 1 [
  //     (buf.validate.field).sint32.example = 1,
  //     (buf.validate.field).sint32.example = -10
  //   ];
  // }
  // ```
  repeated sint32 example = 8 [(predefined).cel = {
    id: "sint32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// SInt64Rules describes the rules applied to `sint64` values.
message SInt64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MySInt64 {
  //   // value must equal 42
  //   sint64 value = 1 [(buf.validate.field).sint64.const = 42];
  // }
  // ```
  optional sint64 const = 1 [(predefined).cel = {
    id: "sint64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field
    // < value). If the field value is equal to or greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySInt64 {
    //   // value must be less than 10
    //   sint64 value = 1 [(buf.validate.field).sint64.lt = 10];
    // }
    // ```
    sint64 lt = 2 [(predefined).cel = {
      id: "sint64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySInt64 {
    //   // value must be less than or equal to 10
    //   sint64 value = 1 [(buf.validate.field).sint64.lte = 10];
    // }
    // ```
    sint64 lte = 3 [(predefined).cel = {
      id: "sint64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySInt64 {
    //   // value must be greater than 5 [sint64.gt]
    //   sint64 value = 1 [(buf.validate.field).sint64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [sint64.gt_lt]
    //   sint64 other_value = 2 [(buf.validate.field).sint64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [sint64.gt_lt_exclusive]
    //   sint64 another_value = 3 [(buf.validate.field).sint64 = { gt: 10, lt: 5 }];
    // }
    // ```
    sint64 gt = 4 [
      (predefined).cel = {
        id: "sint64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySInt64 {
    //   // value must be greater than or equal to 5 [sint64.gte]
    //   sint64 value = 1 [(buf.validate.field).sint64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [sint64.gte_lt]
    //   sint64 other_value = 2 [(buf.validate.field).sint64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [sint64.gte_lt_exclusive]
    //   sint64 another_value = 3 [(buf.validate.field).sint64 = { gte: 10, lt: 5 }];
    // }
    // ```
    sint64 gte = 5 [
      (predefined).cel = {
        id: "sint64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message
  // is generated.
  //
  // ```proto
  // message MySInt64 {
  //   // value must be in list [1, 2, 3]
  //   sint64 value = 1 [(buf.validate.field).sint64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated sint64 in = 6 [(predefined).cel = {
    id: "sint64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MySInt64 {
  //   // value must not be in list [1, 2, 3]
  //   sint64 value = 1 [(buf.validate.field).sint64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated sint64 not_in = 7 [(predefined).cel = {
    id: "sint64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MySInt64 {
  //   sint64 value = 1 [
  //     (buf.validate.field).sint64.example = 1,
  //     (buf.validate.field).sint64.example = -10
  //   ];
  // }
  // ```
  repeated sint64 example = 8 [(predefined).cel = {
    id: "sint64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// Fixed32Rules describes the rules applied to `fixed32` values.
message Fixed32Rules {
  // `const` requires the field value to exactly match the specified value.
  // If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyFixed32 {
  //   // value must equal 42
  //   fixed32 value = 1 [(buf.validate.field).fixed32.const = 42];
  // }
  // ```
  optional fixed32 const = 1 [(predefined).cel = {
    id: "fixed32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed32 {
    //   // value must be less than 10
    //   fixed32 value = 1 [(buf.validate.field).fixed32.lt = 10];
    // }
    // ```
    fixed32 lt = 2 [(predefined).cel = {
      id: "fixed32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyFixed32 {
    //   // value must be less than or equal to 10
    //   fixed32 value = 1 [(buf.validate.field).fixed32.lte = 10];
    // }
    // ```
    fixed32 lte = 3 [(predefined).cel = {
      id: "fixed32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed32 {
    //   // value must be greater than 5 [fixed32.gt]
    //   fixed32 value = 1 [(buf.validate.field).fixed32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [fixed32.gt_lt]
    //   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [fixed32.gt_lt_exclusive]
    //   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gt: 10, lt: 5 }];
    // }
    // ```
    fixed32 gt = 4 [
      (predefined).cel = {
        id: "fixed32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed32 {
    //   // value must be greater than or equal to 5 [fixed32.gte]
    //   fixed32 value = 1 [(buf.validate.field).fixed32.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [fixed32.gte_lt]
    //   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [fixed32.gte_lt_exclusive]
    //   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gte: 10, lt: 5 }];
    // }
    // ```
    fixed32 gte = 5 [
      (predefined).cel = {
        id: "fixed32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message
  // is generated.
  //
  // ```proto
  // message MyFixed32 {
  //   // value must be in list [1, 2, 3]
  //   fixed32 value = 1 [(buf.validate.field).fixed32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated fixed32 in = 6 [(predefined).cel = {
    id: "fixed32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyFixed32 {
  //   // value must not be in list [1, 2, 3]
  //   fixed32 value = 1 [(buf.validate.field).fixed32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated fixed32 not_in = 7 [(predefined).cel = {
    id: "fixed32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyFixed32 {
  //   fixed32 value = 1 [
  //     (buf.validate.field).fixed32.example = 1,
  //     (buf.validate.field).fixed32.example = 2
  //   ];
  // }
  // ```
  repeated fixed32 example = 8 [(predefined).cel = {
    id: "fixed32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// Fixed64Rules describes the rules applied to `fixed64` values.
message Fixed64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyFixed64 {
  //   // value must equal 42
  //   fixed64 value = 1 [(buf.validate.field).fixed64.const = 42];
  // }
  // ```
  optional fixed64 const = 1 [(predefined).cel = {
    id: "fixed64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed64 {
    //   // value must be less than 10
    //   fixed64 value = 1 [(buf.validate.field).fixed64.lt = 10];
    // }
    // ```
    fixed64 lt = 2 [(predefined).cel = {
      id: "fixed64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyFixed64 {
    //   // value must be less than or equal to 10
    //   fixed64 value = 1 [(buf.validate.field).fixed64.lte = 10];
    // }
    // ```
    fixed64 lte = 3 [(predefined).cel = {
      id: "fixed64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed64 {
    //   // value must be greater than 5 [fixed64.gt]
    //   fixed64 value = 1 [(buf.validate.field).fixed64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [fixed64.gt_lt]
    //   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [fixed64.gt_lt_exclusive]
    //   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gt: 10, lt: 5 }];
    // }
    // ```
    fixed64 gt = 4 [
      (predefined).cel = {
        id: "fixed64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed64 {
    //   // value must be greater than or equal to 5 [fixed64.gte]
    //   fixed64 value = 1 [(buf.validate.field).fixed64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [fixed64.gte_lt]
    //   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [fixed64.gte_lt_exclusive]
    //   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gte: 10, lt: 5 }];
    // }
    // ```
    fixed64 gte = 5 [
      (predefined).cel = {
        id: "fixed64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyFixed64 {
  //   // value must be in list [1, 2, 3]
  //   fixed64 value = 1 [(buf.validate.field).fixed64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated fixed64 in = 6 [(predefined).cel = {
    id: "fixed64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyFixed64 {
  //   // value must not be in list [1, 2, 3]
  //   fixed64 value = 1 [(buf.validate.field).fixed64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated fixed64 not_in = 7 [(predefined).cel = {
    id: "fixed64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyFixed64 {
  //   fixed64 value = 1 [
  //     (buf.validate.field).fixed64.example = 1,
  //     (buf.validate.field).fixed64.example = 2
  //   ];
  // }
  // ```
  repeated fixed64 example = 8 [(predefined).cel = {
    id: "fixed64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// SFixed32Rules describes the rules applied to `fixed32` values.
message SFixed32Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MySFixed32 {
  //   // value must equal 42
  //   sfixed32 value = 1 [(buf.validate.field).sfixed32.const = 42];
  // }
  // ```
  optional sfixed32 const = 1 [(predefined).cel = {
    id: "sfixed32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed32 {
    //   // value must be less than 10
    //   sfixed32 value = 1 [(buf.validate.field).sfixed32.lt = 10];
    // }
    // ```
    sfixed32 lt = 2 [(predefined).cel = {
      id: "sfixed32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySFixed32 {
    //   // value must be less than or equal to 10
    //   sfixed32 value = 1 [(buf.validate.field).sfixed32.lte = 10];
    // }
    // ```
    sfixed32 lte = 3 [(predefined).cel = {
      id: "sfixed32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed32 {
    //   // value must be greater than 5 [sfixed32.gt]
    //   sfixed32 value = 1 [(buf.validate.field).sfixed32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [sfixed32.gt_lt]
    //   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [sfixed32.gt_lt_exclusive]
    //   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }];
    // }
    // ```
    sfixed32 gt = 4 [
      (predefined).cel = {
        id: "sfixed32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed32 {
    //   // value must be greater than or equal to 5 [sfixed32.gte]
    //   sfixed32 value = 1 [(buf.validate.field).sfixed32.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [sfixed32.gte_lt]
    //   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [sfixed32.gte_lt_exclusive]
    //   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }];
    // }
    // ```
    sfixed32 gte = 5 [
      (predefined).cel = {
        id: "sfixed32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MySFixed32 {
  //   // value must be in list [1, 2, 3]
  //   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated sfixed32 in = 6 [(predefined).cel = {
    id: "sfixed32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MySFixed32 {
  //   // value must not be in list [1, 2, 3]
  //   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated sfixed32 not_in = 7 [(predefined).cel = {
    id: "sfixed32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MySFixed32 {
  //   sfixed32 value = 1 [
  //     (buf.validate.field).sfixed32.example = 1,
  //     (buf.validate.field).sfixed32.example = 2
  //   ];
  // }
  // ```
  repeated sfixed32 example = 8 [(predefined).cel = {
    id: "sfixed32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// SFixed64Rules describes the rules applied to `fixed64` values.
message SFixed64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MySFixed64 {
  //   // value must equal 42
  //   sfixed64 value = 1 [(buf.validate.field).sfixed64.const = 42];
  // }
  // ```
  optional sfixed64 const = 1 [(predefined).cel = {
    id: "sfixed64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed64 {
    //   // value must be less than 10
    //   sfixed64 value = 1 [(buf.validate.field).sfixed64.lt = 10];
    // }
    // ```
    sfixed64 lt = 2 [(predefined).cel = {
      id: "sfixed64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySFixed64 {
    //   // value must be less than or equal to 10
    //   sfixed64 value = 1 [(buf.validate.field).sfixed64.lte = 10];
    // }
    // ```
    sfixed64 lte = 3 [(predefined).cel = {
      id: "sfixed64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed64 {
    //   // value must be greater than 5 [sfixed64.gt]
    //   sfixed64 value = 1 [(buf.validate.field).sfixed64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [sfixed64.gt_lt]
    //   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [sfixed64.gt_lt_exclusive]
    //   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }];
    // }
    // ```
    sfixed64 gt = 4 [
      (predefined).cel = {
        id: "sfixed64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed64 {
    //   // value must be greater than or equal to 5 [sfixed64.gte]
    //   sfixed64 value = 1 [(buf.validate.field).sfixed64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [sfixed64.gte_lt]
    //   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [sfixed64.gte_lt_exclusive]
    //   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }];
    // }
    // ```
    sfixed64 gte = 5 [
      (predefined).cel = {
        id: "sfixed64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MySFixed64 {
  //   // value must be in list [1, 2, 3]
  //   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated sfixed64 in = 6 [(predefined).cel = {
    id: "sfixed64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MySFixed64 {
  //   // value must not be in list [1, 2, 3]
  //   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated sfixed64 not_in = 7 [(predefined).cel = {
    id: "sfixed64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MySFixed64 {
  //   sfixed64 value = 1 [
  //     (buf.validate.field).sfixed64.example = 1,
  //     (buf.validate.field).sfixed64.example = 2
  //   ];
  // }
  // ```
  repeated sfixed64 example = 8 [(predefined).cel = {
    id: "sfixed64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// BoolRules describes the rules applied to `bool` values. These rules
// may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.
message BoolRules {
  // `const` requires the field value to exactly match the specified boolean value.
  // If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyBool {
  //   // value must equal true
  //   bool value = 1 [(buf.validate.field).bool.const = true];
  // }
  // ```
  optional bool const = 1 [(predefined).cel = {
    id: "bool.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyBool {
  //   bool value = 1 [
  //     (buf.validate.field).bool.example = 1,
  //     (buf.validate.field).bool.example = 2
  //   ];
  // }
  // ```
  repeated bool example = 2 [(predefined).cel = {
    id: "bool.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// StringRules describes the rules applied to `string` values These
// rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
message StringRules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyString {
  //   // value must equal `hello`
  //   string value = 1 [(buf.validate.field).string.const = "hello"];
  // }
  // ```
  optional string const = 1 [(predefined).cel = {
    id: "string.const"
    expression: "this != getField(rules, 'const') ? 'value must equal `%s`'.format([getField(rules, 'const')]) : ''"
  }];

  // `len` dictates that the field value must have the specified
  // number of characters (Unicode code points), which may differ from the number
  // of bytes in the string. If the field value does not meet the specified
  // length, an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be 5 characters
  //   string value = 1 [(buf.validate.field).string.len = 5];
  // }
  // ```
  optional uint64 len = 19 [(predefined).cel = {
    id: "string.len"
    expression: "uint(this.size()) != rules.len ? 'value length must be %s characters'.format([rules.len]) : ''"
  }];

  // `min_len` specifies that the field value must have at least the specified
  // number of characters (Unicode code points), which may differ from the number
  // of bytes in the string. If the field value contains fewer characters, an error
  // message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be at least 3 characters
  //   string value = 1 [(buf.validate.field).string.min_len = 3];
  // }
  // ```
  optional uint64 min_len = 2 [(predefined).cel = {
    id: "string.min_len"
    expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s characters'.format([rules.min_len]) : ''"
  }];

  // `max_len` specifies that the field value must have no more than the specified
  // number of characters (Unicode code points), which may differ from the
  // number of bytes in the string. If the field value contains more characters,
  // an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be at most 10 characters
  //   string value = 1 [(buf.validate.field).string.max_len = 10];
  // }
  // ```
  optional uint64 max_len = 3 [(predefined).cel = {
    id: "string.max_len"
    expression: "uint(this.size()) > rules.max_len ? 'value length must be at most %s characters'.format([rules.max_len]) : ''"
  }];

  // `len_bytes` dictates that the field value must have the specified number of
  // bytes. If the field value does not match the specified length in bytes,
  // an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be 6 bytes
  //   string value = 1 [(buf.validate.field).string.len_bytes = 6];
  // }
  // ```
  optional uint64 len_bytes = 20 [(predefined).cel = {
    id: "string.len_bytes"
    expression: "uint(bytes(this).size()) != rules.len_bytes ? 'value length must be %s bytes'.format([rules.len_bytes]) : ''"
  }];

  // `min_bytes` specifies that the field value must have at least the specified
  // number of bytes. If the field value contains fewer bytes, an error message
  // will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be at least 4 bytes
  //   string value = 1 [(buf.validate.field).string.min_bytes = 4];
  // }
  //
  // ```
  optional uint64 min_bytes = 4 [(predefined).cel = {
    id: "string.min_bytes"
    expression: "uint(bytes(this).size()) < rules.min_bytes ? 'value length must be at least %s bytes'.format([rules.min_bytes]) : ''"
  }];

  // `max_bytes` specifies that the field value must have no more than the
  //specified number of bytes. If the field value contains more bytes, an
  // error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be at most 8 bytes
  //   string value = 1 [(buf.validate.field).string.max_bytes = 8];
  // }
  // ```
  optional uint64 max_bytes = 5 [(predefined).cel = {
    id: "string.max_bytes"
    expression: "uint(bytes(this).size()) > rules.max_bytes ? 'value length must be at most %s bytes'.format([rules.max_bytes]) : ''"
  }];

  // `pattern` specifies that the field value must match the specified
  // regular expression (RE2 syntax), with the expression provided without any
  // delimiters. If the field value doesn't match the regular expression, an
  // error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value does not match regex pattern `^[a-zA-Z]//$`
  //   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
  // }
  // ```
  optional string pattern = 6 [(predefined).cel = {
    id: "string.pattern"
    expression: "!this.matches(rules.pattern) ? 'value does not match regex pattern `%s`'.format([rules.pattern]) : ''"
  }];

  // `prefix` specifies that the field value must have the
  //specified substring at the beginning of the string. If the field value
  // doesn't start with the specified prefix, an error message will be
  // generated.
  //
  // ```proto
  // message MyString {
  //   // value does not have prefix `pre`
  //   string value = 1 [(buf.validate.field).string.prefix = "pre"];
  // }
  // ```
  optional string prefix = 7 [(predefined).cel = {
    id: "string.prefix"
    expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix `%s`'.format([rules.prefix]) : ''"
  }];

  // `suffix` specifies that the field value must have the
  //specified substring at the end of the string. If the field value doesn't
  // end with the specified suffix, an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value does not have suffix `post`
  //   string value = 1 [(buf.validate.field).string.suffix = "post"];
  // }
  // ```
  optional string suffix = 8 [(predefined).cel = {
    id: "string.suffix"
    expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix `%s`'.format([rules.suffix]) : ''"
  }];

  // `contains` specifies that the field value must have the
  //specified substring anywhere in the string. If the field value doesn't
  // contain the specified substring, an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value does not contain substring `inside`.
  //   string value = 1 [(buf.validate.field).string.contains = "inside"];
  // }
  // ```
  optional string contains = 9 [(predefined).cel = {
    id: "string.contains"
    expression: "!this.contains(rules.contains) ? 'value does not contain substring `%s`'.format([rules.contains]) : ''"
  }];

  // `not_contains` specifies that the field value must not have the
  //specified substring anywhere in the string. If the field value contains
  // the specified substring, an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value contains substring `inside`.
  //   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
  // }
  // ```
  optional string not_contains = 23 [(predefined).cel = {
    id: "string.not_contains"
    expression: "this.contains(rules.not_contains) ? 'value contains substring `%s`'.format([rules.not_contains]) : ''"
  }];

  // `in` specifies that the field value must be equal to one of the specified
  // values. If the field value isn't one of the specified values, an error
  // message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value must be in list ["apple", "banana"]
  //   string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
  // }
  // ```
  repeated string in = 10 [(predefined).cel = {
    id: "string.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` specifies that the field value cannot be equal to any
  // of the specified values. If the field value is one of the specified values,
  // an error message will be generated.
  // ```proto
  // message MyString {
  //   // value must not be in list ["orange", "grape"]
  //   string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
  // }
  // ```
  repeated string not_in = 11 [(predefined).cel = {
    id: "string.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `WellKnown` rules provide advanced rules against common string
  // patterns.
  oneof well_known {
    // `email` specifies that the field value must be a valid email address, for
    // example "foo@example.com".
    //
    // Conforms to the definition for a valid email address from the [HTML standard](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address).
    // Note that this standard willfully deviates from [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322),
    // which allows many unexpected forms of email addresses and will easily match
    // a typographical error.
    //
    // If the field value isn't a valid email address, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid email address
    //   string value = 1 [(buf.validate.field).string.email = true];
    // }
    // ```
    bool email = 12 [
      (predefined).cel = {
        id: "string.email"
        message: "value must be a valid email address"
        expression: "!rules.email || this == '' || this.isEmail()"
      },
      (predefined).cel = {
        id: "string.email_empty"
        message: "value is empty, which is not a valid email address"
        expression: "!rules.email || this != ''"
      }
    ];

    // `hostname` specifies that the field value must be a valid hostname, for
    // example "foo.example.com".
    //
    // A valid hostname follows the rules below:
    // - The name consists of one or more labels, separated by a dot (".").
    // - Each label can be 1 to 63 alphanumeric characters.
    // - A label can contain hyphens ("-"), but must not start or end with a hyphen.
    // - The right-most label must not be digits only.
    // - The name can have a trailing dotfor example, "foo.example.com.".
    // - The name can be 253 characters at most, excluding the optional trailing dot.
    //
    // If the field value isn't a valid hostname, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid hostname
    //   string value = 1 [(buf.validate.field).string.hostname = true];
    // }
    // ```
    bool hostname = 13 [
      (predefined).cel = {
        id: "string.hostname"
        message: "value must be a valid hostname"
        expression: "!rules.hostname || this == '' || this.isHostname()"
      },
      (predefined).cel = {
        id: "string.hostname_empty"
        message: "value is empty, which is not a valid hostname"
        expression: "!rules.hostname || this != ''"
      }
    ];

    // `ip` specifies that the field value must be a valid IP (v4 or v6) address.
    //
    // IPv4 addresses are expected in the dotted decimal formatfor example, "192.168.5.21".
    // IPv6 addresses are expected in their text representationfor example, "::1",
    // or "2001:0DB8:ABCD:0012::0".
    //
    // Both formats are well-defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
    // Zone identifiers for IPv6 addresses (for example, "fe80::a%en1") are supported.
    //
    // If the field value isn't a valid IP address, an error message will be
    // generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IP address
    //   string value = 1 [(buf.validate.field).string.ip = true];
    // }
    // ```
    bool ip = 14 [
      (predefined).cel = {
        id: "string.ip"
        message: "value must be a valid IP address"
        expression: "!rules.ip || this == '' || this.isIp()"
      },
      (predefined).cel = {
        id: "string.ip_empty"
        message: "value is empty, which is not a valid IP address"
        expression: "!rules.ip || this != ''"
      }
    ];

    // `ipv4` specifies that the field value must be a valid IPv4 addressfor
    // example "192.168.5.21". If the field value isn't a valid IPv4 address, an
    // error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv4 address
    //   string value = 1 [(buf.validate.field).string.ipv4 = true];
    // }
    // ```
    bool ipv4 = 15 [
      (predefined).cel = {
        id: "string.ipv4"
        message: "value must be a valid IPv4 address"
        expression: "!rules.ipv4 || this == '' || this.isIp(4)"
      },
      (predefined).cel = {
        id: "string.ipv4_empty"
        message: "value is empty, which is not a valid IPv4 address"
        expression: "!rules.ipv4 || this != ''"
      }
    ];

    // `ipv6` specifies that the field value must be a valid IPv6 addressfor
    // example "::1", or "d7a:115c:a1e0:ab12:4843:cd96:626b:430b". If the field
    // value is not a valid IPv6 address, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv6 address
    //   string value = 1 [(buf.validate.field).string.ipv6 = true];
    // }
    // ```
    bool ipv6 = 16 [
      (predefined).cel = {
        id: "string.ipv6"
        message: "value must be a valid IPv6 address"
        expression: "!rules.ipv6 || this == '' || this.isIp(6)"
      },
      (predefined).cel = {
        id: "string.ipv6_empty"
        message: "value is empty, which is not a valid IPv6 address"
        expression: "!rules.ipv6 || this != ''"
      }
    ];

    // `uri` specifies that the field value must be a valid URI, for example
    // "https://example.com/foo/bar?baz=quux#frag".
    //
    // URI is defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
    // Zone Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
    //
    // If the field value isn't a valid URI, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid URI
    //   string value = 1 [(buf.validate.field).string.uri = true];
    // }
    // ```
    bool uri = 17 [
      (predefined).cel = {
        id: "string.uri"
        message: "value must be a valid URI"
        expression: "!rules.uri || this == '' || this.isUri()"
      },
      (predefined).cel = {
        id: "string.uri_empty"
        message: "value is empty, which is not a valid URI"
        expression: "!rules.uri || this != ''"
      }
    ];

    // `uri_ref` specifies that the field value must be a valid URI Referenceeither
    // a URI such as "https://example.com/foo/bar?baz=quux#frag", or a Relative
    // Reference such as "./foo/bar?query".
    //
    // URI, URI Reference, and Relative Reference are defined in the internet
    // standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986). Zone
    // Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
    //
    // If the field value isn't a valid URI Reference, an error message will be
    // generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid URI Reference
    //   string value = 1 [(buf.validate.field).string.uri_ref = true];
    // }
    // ```
    bool uri_ref = 18 [(predefined).cel = {
      id: "string.uri_ref"
      message: "value must be a valid URI Reference"
      expression: "!rules.uri_ref || this.isUriRef()"
    }];

    // `address` specifies that the field value must be either a valid hostname
    // (for example, "example.com"), or a valid IP (v4 or v6) address (for example,
    // "192.168.0.1", or "::1"). If the field value isn't a valid hostname or IP,
    // an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid hostname, or ip address
    //   string value = 1 [(buf.validate.field).string.address = true];
    // }
    // ```
    bool address = 21 [
      (predefined).cel = {
        id: "string.address"
        message: "value must be a valid hostname, or ip address"
        expression: "!rules.address || this == '' || this.isHostname() || this.isIp()"
      },
      (predefined).cel = {
        id: "string.address_empty"
        message: "value is empty, which is not a valid hostname, or ip address"
        expression: "!rules.address || this != ''"
      }
    ];

    // `uuid` specifies that the field value must be a valid UUID as defined by
    // [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2). If the
    // field value isn't a valid UUID, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid UUID
    //   string value = 1 [(buf.validate.field).string.uuid = true];
    // }
    // ```
    bool uuid = 22 [
      (predefined).cel = {
        id: "string.uuid"
        message: "value must be a valid UUID"
        expression: "!rules.uuid || this == '' || this.matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')"
      },
      (predefined).cel = {
        id: "string.uuid_empty"
        message: "value is empty, which is not a valid UUID"
        expression: "!rules.uuid || this != ''"
      }
    ];

    // `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
    // defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2) with all dashes
    // omitted. If the field value isn't a valid UUID without dashes, an error message
    // will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid trimmed UUID
    //   string value = 1 [(buf.validate.field).string.tuuid = true];
    // }
    // ```
    bool tuuid = 33 [
      (predefined).cel = {
        id: "string.tuuid"
        message: "value must be a valid trimmed UUID"
        expression: "!rules.tuuid || this == '' || this.matches('^[0-9a-fA-F]{32}$')"
      },
      (predefined).cel = {
        id: "string.tuuid_empty"
        message: "value is empty, which is not a valid trimmed UUID"
        expression: "!rules.tuuid || this != ''"
      }
    ];

    // `ip_with_prefixlen` specifies that the field value must be a valid IP
    // (v4 or v6) address with prefix lengthfor example, "192.168.5.21/16" or
    // "2001:0DB8:ABCD:0012::F1/64". If the field value isn't a valid IP with
    // prefix length, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IP with prefix length
    //    string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];
    // }
    // ```
    bool ip_with_prefixlen = 26 [
      (predefined).cel = {
        id: "string.ip_with_prefixlen"
        message: "value must be a valid IP prefix"
        expression: "!rules.ip_with_prefixlen || this == '' || this.isIpPrefix()"
      },
      (predefined).cel = {
        id: "string.ip_with_prefixlen_empty"
        message: "value is empty, which is not a valid IP prefix"
        expression: "!rules.ip_with_prefixlen || this != ''"
      }
    ];

    // `ipv4_with_prefixlen` specifies that the field value must be a valid
    // IPv4 address with prefix lengthfor example, "192.168.5.21/16". If the
    // field value isn't a valid IPv4 address with prefix length, an error
    // message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv4 address with prefix length
    //    string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];
    // }
    // ```
    bool ipv4_with_prefixlen = 27 [
      (predefined).cel = {
        id: "string.ipv4_with_prefixlen"
        message: "value must be a valid IPv4 address with prefix length"
        expression: "!rules.ipv4_with_prefixlen || this == '' || this.isIpPrefix(4)"
      },
      (predefined).cel = {
        id: "string.ipv4_with_prefixlen_empty"
        message: "value is empty, which is not a valid IPv4 address with prefix length"
        expression: "!rules.ipv4_with_prefixlen || this != ''"
      }
    ];

    // `ipv6_with_prefixlen` specifies that the field value must be a valid
    // IPv6 address with prefix lengthfor example, "2001:0DB8:ABCD:0012::F1/64".
    // If the field value is not a valid IPv6 address with prefix length,
    // an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv6 address prefix length
    //    string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];
    // }
    // ```
    bool ipv6_with_prefixlen = 28 [
      (predefined).cel = {
        id: "string.ipv6_with_prefixlen"
        message: "value must be a valid IPv6 address with prefix length"
        expression: "!rules.ipv6_with_prefixlen || this == '' || this.isIpPrefix(6)"
      },
      (predefined).cel = {
        id: "string.ipv6_with_prefixlen_empty"
        message: "value is empty, which is not a valid IPv6 address with prefix length"
        expression: "!rules.ipv6_with_prefixlen || this != ''"
      }
    ];

    // `ip_prefix` specifies that the field value must be a valid IP (v4 or v6)
    // prefixfor example, "192.168.0.0/16" or "2001:0DB8:ABCD:0012::0/64".
    //
    // The prefix must have all zeros for the unmasked bits. For example,
    // "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
    // prefix, and the remaining 64 bits must be zero.
    //
    // If the field value isn't a valid IP prefix, an error message will be
    // generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IP prefix
    //    string value = 1 [(buf.validate.field).string.ip_prefix = true];
    // }
    // ```
    bool ip_prefix = 29 [
      (predefined).cel = {
        id: "string.ip_prefix"
        message: "value must be a valid IP prefix"
        expression: "!rules.ip_prefix || this == '' || this.isIpPrefix(true)"
      },
      (predefined).cel = {
        id: "string.ip_prefix_empty"
        message: "value is empty, which is not a valid IP prefix"
        expression: "!rules.ip_prefix || this != ''"
      }
    ];

    // `ipv4_prefix` specifies that the field value must be a valid IPv4
    // prefix, for example "192.168.0.0/16".
    //
    // The prefix must have all zeros for the unmasked bits. For example,
    // "192.168.0.0/16" designates the left-most 16 bits for the prefix,
    // and the remaining 16 bits must be zero.
    //
    // If the field value isn't a valid IPv4 prefix, an error message
    // will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv4 prefix
    //    string value = 1 [(buf.validate.field).string.ipv4_prefix = true];
    // }
    // ```
    bool ipv4_prefix = 30 [
      (predefined).cel = {
        id: "string.ipv4_prefix"
        message: "value must be a valid IPv4 prefix"
        expression: "!rules.ipv4_prefix || this == '' || this.isIpPrefix(4, true)"
      },
      (predefined).cel = {
        id: "string.ipv4_prefix_empty"
        message: "value is empty, which is not a valid IPv4 prefix"
        expression: "!rules.ipv4_prefix || this != ''"
      }
    ];

    // `ipv6_prefix` specifies that the field value must be a valid IPv6 prefixfor
    // example, "2001:0DB8:ABCD:0012::0/64".
    //
    // The prefix must have all zeros for the unmasked bits. For example,
    // "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
    // prefix, and the remaining 64 bits must be zero.
    //
    // If the field value is not a valid IPv6 prefix, an error message will be
    // generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv6 prefix
    //    string value = 1 [(buf.validate.field).string.ipv6_prefix = true];
    // }
    // ```
    bool ipv6_prefix = 31 [
      (predefined).cel = {
        id: "string.ipv6_prefix"
        message: "value must be a valid IPv6 prefix"
        expression: "!rules.ipv6_prefix || this == '' || this.isIpPrefix(6, true)"
      },
      (predefined).cel = {
        id: "string.ipv6_prefix_empty"
        message: "value is empty, which is not a valid IPv6 prefix"
        expression: "!rules.ipv6_prefix || this != ''"
      }
    ];

    // `host_and_port` specifies that the field value must be valid host/port
    // pairfor example, "example.com:8080".
    //
    // The host can be one of:
    //- An IPv4 address in dotted decimal formatfor example, "192.168.5.21".
    //- An IPv6 address enclosed in square bracketsfor example, "[2001:0DB8:ABCD:0012::F1]".
    //- A hostnamefor example, "example.com".
    //
    // The port is separated by a colon. It must be non-empty, with a decimal number
    // in the range of 0-65535, inclusive.
    bool host_and_port = 32 [
      (predefined).cel = {
        id: "string.host_and_port"
        message: "value must be a valid host (hostname or IP address) and port pair"
        expression: "!rules.host_and_port || this == '' || this.isHostAndPort(true)"
      },
      (predefined).cel = {
        id: "string.host_and_port_empty"
        message: "value is empty, which is not a valid host and port pair"
        expression: "!rules.host_and_port || this != ''"
      }
    ];

    // `well_known_regex` specifies a common well-known pattern
    // defined as a regex. If the field value doesn't match the well-known
    // regex, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid HTTP header value
    //   string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];
    // }
    // ```
    //
    // #### KnownRegex
    //
    // `well_known_regex` contains some well-known patterns.
    //
    // | Name                          | Number | Description                               |
    // |-------------------------------|--------|-------------------------------------------|
    // | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
    // | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2)  |
    // | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4) |
    KnownRegex well_known_regex = 24 [
      (predefined).cel = {
        id: "string.well_known_regex.header_name"
        message: "value must be a valid HTTP header name"
        expression:
          "rules.well_known_regex != 1 || this == '' || this.matches(!has(rules.strict) || rules.strict ?"
          "'^:?[0-9a-zA-Z!#$%&\\'*+-.^_|~\\x60]+$' :"
          "'^[^\\u0000\\u000A\\u000D]+$')"
      },
      (predefined).cel = {
        id: "string.well_known_regex.header_name_empty"
        message: "value is empty, which is not a valid HTTP header name"
        expression: "rules.well_known_regex != 1 || this != ''"
      },
      (predefined).cel = {
        id: "string.well_known_regex.header_value"
        message: "value must be a valid HTTP header value"
        expression:
          "rules.well_known_regex != 2 || this.matches(!has(rules.strict) || rules.strict ?"
          "'^[^\\u0000-\\u0008\\u000A-\\u001F\\u007F]*$' :"
          "'^[^\\u0000\\u000A\\u000D]*$')"
      }
    ];
  }

  // This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
  // enable strict header validation. By default, this is true, and HTTP header
  // validations are [RFC-compliant](https://datatracker.ietf.org/doc/html/rfc7230#section-3). Setting to false will enable looser
  // validations that only disallow `\r\n\0` characters, which can be used to
  // bypass header matching rules.
  //
  // ```proto
  // message MyString {
  //   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
  //   string value = 1 [(buf.validate.field).string.strict = false];
  // }
  // ```
  optional bool strict = 25;

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyString {
  //   string value = 1 [
  //     (buf.validate.field).string.example = "hello",
  //     (buf.validate.field).string.example = "world"
  //   ];
  // }
  // ```
  repeated string example = 34 [(predefined).cel = {
    id: "string.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// KnownRegex contains some well-known patterns.
enum KnownRegex {
  KNOWN_REGEX_UNSPECIFIED = 0;

  // HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2).
  KNOWN_REGEX_HTTP_HEADER_NAME = 1;

  // HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4).
  KNOWN_REGEX_HTTP_HEADER_VALUE = 2;
}

// BytesRules describe the rules applied to `bytes` values. These rules
// may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.
message BytesRules {
  // `const` requires the field value to exactly match the specified bytes
  // value. If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must be "\x01\x02\x03\x04"
  //   bytes value = 1 [(buf.validate.field).bytes.const = "\x01\x02\x03\x04"];
  // }
  // ```
  optional bytes const = 1 [(predefined).cel = {
    id: "bytes.const"
    expression: "this != getField(rules, 'const') ? 'value must be %x'.format([getField(rules, 'const')]) : ''"
  }];

  // `len` requires the field value to have the specified length in bytes.
  // If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value length must be 4 bytes.
  //   optional bytes value = 1 [(buf.validate.field).bytes.len = 4];
  // }
  // ```
  optional uint64 len = 13 [(predefined).cel = {
    id: "bytes.len"
    expression: "uint(this.size()) != rules.len ? 'value length must be %s bytes'.format([rules.len]) : ''"
  }];

  // `min_len` requires the field value to have at least the specified minimum
  // length in bytes.
  // If the field value doesn't meet the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value length must be at least 2 bytes.
  //   optional bytes value = 1 [(buf.validate.field).bytes.min_len = 2];
  // }
  // ```
  optional uint64 min_len = 2 [(predefined).cel = {
    id: "bytes.min_len"
    expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s bytes'.format([rules.min_len]) : ''"
  }];

  // `max_len` requires the field value to have at most the specified maximum
  // length in bytes.
  // If the field value exceeds the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must be at most 6 bytes.
  //   optional bytes value = 1 [(buf.validate.field).bytes.max_len = 6];
  // }
  // ```
  optional uint64 max_len = 3 [(predefined).cel = {
    id: "bytes.max_len"
    expression: "uint(this.size()) > rules.max_len ? 'value must be at most %s bytes'.format([rules.max_len]) : ''"
  }];

  // `pattern` requires the field value to match the specified regular
  // expression ([RE2 syntax](https://github.com/google/re2/wiki/Syntax)).
  // The value of the field must be valid UTF-8 or validation will fail with a
  // runtime error.
  // If the field value doesn't match the pattern, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must match regex pattern "^[a-zA-Z0-9]+$".
  //   optional bytes value = 1 [(buf.validate.field).bytes.pattern = "^[a-zA-Z0-9]+$"];
  // }
  // ```
  optional string pattern = 4 [(predefined).cel = {
    id: "bytes.pattern"
    expression: "!string(this).matches(rules.pattern) ? 'value must match regex pattern `%s`'.format([rules.pattern]) : ''"
  }];

  // `prefix` requires the field value to have the specified bytes at the
  // beginning of the string.
  // If the field value doesn't meet the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value does not have prefix \x01\x02
  //   optional bytes value = 1 [(buf.validate.field).bytes.prefix = "\x01\x02"];
  // }
  // ```
  optional bytes prefix = 5 [(predefined).cel = {
    id: "bytes.prefix"
    expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix %x'.format([rules.prefix]) : ''"
  }];

  // `suffix` requires the field value to have the specified bytes at the end
  // of the string.
  // If the field value doesn't meet the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value does not have suffix \x03\x04
  //   optional bytes value = 1 [(buf.validate.field).bytes.suffix = "\x03\x04"];
  // }
  // ```
  optional bytes suffix = 6 [(predefined).cel = {
    id: "bytes.suffix"
    expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix %x'.format([rules.suffix]) : ''"
  }];

  // `contains` requires the field value to have the specified bytes anywhere in
  // the string.
  // If the field value doesn't meet the requirement, an error message is generated.
  //
  // ```protobuf
  // message MyBytes {
  //   // value does not contain \x02\x03
  //   optional bytes value = 1 [(buf.validate.field).bytes.contains = "\x02\x03"];
  // }
  // ```
  optional bytes contains = 7 [(predefined).cel = {
    id: "bytes.contains"
    expression: "!this.contains(rules.contains) ? 'value does not contain %x'.format([rules.contains]) : ''"
  }];

  // `in` requires the field value to be equal to one of the specified
  // values. If the field value doesn't match any of the specified values, an
  // error message is generated.
  //
  // ```protobuf
  // message MyBytes {
  //   // value must in ["\x01\x02", "\x02\x03", "\x03\x04"]
  //   optional bytes value = 1 [(buf.validate.field).bytes.in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
  // }
  // ```
  repeated bytes in = 8 [(predefined).cel = {
    id: "bytes.in"
    expression: "getField(rules, 'in').size() > 0 && !(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to be not equal to any of the specified
  // values.
  // If the field value matches any of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must not in ["\x01\x02", "\x02\x03", "\x03\x04"]
  //   optional bytes value = 1 [(buf.validate.field).bytes.not_in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
  // }
  // ```
  repeated bytes not_in = 9 [(predefined).cel = {
    id: "bytes.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // WellKnown rules provide advanced rules against common byte
  // patterns
  oneof well_known {
    // `ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.
    // If the field value doesn't meet this rule, an error message is generated.
    //
    // ```proto
    // message MyBytes {
    //   // value must be a valid IP address
    //   optional bytes value = 1 [(buf.validate.field).bytes.ip = true];
    // }
    // ```
    bool ip = 10 [
      (predefined).cel = {
        id: "bytes.ip"
        message: "value must be a valid IP address"
        expression: "!rules.ip || this.size() == 0 || this.size() == 4 || this.size() == 16"
      },
      (predefined).cel = {
        id: "bytes.ip_empty"
        message: "value is empty, which is not a valid IP address"
        expression: "!rules.ip || this.size() != 0"
      }
    ];

    // `ipv4` ensures that the field `value` is a valid IPv4 address in byte format.
    // If the field value doesn't meet this rule, an error message is generated.
    //
    // ```proto
    // message MyBytes {
    //   // value must be a valid IPv4 address
    //   optional bytes value = 1 [(buf.validate.field).bytes.ipv4 = true];
    // }
    // ```
    bool ipv4 = 11 [
      (predefined).cel = {
        id: "bytes.ipv4"
        message: "value must be a valid IPv4 address"
        expression: "!rules.ipv4 || this.size() == 0 || this.size() == 4"
      },
      (predefined).cel = {
        id: "bytes.ipv4_empty"
        message: "value is empty, which is not a valid IPv4 address"
        expression: "!rules.ipv4 || this.size() != 0"
      }
    ];

    // `ipv6` ensures that the field `value` is a valid IPv6 address in byte format.
    // If the field value doesn't meet this rule, an error message is generated.
    // ```proto
    // message MyBytes {
    //   // value must be a valid IPv6 address
    //   optional bytes value = 1 [(buf.validate.field).bytes.ipv6 = true];
    // }
    // ```
    bool ipv6 = 12 [
      (predefined).cel = {
        id: "bytes.ipv6"
        message: "value must be a valid IPv6 address"
        expression: "!rules.ipv6 || this.size() == 0 || this.size() == 16"
      },
      (predefined).cel = {
        id: "bytes.ipv6_empty"
        message: "value is empty, which is not a valid IPv6 address"
        expression: "!rules.ipv6 || this.size() != 0"
      }
    ];
  }

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyBytes {
  //   bytes value = 1 [
  //     (buf.validate.field).bytes.example = "\x01\x02",
  //     (buf.validate.field).bytes.example = "\x02\x03"
  //   ];
  // }
  // ```
  repeated bytes example = 14 [(predefined).cel = {
    id: "bytes.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// EnumRules describe the rules applied to `enum` values.
message EnumRules {
  // `const` requires the field value to exactly match the specified enum value.
  // If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //   // The field `value` must be exactly MY_ENUM_VALUE1.
  //   MyEnum value = 1 [(buf.validate.field).enum.const = 1];
  // }
  // ```
  optional int32 const = 1 [(predefined).cel = {
    id: "enum.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];

  // `defined_only` requires the field value to be one of the defined values for
  // this enum, failing on any undefined value.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //   // The field `value` must be a defined value of MyEnum.
  //   MyEnum value = 1 [(buf.validate.field).enum.defined_only = true];
  // }
  // ```
  optional bool defined_only = 2;

  // `in` requires the field value to be equal to one of the
  //specified enum values. If the field value doesn't match any of the
  //specified values, an error message is generated.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //   // The field `value` must be equal to one of the specified values.
  //   MyEnum value = 1 [(buf.validate.field).enum = { in: [1, 2]}];
  // }
  // ```
  repeated int32 in = 3 [(predefined).cel = {
    id: "enum.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to be not equal to any of the
  //specified enum values. If the field value matches one of the specified
  // values, an error message is generated.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //   // The field `value` must not be equal to any of the specified values.
  //   MyEnum value = 1 [(buf.validate.field).enum = { not_in: [1, 2]}];
  // }
  // ```
  repeated int32 not_in = 4 [(predefined).cel = {
    id: "enum.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //     (buf.validate.field).enum.example = 1,
  //     (buf.validate.field).enum.example = 2
  // }
  // ```
  repeated int32 example = 5 [(predefined).cel = {
    id: "enum.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// RepeatedRules describe the rules applied to `repeated` values.
message RepeatedRules {
  // `min_items` requires that this field must contain at least the specified
  // minimum number of items.
  //
  // Note that `min_items = 1` is equivalent to setting a field as `required`.
  //
  // ```proto
  // message MyRepeated {
  //   // value must contain at least  2 items
  //   repeated string value = 1 [(buf.validate.field).repeated.min_items = 2];
  // }
  // ```
  optional uint64 min_items = 1 [(predefined).cel = {
    id: "repeated.min_items"
    expression: "uint(this.size()) < rules.min_items ? 'value must contain at least %d item(s)'.format([rules.min_items]) : ''"
  }];

  // `max_items` denotes that this field must not exceed a
  // certain number of items as the upper limit. If the field contains more
  // items than specified, an error message will be generated, requiring the
  // field to maintain no more than the specified number of items.
  //
  // ```proto
  // message MyRepeated {
  //   // value must contain no more than 3 item(s)
  //   repeated string value = 1 [(buf.validate.field).repeated.max_items = 3];
  // }
  // ```
  optional uint64 max_items = 2 [(predefined).cel = {
    id: "repeated.max_items"
    expression: "uint(this.size()) > rules.max_items ? 'value must contain no more than %s item(s)'.format([rules.max_items]) : ''"
  }];

  // `unique` indicates that all elements in this field must
  // be unique. This rule is strictly applicable to scalar and enum
  // types, with message types not being supported.
  //
  // ```proto
  // message MyRepeated {
  //   // repeated value must contain unique items
  //   repeated string value = 1 [(buf.validate.field).repeated.unique = true];
  // }
  // ```
  optional bool unique = 3 [(predefined).cel = {
    id: "repeated.unique"
    message: "repeated value must contain unique items"
    expression: "!rules.unique || this.unique()"
  }];

  // `items` details the rules to be applied to each item
  // in the field. Even for repeated message fields, validation is executed
  // against each item unless `ignore` is specified.
  //
  // ```proto
  // message MyRepeated {
  //   // The items in the field `value` must follow the specified rules.
  //   repeated string value = 1 [(buf.validate.field).repeated.items = {
  //     string: {
  //       min_len: 3
  //       max_len: 10
  //     }
  //   }];
  // }
  // ```
  //
  // Note that the `required` rule does not apply. Repeated items
  // cannot be unset.
  optional FieldRules items = 4;

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// MapRules describe the rules applied to `map` values.
message MapRules {
  // Specifies the minimum number of key-value pairs allowed. If the field has
  // fewer key-value pairs than specified, an error message is generated.
  //
  // ```proto
  // message MyMap {
  //   // The field `value` must have at least 2 key-value pairs.
  //   map<string, string> value = 1 [(buf.validate.field).map.min_pairs = 2];
  // }
  // ```
  optional uint64 min_pairs = 1 [(predefined).cel = {
    id: "map.min_pairs"
    expression: "uint(this.size()) < rules.min_pairs ? 'map must be at least %d entries'.format([rules.min_pairs]) : ''"
  }];

  // Specifies the maximum number of key-value pairs allowed. If the field has
  // more key-value pairs than specified, an error message is generated.
  //
  // ```proto
  // message MyMap {
  //   // The field `value` must have at most 3 key-value pairs.
  //   map<string, string> value = 1 [(buf.validate.field).map.max_pairs = 3];
  // }
  // ```
  optional uint64 max_pairs = 2 [(predefined).cel = {
    id: "map.max_pairs"
    expression: "uint(this.size()) > rules.max_pairs ? 'map must be at most %d entries'.format([rules.max_pairs]) : ''"
  }];

  // Specifies the rules to be applied to each key in the field.
  //
  // ```proto
  // message MyMap {
  //   // The keys in the field `value` must follow the specified rules.
  //   map<string, string> value = 1 [(buf.validate.field).map.keys = {
  //     string: {
  //       min_len: 3
  //       max_len: 10
  //     }
  //   }];
  // }
  // ```
  //
  // Note that the `required` rule does not apply. Map keys cannot be unset.
  optional FieldRules keys = 4;

  // Specifies the rules to be applied to the value of each key in the
  // field. Message values will still have their validations evaluated unless
  // `ignore` is specified.
  //
  // ```proto
  // message MyMap {
  //   // The values in the field `value` must follow the specified rules.
  //   map<string, string> value = 1 [(buf.validate.field).map.values = {
  //     string: {
  //       min_len: 5
  //       max_len: 20
  //     }
  //   }];
  // }
  // ```
  // Note that the `required` rule does not apply. Map values cannot be unset.
  optional FieldRules values = 5;

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// AnyRules describe rules applied exclusively to the `google.protobuf.Any` well-known type.
message AnyRules {
  // `in` requires the field's `type_url` to be equal to one of the
  //specified values. If it doesn't match any of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyAny {
  //   //  The `value` field must have a `type_url` equal to one of the specified values.
  //   google.protobuf.Any value = 1 [(buf.validate.field).any = {
  //       in: ["type.googleapis.com/MyType1", "type.googleapis.com/MyType2"]
  //   }];
  // }
  // ```
  repeated string in = 2;

  // requires the field's type_url to be not equal to any of the specified values. If it matches any of the specified values, an error message is generated.
  //
  // ```proto
  // message MyAny {
  //   //  The `value` field must not have a `type_url` equal to any of the specified values.
  //   google.protobuf.Any value = 1 [(buf.validate.field).any = {
  //       not_in: ["type.googleapis.com/ForbiddenType1", "type.googleapis.com/ForbiddenType2"]
  //   }];
  // }
  // ```
  repeated string not_in = 3;
}

// DurationRules describe the rules applied exclusively to the `google.protobuf.Duration` well-known type.
message DurationRules {
  // `const` dictates that the field must match the specified value of the `google.protobuf.Duration` type exactly.
  // If the field's value deviates from the specified value, an error message
  // will be generated.
  //
  // ```proto
  // message MyDuration {
  //   // value must equal 5s
  //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.const = "5s"];
  // }
  // ```
  optional google.protobuf.Duration const = 2 [(predefined).cel = {
    id: "duration.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` stipulates that the field must be less than the specified value of the `google.protobuf.Duration` type,
    // exclusive. If the field's value is greater than or equal to the specified
    // value, an error message will be generated.
    //
    // ```proto
    // message MyDuration {
    //   // value must be less than 5s
    //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = "5s"];
    // }
    // ```
    google.protobuf.Duration lt = 3 [(predefined).cel = {
      id: "duration.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` indicates that the field must be less than or equal to the specified
    // value of the `google.protobuf.Duration` type, inclusive. If the field's value is greater than the specified value,
    // an error message will be generated.
    //
    // ```proto
    // message MyDuration {
    //   // value must be less than or equal to 10s
    //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lte = "10s"];
    // }
    // ```
    google.protobuf.Duration lte = 4 [(predefined).cel = {
      id: "duration.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the duration field value to be greater than the specified
    // value (exclusive). If the value of `gt` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyDuration {
    //   // duration must be greater than 5s [duration.gt]
    //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.gt = { seconds: 5 }];
    //
    //   // duration must be greater than 5s and less than 10s [duration.gt_lt]
    //   google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gt: { seconds: 5 }, lt: { seconds: 10 } }];
    //
    //   // duration must be greater than 10s or less than 5s [duration.gt_lt_exclusive]
    //   google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gt: { seconds: 10 }, lt: { seconds: 5 } }];
    // }
    // ```
    google.protobuf.Duration gt = 5 [
      (predefined).cel = {
        id: "duration.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "duration.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the duration field value to be greater than or equal to the
    // specified value (exclusive). If the value of `gte` is larger than a
    // specified `lt` or `lte`, the range is reversed, and the field value must
    // be outside the specified range. If the field value doesn't meet the
    // required conditions, an error message is generated.
    //
    // ```proto
    // message MyDuration {
    //  // duration must be greater than or equal to 5s [duration.gte]
    //  google.protobuf.Duration value = 1 [(buf.validate.field).duration.gte = { seconds: 5 }];
    //
    //  // duration must be greater than or equal to 5s and less than 10s [duration.gte_lt]
    //  google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gte: { seconds: 5 }, lt: { seconds: 10 } }];
    //
    //  // duration must be greater than or equal to 10s or less than 5s [duration.gte_lt_exclusive]
    //  google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gte: { seconds: 10 }, lt: { seconds: 5 } }];
    // }
    // ```
    google.protobuf.Duration gte = 6 [
      (predefined).cel = {
        id: "duration.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "duration.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "duration.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` asserts that the field must be equal to one of the specified values of the `google.protobuf.Duration` type.
  // If the field's value doesn't correspond to any of the specified values,
  // an error message will be generated.
  //
  // ```proto
  // message MyDuration {
  //   // value must be in list [1s, 2s, 3s]
  //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.in = ["1s", "2s", "3s"]];
  // }
  // ```
  repeated google.protobuf.Duration in = 7 [(predefined).cel = {
    id: "duration.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` denotes that the field must not be equal to
  // any of the specified values of the `google.protobuf.Duration` type.
  // If the field's value matches any of these values, an error message will be
  // generated.
  //
  // ```proto
  // message MyDuration {
  //   // value must not be in list [1s, 2s, 3s]
  //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.not_in = ["1s", "2s", "3s"]];
  // }
  // ```
  repeated google.protobuf.Duration not_in = 8 [(predefined).cel = {
    id: "duration.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyDuration {
  //   google.protobuf.Duration value = 1 [
  //     (buf.validate.field).duration.example = { seconds: 1 },
  //     (buf.validate.field).duration.example = { seconds: 2 },
  //   ];
  // }
  // ```
  repeated google.protobuf.Duration example = 9 [(predefined).cel = {
    id: "duration.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// TimestampRules describe the rules applied exclusively to the `google.protobuf.Timestamp` well-known type.
message TimestampRules {
  // `const` dictates that this field, of the `google.protobuf.Timestamp` type, must exactly match the specified value. If the field value doesn't correspond to the specified timestamp, an error message will be generated.
  //
  // ```proto
  // message MyTimestamp {
  //   // value must equal 2023-05-03T10:00:00Z
  //   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.const = {seconds: 1727998800}];
  // }
  // ```
  optional google.protobuf.Timestamp const = 2 [(predefined).cel = {
    id: "timestamp.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // requires the duration field value to be less than the specified value (field < value). If the field value doesn't meet the required conditions, an error message is generated.
    //
    // ```proto
    // message MyDuration {
    //   // duration must be less than 'P3D' [duration.lt]
    //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = { seconds: 259200 }];
    // }
    // ```
    google.protobuf.Timestamp lt = 3 [(predefined).cel = {
      id: "timestamp.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // requires the timestamp field value to be less than or equal to the specified value (field <= value). If the field value doesn't meet the required conditions, an error message is generated.
    //
    // ```proto
    // message MyTimestamp {
    //   // timestamp must be less than or equal to '2023-05-14T00:00:00Z' [timestamp.lte]
    //   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.lte = { seconds: 1678867200 }];
    // }
    // ```
    google.protobuf.Timestamp lte = 4 [(predefined).cel = {
      id: "timestamp.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];

    // `lt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be less than the current time. `lt_now` can only be used with the `within` rule.
    //
    // ```proto
    // message MyTimestamp {
    //  // value must be less than now
    //   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.lt_now = true];
    // }
    // ```
    bool lt_now = 7 [(predefined).cel = {
      id: "timestamp.lt_now"
      expression: "(rules.lt_now && this > now) ? 'value must be less than now' : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the timestamp field value to be greater than the specified
    // value (exclusive). If the value of `gt` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyTimestamp {
    //   // timestamp must be greater than '2023-01-01T00:00:00Z' [timestamp.gt]
    //   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gt = { seconds: 1672444800 }];
    //
    //   // timestamp must be greater than '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gt_lt]
    //   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gt: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
    //
    //   // timestamp must be greater than '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gt_lt_exclusive]
    //   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gt: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
    // }
    // ```
    google.protobuf.Timestamp gt = 5 [
      (predefined).cel = {
        id: "timestamp.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the timestamp field value to be greater than or equal to the
    // specified value (exclusive). If the value of `gte` is larger than a
    // specified `lt` or `lte`, the range is reversed, and the field value
    // must be outside the specified range. If the field value doesn't meet
    // the required conditions, an error message is generated.
    //
    // ```proto
    // message MyTimestamp {
    //   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' [timestamp.gte]
    //   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gte = { seconds: 1672444800 }];
    //
    //   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gte_lt]
    //   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gte: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
    //
    //   // timestamp must be greater than or equal to '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gte_lt_exclusive]
    //   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gte: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
    // }
    // ```
    google.protobuf.Timestamp gte = 6 [
      (predefined).cel = {
        id: "timestamp.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];

    // `gt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be greater than the current time. `gt_now` can only be used with the `within` rule.
    //
    // ```proto
    // message MyTimestamp {
    //   // value must be greater than now
    //   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.gt_now = true];
    // }
    // ```
    bool gt_now = 8 [(predefined).cel = {
      id: "timestamp.gt_now"
      expression: "(rules.gt_now && this < now) ? 'value must be greater than now' : ''"
    }];
  }

  // `within` specifies that this field, of the `google.protobuf.Timestamp` type, must be within the specified duration of the current time. If the field value isn't within the duration, an error message is generated.
  //
  // ```proto
  // message MyTimestamp {
  //   // value must be within 1 hour of now
  //   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.within = {seconds: 3600}];
  // }
  // ```
  optional google.protobuf.Duration within = 9 [(predefined).cel = {
    id: "timestamp.within"
    expression: "this < now-rules.within || this > now+rules.within ? 'value must be within %s of now'.format([rules.within]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyTimestamp {
  //   google.protobuf.Timestamp value = 1 [
  //     (buf.validate.field).timestamp.example = { seconds: 1672444800 },
  //     (buf.validate.field).timestamp.example = { seconds: 1672531200 },
  //   ];
  // }
  // ```
  repeated google.protobuf.Timestamp example = 10 [(predefined).cel = {
    id: "timestamp.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// `Violations` is a collection of `Violation` messages. This message type is returned by
// Protovalidate when a proto message fails to meet the requirements set by the `Rule` validation rules.
// Each individual violation is represented by a `Violation` message.
message Violations {
  // `violations` is a repeated field that contains all the `Violation` messages corresponding to the violations detected.
  repeated Violation violations = 1;
}

// `Violation` represents a single instance where a validation rule, expressed
// as a `Rule`, was not met. It provides information about the field that
// caused the violation, the specific rule that wasn't fulfilled, and a
// human-readable error message.
//
// For example, consider the following message:
//
// ```proto
// message User {
//     int32 age = 1 [(buf.validate.field).cel = {
//         id: "user.age",
//         expression: "this < 18 ? 'User must be at least 18 years old' : ''",
//     }];
// }
// ```
//
// It could produce the following violation:
//
// ```json
// {
//   "ruleId": "user.age",
//   "message": "User must be at least 18 years old",
//   "field": {
//     "elements": [
//       {
//         "fieldNumber": 1,
//         "fieldName": "age",
//         "fieldType": "TYPE_INT32"
//       }
//     ]
//   },
//   "rule": {
//     "elements": [
//       {
//         "fieldNumber": 23,
//         "fieldName": "cel",
//         "fieldType": "TYPE_MESSAGE",
//         "index": "0"
//       }
//     ]
//   }
// }
// ```
message Violation {
  // `field` is a machine-readable path to the field that failed validation.
  // This could be a nested field, in which case the path will include all the parent fields leading to the actual field that caused the violation.
  //
  // For example, consider the following message:
  //
  // ```proto
  // message Message {
  //   bool a = 1 [(buf.validate.field).required = true];
  // }
  // ```
  //
  // It could produce the following violation:
  //
  // ```textproto
  // violation {
  //   field { element { field_number: 1, field_name: "a", field_type: 8 } }
  //   ...
  // }
  // ```
  optional FieldPath field = 5;

  // `rule` is a machine-readable path that points to the specific rule that failed validation.
  // This will be a nested field starting from the FieldRules of the field that failed validation.
  // For custom rules, this will provide the path of the rule, e.g. `cel[0]`.
  //
  // For example, consider the following message:
  //
  // ```proto
  // message Message {
  //   bool a = 1 [(buf.validate.field).required = true];
  //   bool b = 2 [(buf.validate.field).cel = {
  //     id: "custom_rule",
  //     expression: "!this ? 'b must be true': ''"
  //   }]
  // }
  // ```
  //
  // It could produce the following violations:
  //
  // ```textproto
  // violation {
  //   rule { element { field_number: 25, field_name: "required", field_type: 8 } }
  //   ...
  // }
  // violation {
  //   rule { element { field_number: 23, field_name: "cel", field_type: 11, index: 0 } }
  //   ...
  // }
  // ```
  optional FieldPath rule = 6;

  // `rule_id` is the unique identifier of the `Rule` that was not fulfilled.
  // This is the same `id` that was specified in the `Rule` message, allowing easy tracing of which rule was violated.
  optional string rule_id = 2;

  // `message` is a human-readable error message that describes the nature of the violation.
  // This can be the default error message from the violated `Rule`, or it can be a custom message that gives more context about the violation.
  optional string message = 3;

  // `for_key` indicates whether the violation was caused by a map key, rather than a value.
  optional bool for_key = 4;

  reserved 1;
  reserved "field_path";
}

// `FieldPath` provides a path to a nested protobuf field.
//
// This message provides enough information to render a dotted field path even without protobuf descriptors.
// It also provides enough information to resolve a nested field through unknown wire data.
message FieldPath {
  // `elements` contains each element of the path, starting from the root and recursing downward.
  repeated FieldPathElement elements = 1;
}

// `FieldPathElement` provides enough information to nest through a single protobuf field.
//
// If the selected field is a map or repeated field, the `subscript` value selects a specific element from it.
// A path that refers to a value nested under a map key or repeated field index will have a `subscript` value.
// The `field_type` field allows unambiguous resolution of a field even if descriptors are not available.
message FieldPathElement {
  // `field_number` is the field number this path element refers to.
  optional int32 field_number = 1;

  // `field_name` contains the field name this path element refers to.
  // This can be used to display a human-readable path even if the field number is unknown.
  optional string field_name = 2;

  // `field_type` specifies the type of this field. When using reflection, this value is not needed.
  //
  // This value is provided to make it possible to traverse unknown fields through wire data.
  // When traversing wire data, be mindful of both packed[1] and delimited[2] encoding schemes.
  //
  // [1]: https://protobuf.dev/programming-guides/encoding/#packed
  // [2]: https://protobuf.dev/programming-guides/encoding/#groups
  //
  // N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
  // can be explicitly used in Protocol Buffers 2023 Edition.
  optional google.protobuf.FieldDescriptorProto.Type field_type = 3;

  // `key_type` specifies the map key type of this field. This value is useful when traversing
  // unknown fields through wire data: specifically, it allows handling the differences between
  // different integer encodings.
  optional google.protobuf.FieldDescriptorProto.Type key_type = 4;

  // `value_type` specifies map value type of this field. This is useful if you want to display a
  // value inside unknown fields through wire data.
  optional google.protobuf.FieldDescriptorProto.Type value_type = 5;

  // `subscript` contains a repeated index or map key, if this path element nests into a repeated or map field.
  oneof subscript {
    // `index` specifies a 0-based index into a repeated field.
    uint64 index = 6;

    // `bool_key` specifies a map key of type bool.
    bool bool_key = 7;

    // `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64.
    int64 int_key = 8;

    // `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64.
    uint64 uint_key = 9;

    // `string_key` specifies a map key of type string.
    string string_key = 10;
  }
}



====================
FILE: D:\go-grpc-ecommerce-be\proto\cart\cart.proto
====================
syntax = "proto3";

// generated proto: protoc --go_out=./pb --go-grpc_out=./pb --proto_path=./proto --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative cart/cart.proto

option go_package = "github.com/luzmareto/go-grpc-ecommerce-be/pb/cart"; // import manual
import "common/base_response.proto";
import "buf/validate/validate.proto";

package cart;

service CartService {
    rpc AddProductToCart(AddProductToCartRequest) returns (AddProductToCartResponse);
    rpc ListCart(ListCartRequest) returns (ListCartResponse);
    rpc DeleteCart(DeleteCartRequest) returns (DeleteCartResponse);
    rpc UpdateCartQuantity(UpdateCartQuantityRequest) returns (UpdateCartQuantityResponse);
}

message AddProductToCartRequest {
    string product_id = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255}];
}

message AddProductToCartResponse {
    common.BaseResponse base = 1;
    string id = 2;
}

message ListCartRequest {}

message ListCartResponseItem {
    string cart_id = 1;
    string product_id = 2;
    string product_name = 3;
    string product_image_url = 4;
    double product_price = 5;
    int64 quantity = 6;
}

message ListCartResponse {
    common.BaseResponse base = 1;
    repeated ListCartResponseItem items = 2;
}

message DeleteCartRequest {
    string cart_id = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}

message DeleteCartResponse {
    common.BaseResponse base = 1;
}

message UpdateCartQuantityRequest {
    string cart_id = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
    int64 new_quantity = 2 [(buf.validate.field).int64.gte = 0];
}

message UpdateCartQuantityResponse {
    common.BaseResponse base = 1;
}



====================
FILE: D:\go-grpc-ecommerce-be\proto\common\base_response.proto
====================
syntax = "proto3";

option go_package = "github.com/luzmareto/go-grpc-ecommerce-be/pb/common"; //import manual

// generated proto: protoc --go_out=./pb --go-grpc_out=./pb --proto_path=./proto --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative common/base_response.proto

package common;

message ValidationError {
    string field = 1;
    string message= 2;
}

message BaseResponse {
    int64 status_code = 1;
    string message = 2;
    bool is_error = 3;
    repeated ValidationError validation_errors = 4;
}



====================
FILE: D:\go-grpc-ecommerce-be\proto\common\pagination.proto
====================
syntax = "proto3";

option go_package = "github.com/luzmareto/go-grpc-ecommerce-be/pb/common"; //import manual

// generated proto: protoc --go_out=./pb --go-grpc_out=./pb --proto_path=./proto --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative common/pagination.proto

package common;

message PaginationSortRequest {
    string field = 1;
    string direction = 2;
}

message PaginationRequest {
    int32 current_page = 1;
    int32 item_per_page = 2;
    PaginationSortRequest sort = 3;
}

message PaginationResponse {
    int32 current_page = 1;
    int32 total_page_count = 2;
    int32 item_per_page = 3;
    int32 total_item_count = 4;
}



====================
FILE: D:\go-grpc-ecommerce-be\proto\google\protobuf\timestamp.proto
====================
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";

package google.protobuf;

option cc_enable_arenas = true;
option go_package = "google.golang.org/protobuf/types/known/timestamppb";
option java_package = "com.google.protobuf";
option java_outer_classname = "TimestampProto";
option java_multiple_files = true;
option objc_class_prefix = "GPB";
option csharp_namespace = "Google.Protobuf.WellKnownTypes";

// A Timestamp represents a point in time independent of any time zone or local
// calendar, encoded as a count of seconds and fractions of seconds at
// nanosecond resolution. The count is relative to an epoch at UTC midnight on
// January 1, 1970, in the proleptic Gregorian calendar which extends the
// Gregorian calendar backwards to year one.
//
// All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
// second table is needed for interpretation, using a [24-hour linear
// smear](https://developers.google.com/time/smear).
//
// The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
// restricting to that range, we ensure that we can convert to and from [RFC
// 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
//
// # Examples
//
// Example 1: Compute Timestamp from POSIX `time()`.
//
//     Timestamp timestamp;
//     timestamp.set_seconds(time(NULL));
//     timestamp.set_nanos(0);
//
// Example 2: Compute Timestamp from POSIX `gettimeofday()`.
//
//     struct timeval tv;
//     gettimeofday(&tv, NULL);
//
//     Timestamp timestamp;
//     timestamp.set_seconds(tv.tv_sec);
//     timestamp.set_nanos(tv.tv_usec * 1000);
//
// Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
//
//     FILETIME ft;
//     GetSystemTimeAsFileTime(&ft);
//     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
//
//     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
//     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
//     Timestamp timestamp;
//     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
//     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
//
// Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
//
//     long millis = System.currentTimeMillis();
//
//     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
//         .setNanos((int) ((millis % 1000) * 1000000)).build();
//
// Example 5: Compute Timestamp from Java `Instant.now()`.
//
//     Instant now = Instant.now();
//
//     Timestamp timestamp =
//         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
//             .setNanos(now.getNano()).build();
//
// Example 6: Compute Timestamp from current time in Python.
//
//     timestamp = Timestamp()
//     timestamp.GetCurrentTime()
//
// # JSON Mapping
//
// In JSON format, the Timestamp type is encoded as a string in the
// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
// format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
// where {year} is always expressed using four digits while {month}, {day},
// {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
// seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
// are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
// is required. A proto3 JSON serializer should always use UTC (as indicated by
// "Z") when printing the Timestamp type and a proto3 JSON parser should be
// able to accept both UTC and other timezones (as indicated by an offset).
//
// For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
// 01:30 UTC on January 15, 2017.
//
// In JavaScript, one can convert a Date object to this format using the
// standard
// [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
// method. In Python, a standard `datetime.datetime` object can be converted
// to this format using
// [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
// the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
// the Joda Time's [`ISODateTimeFormat.dateTime()`](
// http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
// ) to obtain a formatter capable of generating timestamps in this format.
//
message Timestamp {
  // Represents seconds of UTC time since Unix epoch
  // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  // 9999-12-31T23:59:59Z inclusive.
  int64 seconds = 1;

  // Non-negative fractions of a second at nanosecond resolution. Negative
  // second values with fractions must still have non-negative nanos values
  // that count forward in time. Must be from 0 to 999,999,999
  // inclusive.
  int32 nanos = 2;
}



====================
FILE: D:\go-grpc-ecommerce-be\proto\order\order.proto
====================
syntax = "proto3";

option go_package = "github.com/luzmareto/go-grpc-ecommerce-be/pb/order"; // import manual
// generated proto: protoc --go_out=./pb --go-grpc_out=./pb --proto_path=./proto --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative order/order.proto
import "buf/validate/validate.proto";
import "common/base_response.proto";
import "common/pagination.proto";
import "google/protobuf/timestamp.proto";


package order;

service OrderService {
    rpc CreateOrder (CreateOrderRequest) returns (CreateOrderResponse);
    rpc ListOrderAdmin (ListOrderAdminRequest) returns (ListOrderAdminResponse);
    rpc ListOrder (ListOrderRequest) returns (ListOrderResponse);
    rpc DetailOrder (DetailOrderRequest) returns (DetailOrderResponse);
    rpc UpdateOrderStatus (UpdateOrderStatusRequest) returns (UpdateOrderStatusResponse);
}   

message CreateOrderRequestProductItem{
    string id = 1;
    int64 quantity = 2;
}

message CreateOrderRequest {
    string full_name = 1 [(buf.validate.field).string = {min_len: 1, max_len: 255}];
    string address = 2[(buf.validate.field).string = {min_len: 1, max_len: 255}];;
    string phone_number = 3[(buf.validate.field).string = {min_len: 1, max_len: 255}];;
    string notes = 4[(buf.validate.field).string = {max_len: 255}];;
    repeated CreateOrderRequestProductItem products = 5;
}

// list order

message CreateOrderResponse {
    common.BaseResponse base = 1;
    string id = 2;
}

message ListOrderAdminRequest {
    common.PaginationRequest pagination = 1;
}

message ListOrderAdminResponseItemProduct{
    string id = 1;
    string name = 2;
    double price = 3;
    int64 quantity = 4;
}

message ListOrderAdminResponseItem{
    string id = 1;
    string number = 2;
    string customer = 3;
    string status_code = 4;
    double total = 5;
    google.protobuf.Timestamp created_at = 6;
    repeated ListOrderAdminResponseItemProduct products = 7;
}

message ListOrderAdminResponse{
    common.BaseResponse base = 1;
    common.PaginationResponse pagination = 2;
    repeated ListOrderAdminResponseItem items = 3;
}

// list order

message ListOrderRequest {
    common.PaginationRequest pagination = 1;
}

message ListOrderResponseItemProduct{
    string id = 1;
    string name = 2;
    double price = 3;
    int64 quantity = 4;
}

message ListOrderResponseItem{
    string id = 1;
    string number = 2;
    string customer = 3;
    string status_code = 4;
    double total = 5;
    google.protobuf.Timestamp created_at = 6;
    repeated ListOrderResponseItemProduct products = 7;
    string xendit_nvoice_url = 8;
}

message ListOrderResponse{
    common.BaseResponse base = 1;
    common.PaginationResponse pagination = 2;
    repeated ListOrderResponseItem items = 3;
}

message DetailOrderRequest {
    string id = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}

message DetailOrderResponseItem {
    string id = 1;
    string name = 2;
    double price = 3;
    int64 quantity = 4;
}

message DetailOrderResponse {
    common.BaseResponse base = 1;
    string id = 2;
    string number = 3;
    string user_full_name = 4;
    string address = 5;
    string phone_number = 6;
    string notes = 7;
    string order_status_code = 8;
    google.protobuf.Timestamp created_at = 9;
    string xendit_invoice_url = 10;
    repeated DetailOrderResponseItem items = 11; 
    double total = 12;
    google.protobuf.Timestamp expired_at = 13;
}

message UpdateOrderStatusRequest {
    string order_id = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
    string new_status_code = 2 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}

message UpdateOrderStatusResponse {
    common.BaseResponse base = 1;
}



====================
FILE: D:\go-grpc-ecommerce-be\proto\product\product.proto
====================
syntax = "proto3";

option go_package = "github.com/luzmareto/go-grpc-ecommerce-be/pb/product"; //import manual
//protoc --go_out=./pb --go-grpc_out=./pb --proto_path=./proto --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative product/product.proto


import "common/base_response.proto";
import "common/pagination.proto";
import "buf/validate/validate.proto";

package product;

service ProductService {
    rpc CreateProduct (CreateProductRequest) returns (CreateProductResponse);
    rpc DetailProduct (DetailProductRequest) returns (DetailProductResponse);
    rpc EditProduct (EditProductRequest) returns (EditProductResponse);
    rpc DeleteProduct (DeleteProductRequest) returns (DeleteProductResponse);
    rpc ListProduct (ListProductRequest) returns (ListProductResponse);
    rpc ListProductAdmin (ListProductAdminRequest) returns (ListProductAdminResponse);
    rpc HighlightProducts (HighlightProductsRequest) returns (HighlightProductsResponse);
}

message CreateProductRequest {
    string name = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
    string description = 2 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
    double price = 3 [(buf.validate.field).double.gte = 0];
    string image_file_name = 4 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}

message CreateProductResponse {
    common.BaseResponse base = 1;
    string id = 2;    
}

message DetailProductRequest {
    string id  = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}

message DetailProductResponse {
    common.BaseResponse base = 1;
    string id = 2;    
    string name = 3;
    string description = 4;
    double price = 5;
    string image_url = 6;

}

message EditProductRequest {
    string id  = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
    string name = 2 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
    string description = 3 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
    double price = 4 [(buf.validate.field).double.gte = 0];
    string image_file_name = 5 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];

}

message EditProductResponse {
    common.BaseResponse base = 1;
    string id = 2;
}

message DeleteProductRequest {
    string id  = 1 [(buf.validate.field).string = { min_len: 1, max_len: 255 }];
}

message DeleteProductResponse {
    common.BaseResponse base = 1;
}

message ListProductRequest {
    common.PaginationRequest pagination = 1;
}

message ListProductResponseItem {
    string id = 1;
    string name = 2;
    string description = 3;
    double price = 4;
    string image_url = 5;
}

message ListProductResponse {
    common.BaseResponse base = 1;
    common.PaginationResponse pagination = 2;
    repeated ListProductResponseItem data = 3;
}


message ListProductAdminRequest {
    common.PaginationRequest pagination = 1;
}

message ListProductAdminResponseItem {
    string id = 1;
    string name = 2;
    string description = 3;
    double price = 4;
    string image_url = 5;
}

message ListProductAdminResponse {
    common.BaseResponse base = 1;
    common.PaginationResponse pagination = 2;
    repeated ListProductAdminResponseItem data = 3;
}

message HighlightProductsRequest {}

message HighlightProductsResponseItem {
    string id = 1;
    string name = 2;
    string description = 3;
    double price = 4;
    string image_url = 5;
}

message HighlightProductsResponse {
    common.BaseResponse base = 1;
    repeated HighlightProductsResponseItem data = 2;
}




====================
FILE: D:\go-grpc-ecommerce-be\proto\service\service.proto
====================
syntax = "proto3";

package service;
// generated proto: protoc --go_out=./pb --go-grpc_out=./pb --proto_path=./proto --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative service/service.proto

option go_package = "github.com/luzmareto/go-grpc-ecommerce-be/pb/service"; //import manual

import "common/base_response.proto";
import "buf/validate/validate.proto";

service HelloWorldService {
    rpc HelloWorld (HelloWordlRequest) returns (HelloWorldResponse);
}

message HelloWordlRequest {
    string name = 1 [(buf.validate.field).string = {min_len: 1, max_len: 255 }];
}

message HelloWorldResponse{
    common.BaseResponse base = 1;
    string message = 2;
}



